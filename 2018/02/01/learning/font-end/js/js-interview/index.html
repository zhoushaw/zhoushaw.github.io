<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>知识大杂烩 | zhou shaw</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="js," />
  

  <meta name="keywords" content="js">
<meta property="og:type" content="article">
<meta property="og:title" content="知识大杂烩">
<meta property="og:url" content="http://zhoushaw.github.io/2018/02/01/learning/font-end/js/js-interview/index.html">
<meta property="og:site_name" content="zhou shaw">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-04-14T13:54:11.949Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="知识大杂烩">

  

  
    <link rel="icon" href="https://s10.mogucdn.com/mlcdn/c45406/190317_10046af208g71l99jkg2cd2h3abaa_386x394.png">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">
<link href="/css/other.css?v=c114cbeddx" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  

  


  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

  <!-- 聊天系统 -->
  
    <script>
     (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
     daovoice('init', {
         app_id: 'b89c9b48'
       });
     daovoice('update');
   </script>
   
   <style>
      #modal {
        position: static !important;
      }
   </style>
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">导航</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">导航</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/categories/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tags/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#SEO"><span class="toc-text">SEO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XMLHttp-原生写法"><span class="toc-text">XMLHttp 原生写法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cookie、sessionStorage、localStorage"><span class="toc-text">cookie、sessionStorage、localStorage</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iframe特点"><span class="toc-text">iframe特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#web标准和w3c标准"><span class="toc-text">web标准和w3c标准</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XHTML和HTML"><span class="toc-text">XHTML和HTML</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Doctype作用-严格模式与混杂模式如何区分？它们有何意义"><span class="toc-text">Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#行内元素有哪些？块级元素有哪些？-空-void-元素有那些？行内元素和块级元素有什么区别？"><span class="toc-text">行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#闭包"><span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#作用域链"><span class="toc-text">作用域链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原型链"><span class="toc-text">原型链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#有赞"><span class="toc-text">有赞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP"><span class="toc-text">HTTP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#html5新特性"><span class="toc-text">html5新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#闭包-1"><span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#预加载"><span class="toc-text">预加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http缓存"><span class="toc-text">http缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#http缓存的介绍"><span class="toc-text">http缓存的介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何使用缓存技术"><span class="toc-text">如何使用缓存技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何禁止浏览器缓存input框的输入内容"><span class="toc-text">如何禁止浏览器缓存input框的输入内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#input框的属性"><span class="toc-text">input框的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组中有哪些方法"><span class="toc-text">数组中有哪些方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何检测css动画如何终止"><span class="toc-text">如何检测css动画如何终止</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-router如何实现的"><span class="toc-text">vue-router如何实现的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http的常见方法"><span class="toc-text">http的常见方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#正则表达式空格怎么表示"><span class="toc-text">正则表达式空格怎么表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie的操作，如何设置cookie的目录"><span class="toc-text">cookie的操作，如何设置cookie的目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#svg有用过吗，canvas如何使用"><span class="toc-text">svg有用过吗，canvas如何使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue的双向绑定原理是怎么样的"><span class="toc-text">vue的双向绑定原理是怎么样的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#你是怎么学习的"><span class="toc-text">你是怎么学习的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#transition有哪些属性，可以设置什么。同理去学习一下animation"><span class="toc-text">transition有哪些属性，可以设置什么。同理去学习一下animation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见的网络安全问题，如何解决sql注入，xss攻击，CSRF的防御"><span class="toc-text">常见的网络安全问题，如何解决sql注入，xss攻击，CSRF的防御</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#promise状态有哪些，有哪些方法。所有promise执行完了之后有个finally方法"><span class="toc-text">promise状态有哪些，有哪些方法。所有promise执行完了之后有个finally方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue的生命周期有哪些，分别做了什么"><span class="toc-text">vue的生命周期有哪些，分别做了什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#h5的离线存储"><span class="toc-text">h5的离线存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何防止使用js在浏览器中获取到cookie"><span class="toc-text">如何防止使用js在浏览器中获取到cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jsonp的跨域原理"><span class="toc-text">jsonp的跨域原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#input如何禁止浏览器缓存用户的登录信息"><span class="toc-text">input如何禁止浏览器缓存用户的登录信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#es6中如何实现双向绑定"><span class="toc-text">es6中如何实现双向绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#箭头函数和普通函数有什么区别"><span class="toc-text">箭头函数和普通函数有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件委托是如何实现的"><span class="toc-text">事件委托是如何实现的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#移动端的点击穿透是为什么"><span class="toc-text">移动端的点击穿透是为什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#box-sizing有哪些属性，那些元素是默认border-box的"><span class="toc-text">box-sizing有哪些属性，那些元素是默认border-box的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#background-clip属性和background-origin属性"><span class="toc-text">background-clip属性和background-origin属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#网页中使用什么类型的图片该如何取舍"><span class="toc-text">网页中使用什么类型的图片该如何取舍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何设置input框中占位信息的样式"><span class="toc-text">如何设置input框中占位信息的样式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何设置像五角星一样的不规则点击区域"><span class="toc-text">如何设置像五角星一样的不规则点击区域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scss有些什么功能，extend"><span class="toc-text">scss有些什么功能，extend</span></a></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-learning/font-end/js/js-interview" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">知识大杂烩</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2018.02.01</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>zhou shaw</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/js/">js</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
       
          <span class="post-count">
            <i class="fa fa-file-word-o"></i>&nbsp
            <span>字数统计 6.2k字</span>
          </span>

          <span class="post-count">
            <i class="fa fa-columns"></i>&nbsp
            <span>阅读时长 22分</span>
          </span>
      
    </div>
  </header>

  <div class="article-content">
    
      <p><div><a id="more"></a></div></p>
<h2 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h2><p>1.合理的title、description、keywords:搜索引擎对于三项的权重逐个减小。<br>2.使用语义化标签，爬虫更容易理解和抓取<br>3.重要内容不要使用js外部引入，爬虫不容易抓取<br>4.网页加载速度也是爬虫评判的重要标准<br>5.每个页要只能出现一次H1标签，H2~H6标签可以多次，这样做是为了加重H1标签的权重。 </p>
<h2 id="XMLHttp-原生写法"><a href="#XMLHttp-原生写法" class="headerlink" title="XMLHttp 原生写法"></a>XMLHttp 原生写法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">	xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHttp'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'get'</span>,<span class="string">'www.baidu.com'</span>,<span class="literal">true</span>);</span><br><span class="line">xhr.send();</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(xhr.readyState==<span class="number">4</span>&amp;&amp;xhr.status==<span class="number">200</span>)&#123;</span><br><span class="line">		alert(xhr.responseText)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote>
<p>修改原数组</p>
</blockquote>
<p>push<br>pop<br>shift<br>unshift<br>reverse<br>splice</p>
<blockquote>
<p>不修改原数组，返回处理的新数组</p>
</blockquote>
<p>slice<br>sort</p>
<h2 id="cookie、sessionStorage、localStorage"><a href="#cookie、sessionStorage、localStorage" class="headerlink" title="cookie、sessionStorage、localStorage"></a>cookie、sessionStorage、localStorage</h2><blockquote>
<p>区别</p>
</blockquote>
<ul>
<li><p>大小:</p>
<p>  cookie  – 5kb<br>  sessionStorage  – 5MB<br>  localStorage    – 5MB</p>
</li>
<li><p>使用场景:</p>
<p>  cookie  –  服务端在请求头报文中增加set-cookie，请求回来时自动将cookie存入本地。在同源http请求中将自动在request Head中携带cookie</p>
<p>  sessionStorage – 通常可以配合cookie使用，列如当用户登录淘宝后，访问的每个页面都需要保持持续登录，服务器会创建好session，<br>  并关联的session_id通过set-cookie添加到响应头中，浏览器接收到cookie后会将其存入指定位置，当发送同源的http请求时可以自动发送cookie</p>
<p>  localStorage  – 可以存储用户数据，可以用来存储token、userId内容，当登录成功后将获取到的token存入localStorage中，<br>  每个http请求头中添加token，这样也获得了持续验证</p>
</li>
<li><p>存储时间:</p>
<p>  cookie – 设置失效时间，到达失效时间后对应的cookie将消失</p>
<p>  sessionStorage  – 当对应的页面，标签或浏览器关闭后，sessionStorage将失效</p>
<p>  localStorage – 永久保存，只有同源域名下才可以访问到对应的localStorage</p>
</li>
</ul>
<h2 id="iframe特点"><a href="#iframe特点" class="headerlink" title="iframe特点"></a>iframe特点</h2><blockquote>
<p>优点</p>
</blockquote>
<p>更加快速构成网页结构，编写导航更加便捷</p>
<blockquote>
<p>缺点</p>
</blockquote>
<p>1.多个框架构成的网页代码变得更加复杂，不容易管理从而带来不好的用户体验<br>2.网络爬虫，读取到iframe时，找不到链接，认为该网站是死网站，放弃爬取该网站内容<br>3.网站前进后退按钮只对光标所在的页面生效<br>4.使用iframe会阻塞js的onload进程<br>5.iframe中的css和js必须外链引入增加http请求，降低性能</p>
<h2 id="web标准和w3c标准"><a href="#web标准和w3c标准" class="headerlink" title="web标准和w3c标准"></a>web标准和w3c标准</h2><blockquote>
<p>web标准</p>
</blockquote>
<p>web标准是由多个标准组成的: 结构化标准，表现标准，行为标准<br>对应标准也分为:<br>    1.结构化标准指XML和XHTML<br>    2.表现标准是指css<br>    3.行为标准w3c DOM和 ECMAScript</p>
<blockquote>
<p>w3c标准</p>
</blockquote>
<p>web标准中的大部分标准都是万维网联盟制定的，但也有些标准是其他组织进行制定的列如ECMAScript</p>
<h2 id="XHTML和HTML"><a href="#XHTML和HTML" class="headerlink" title="XHTML和HTML"></a>XHTML和HTML</h2><p>XML: 可扩展标记语言<br>HTML: 超文本链接<br>XHTML: 可扩展的超文本链接</p>
<blockquote>
<p>HTML</p>
</blockquote>
<p>网页内容标记语言，是一个标准，是网页构成的基本内容。<br>超文本的内容除了文本，还可以表示图片，音频，视频等内容。<br>它的作用是一个规范，告诉所有浏览器统一标准</p>
<blockquote>
<p>XML</p>
</blockquote>
<p>XML的表现形式上来说就是给文档加一堆标签，告诉文档对应部分的内容是什么。<br>这样做的目的是方便数据存储，传输，分享数据。也更加方便人和机器阅读<br>XML和HTML的区别是，HTML:是预定义的，再使用前就定义好了，不能凭空造一个新标签然后使用<br>而XML则不同，可以自己发明标签，也就是可扩展的意思</p>
<blockquote>
<p>XHTML </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">XHTML实际上就是HTML和XML的混合体，出现的原因是因为，HTML是一种语法比较松散的标记语言，语法要求也不严格。</span><br><span class="line">比如:不区分大小写，单引号和双引号都可以，属性值加不加引号都可以，所谓没有规矩不成方圆</span><br><span class="line">XHTML1<span class="number">.0</span>是基于HTML1<span class="number">.0</span>的，它没有引入任何新的标签和属性，XHTML 是更严格的HTML，它相当于HTML的子集.几乎所有能正确解析HTML的浏览器，都能兼容XHTML</span><br><span class="line">XML设计用来传送及携带数据信息，不用来表现或展示数据</span><br><span class="line">标签必须使用 /&gt;实现闭合例如&lt;br /&gt;而不能使用&lt;br&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Doctype作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#Doctype作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?"></a>Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</h2><blockquote>
<p>Doctype</p>
</blockquote>
<p>位于html标签前面，用来声明使用XML或XHTML规范</p>
<blockquote>
<p>严格模式</p>
</blockquote>
<p>所谓的严格模式是以浏览器支持的最高的w3c标准解析执行代码；</p>
<blockquote>
<p>混杂模式</p>
</blockquote>
<p>在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。</p>
<blockquote>
<p>何时出现对应模式</p>
</blockquote>
<p>浏览器使用严格模式还是混杂模式取决于，<br>html中的DTD(文档类型声明),文档中定义了标准的DTD声明，则会使网页使用对应的方法标准解析加载网页<br>忽略了文档中的DTD声明，则会采用</p>
<h2 id="行内元素有哪些？块级元素有哪些？-空-void-元素有那些？行内元素和块级元素有什么区别？"><a href="#行内元素有哪些？块级元素有哪些？-空-void-元素有那些？行内元素和块级元素有什么区别？" class="headerlink" title="行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？"></a>行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？</h2><blockquote>
<p>行内元素</p>
</blockquote>
<p>b,img,font,textarea,input,label,button,select,em,i,span,</p>
<blockquote>
<p>块元素</p>
</blockquote>
<p>div,p,section,header,table,tbody,tfoot,h1-h6,iframe,option,ul,li,ol,dl，address,tr,hr,br</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><blockquote>
<p>什么是闭包</p>
</blockquote>
<p>闭包其实就是可以读取其他函数变量的函数，这种引用的产生导致，变量将常驻内存导致无法释放</p>
<blockquote>
<p>如何使用闭包</p>
</blockquote>
<p>编写一个函数a，函数a里面有一个函数b，函数b里面引用了函数a内的变量</p>
<blockquote>
<p>闭包带来的优点和缺点</p>
</blockquote>
<p>在javascript中并没有私有变量这个概念，可以通过闭包来实现私有变量和私有方法，减少全局污染<br>使用闭包会造成变量常驻内存，使用不当容易造成内存泄漏，解决方法在函数退出前，将不适用的局部变量删除</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><blockquote>
<p>什么是作用域链</p>
</blockquote>
<p>作用域链是执行环境中函数和变量的可访问性是有序的，变量的访问权限是一直向上查找的，一直查找到windows停止。作用域向下访问时不允许的<br>简单的说作用域链就是函数和变量的可访问范围，即作用域链控制着函数和变量的生命周期和可访问性</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><blockquote>
<p>前言</p>
</blockquote>
<p>javascript中函数也是一个对象</p>
<blockquote>
<p>原型链prototype</p>
</blockquote>
<p>javascript中的函数可以当做构造函数使用，约定构造函数的首字母大写，使用new生成一个实例对象<br>每个函数再生成时都会附带一些原有属性，每个函数都有一个prototype属性指向这个函数的原型，原型里面自带<strong>proto</strong>属性和constructor<br>另外原型里面可以定义方法，在生成的实例对象中可以使用prototype定义的方法，生成的实例对象在调用方法时，首先会在自身上查找是否有该方法，<br>没有方法时会到构造函数的原型上查找，没有查找到通过<strong>proto</strong>向更上层的原型对象查找是否有该方法，直至找到Function.prototype。</p>
<p>如果需要实现继承，将要继承的函数的原型的proto等于继承函数的实例，因为继承函数的实例里面有<strong>proto</strong>可以查找到继承函数的原型，就可以使用继承函数的方法和变量了</p>
<p>生成的实例对象中含有<strong>proto</strong>这个属性，proto属性指向生成这个构造函数的原型，通过constructor可以找到这个实例对象的构造函数</p>
<p>而通过这个构造函数生成的实例对象会生成一个<strong>proto</strong>属性，这个属性指向它构造函数的prototype</p>
<h2 id="有赞"><a href="#有赞" class="headerlink" title="有赞"></a>有赞</h2><blockquote>
<p>为什么要离开现在公司</p>
</blockquote>
<p>公司的技术氛围不是很好，在公司发展受限</p>
<blockquote>
<p>常见算法时间复杂度，排序算法的时间复杂度</p>
</blockquote>
<p>O(n^2)</p>
<blockquote>
<p>position 有哪些属性，定位时根据什么进行定位</p>
</blockquote>
<p>属性:<br>    static<br>    relative<br>    absolute<br>    fixed</p>
<p>设置了static后，left和top不起作用<br>设置relative，left和top的偏移将会以自身当前位置做偏移<br>absolute，一直向上查询找到设置了属性为relative，absolute，fixed的父元素<br>fixed以窗口为基准进行偏移</p>
<blockquote>
<p>如何解决微信定位不准的问题</p>
</blockquote>
<p>使用wx.getLocation获取到当前经纬度，使用wx.request向腾讯的地图接口发送请求获取当前地址信息</p>
<blockquote>
<p>http三次握手</p>
</blockquote>
<p>白话翻译:<br>client-&gt; server 我要发送http请求了<br>server-client 可以你发吧<br>client-&gt; server 好，那我发送了</p>
<blockquote>
<p>js数据类型，及如何判断</p>
</blockquote>
<p>数据类型:<br>    boolean，object，string，null，undefined，number，symbol</p>
<p>typeof boolean  &gt; boolean<br>typeof object   &gt; object<br>typeof array    &gt; object<br>typeof function &gt; functioin<br>typeof null     &gt; object<br>typeof number   &gt; number<br>typeof undefined &gt; undefined</p>
<p>判断一个是否为对象时</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> type = <span class="keyword">typeof</span> item;</span><br><span class="line">    <span class="keyword">return</span> type ===<span class="string">'object'</span>||type===<span class="string">'function'</span>&amp;&amp;item!==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>判断其是否是dom对象</p>
</blockquote>
<p>dom.nodeType ===1,是dom对象</p>
<blockquote>
<p>小程序如何实现分享</p>
</blockquote>
<p>在js文件中定义onshareAppmessage，可以设置图片路径，标题，打开的页面路径<br>不设置图片和标题使用，图片使用当前页面截图，标题使用当前页面标题，或者首页标题，</p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><blockquote>
<p>常用的http方法</p>
</blockquote>
<p>get,post,head,put,delete,options,trace,connect，link</p>
<p>get获取远程资源<br>post传输实体<br>head获取请求头<br>put获取文件<br>delete删除远程服务器文件<br>connect与与远程服务器保持连接<br>options检测远程服务器是否支持指定类型的方法</p>
<blockquote>
<p>get与post文件区别</p>
</blockquote>
<p>浏览器会主动缓存get的请求，<br>get相对于post而言，post更加安全，因为get已明文的方式显示在地址栏上，而post放在request body中，抓包情况下一样<br>post使用request body进行传输，所以支持更多的数据传输长度，并且支持更多种数据类型，而浏览器的url长度有限</p>
<blockquote>
<p>http状态</p>
</blockquote>
<p>http是无状态的，不存储状态，使用http1.1开始自动建立持续连接</p>
<h2 id="html5新特性"><a href="#html5新特性" class="headerlink" title="html5新特性"></a>html5新特性</h2><blockquote>
<p>新增标签:</p>
</blockquote>
<p>语义化标签:<br>article，section，aside，header，footer</p>
<p>新特性标签:<br>video，canvas，audio，css3新动画特效</p>
<blockquote>
<p>去除的标签:</p>
</blockquote>
<p>basefont,u,tt,s,font</p>
<blockquote>
<p>css3特性</p>
</blockquote>
<p>1.选择器的扩展，属性选择器，后代选择器<br>2.边框，背景<br>3.渐变，阴影<br>4.盒模型</p>
<blockquote>
<p>标准盒模型，怪异盒模型</p>
</blockquote>
<p>标准盒模型的块宽度等于padding+margin+border+width<br>怪异盒模型的块宽度等于margin+width</p>
<h2 id="闭包-1"><a href="#闭包-1" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是什么？为什么产生闭包？闭包的作用？</p>
<blockquote>
<p>什么是闭包</p>
</blockquote>
<p>在了解闭包之前我们先来讲解一下作用域链，假设我们声明了一个函数b，b函数中包含一个函数a，而a函数中console.log(s);如果当前作用域没有s变量，则会向上一个作用域寻找s变量.假设函数b中有声明变量s，这个时候就形成了闭包<br>当我们在函数b中声明了变量s，并且return了函数a，这个时候函数a形成了闭包</p>
<blockquote>
<p>为什么会产生闭包</p>
</blockquote>
<p>根据垃圾回收机制，如果一个变量的引用不为0，那么这个变量就不会被释放，当这个变量一直不会释放就会一直存储在内存中，从而形成了我们所知的闭包。当将函数内部的函数返回出来，并且将返回的函数存入一个全局变量，那么这个全局变量不会被释放，所有内部的变量也不会被释放，变量将会一直保存在变量中</p>
<blockquote>
<p>闭包的作用</p>
</blockquote>
<p>在javascript中可以直接读取全局的变量，但是一个函数中不可以读取其他函数的变量。而闭包正好实现了一个变量读取其他函数的变量，闭包形成私有变量，减少全局变量的污染</p>
<h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><blockquote>
<p>preload的作用</p>
</blockquote>
<p>1.不阻塞渲染和document的onload事件<br>2.提前加载指定资源，不会出现字体半天才出现的情况</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"preload"</span> href=<span class="string">"style.css"</span> <span class="keyword">as</span>=<span class="string">"style"</span>&gt;</span><br><span class="line">&lt;link rel=<span class="string">"preload"</span> href=<span class="string">"main.js"</span> <span class="keyword">as</span>=<span class="string">"script"</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="http缓存"><a href="#http缓存" class="headerlink" title="http缓存"></a>http缓存</h2><h3 id="http缓存的介绍"><a href="#http缓存的介绍" class="headerlink" title="http缓存的介绍"></a>http缓存的介绍</h3><blockquote>
<p>为什么有http缓存，什么时候出现作用是什么</p>
</blockquote>
<p>http缓存也可以理解成客户端缓存，相当于客户端有个本地数据库，可以用于存储图片，js，这些常见的静态文件，分成强制缓存和协商缓存</p>
<blockquote>
<p>强制缓存</p>
</blockquote>
<p>当设置http请求头中设置了缓存类型为强制缓存时，会将资源缓存入本地，当再次发送请求获取这些资源的时候，会直接读取缓存在本地的这些数据，当本地数据库没有这些文件的时候才会从服务端读取</p>
<blockquote>
<p>协商缓存</p>
</blockquote>
<p>协商缓存又可以称之为对比缓存，客户端会首先从缓存数据库获取一个标识，得到标识后向服务端验证缓存的资源是否新鲜，如果该资源还是新鲜的资源，服务端会返回304，这时客户端会从本地读取缓存数据</p>
<blockquote>
<p>浏览器是如何判断本地缓存资源是否新鲜</p>
</blockquote>
<p>在客户端与服务端进行交互的时候会发送http请求，http请求是由请求头和请求体构成，在请求头中有cache-control中附带缓存信息，时间等数据信息，客户端可以根据这个来判断是否是新鲜数据</p>
<h3 id="如何使用缓存技术"><a href="#如何使用缓存技术" class="headerlink" title="如何使用缓存技术"></a>如何使用缓存技术</h3><blockquote>
<p>如何使用强制缓存</p>
</blockquote>
<p>对于强制缓存服务端会使用两个字段来表明，expires和cache-control</p>
<p>expires:</p>
<p>expires的值为服务端返回的数据到期时间，当再次请求时的请求时间小于expires的时间，客户端则直接使用缓存的数据，但由于服务端和客户端的时间可能有时间差，所以一般使用cache-control代替</p>
<p>cache-control:</p>
<p>cache-control有很多属性分别表示不同的缓存策略</p>
<p>private:    客户端可以缓存<br>public:        客户端和服务端都可以缓存<br>max-age=t    表明资源会在多少秒之后失效<br>no-cache:    表明使用协商缓存<br>no-store:    不使用缓存</p>
<blockquote>
<p>协商缓存</p>
</blockquote>
<p>协商缓存需要对比是否使用缓存，在客户端第一次向服务端发起请求的时候，服务端会向客户端发送缓存标识和缓存数据，客户端会将缓存数据存入本地，再次请求时客户端会将缓存标识发给服务端，当服务端会验证这个标识是否新鲜，当该资源新鲜时直接返回，304状态这时客户端会直接使用缓存文件，当资源不够新鲜时，服务端会直接发送最新的数据过来</p>
<p>Last-ModifiedLast-Modified:服务器在响应请求时，会告诉浏览器资源的最后修改时间。<br>if-Modified-Since:浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回304和响应报文头，浏览器只需要从缓存中获取信息即可。从字面上看，就是说:从某个时间节点算起，是否文件被修改了</p>
<p>如果真的被修改:那么开始传输响应一个整体，服务器返回:200 OK<br>如果没有被修改:那么只需传输响应header，服务器返回:304 Not Modified</p>
<p>if-Unmodified-Since:从字面上看, 就是说: 从某个时间点算起, 是否文件没有被修改</p>
<p>如果没有被修改:则开始`继续’传送文件: 服务器返回: 200 OK<br>如果文件被修改:则不传输,服务器返回: 412 Precondition failed (预处理错误)</p>
<p>这两个的区别是一个是修改了才下载一个是没修改才下载。Last-Modified 说好却也不是特别好，因为如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP1.1推出了Etag。</p>
<h3 id="如何禁止浏览器缓存input框的输入内容"><a href="#如何禁止浏览器缓存input框的输入内容" class="headerlink" title="如何禁止浏览器缓存input框的输入内容"></a>如何禁止浏览器缓存input框的输入内容</h3><p>input框有autocomplete属性，有on和off值，默认为on，设置为off即可</p>
<h3 id="input框的属性"><a href="#input框的属性" class="headerlink" title="input框的属性"></a>input框的属性</h3><blockquote>
<p>所有方法有</p>
</blockquote>
<p>image,radio,hidden,checkbox,password,reset,submit,text,button</p>
<h3 id="数组中有哪些方法"><a href="#数组中有哪些方法" class="headerlink" title="数组中有哪些方法"></a>数组中有哪些方法</h3><blockquote>
<p>会修改原数组的方法</p>
</blockquote>
<p>splice,sort,push,pop,shift,unshift,reverse,</p>
<blockquote>
<p>不会修改原数组的方法</p>
</blockquote>
<p>forEach,filter,some,every,map,reduce,join,slice,indexOf</p>
<blockquote>
<p>数组中的如何中断</p>
</blockquote>
<p>数组中的方法都不可以中断，return也无效。只有some和every为return false的时候会中断</p>
<h3 id="如何检测css动画如何终止"><a href="#如何检测css动画如何终止" class="headerlink" title="如何检测css动画如何终止"></a>如何检测css动画如何终止</h3><blockquote>
<p>通过事件监听transitionend，是否执行来判断是否执行结束</p>
</blockquote>
<p>el.addEventListener(‘transitionend’,function(){<br>    console.log(‘css动画结束’)<br>    // todo<br>})</p>
<h3 id="vue-router如何实现的"><a href="#vue-router如何实现的" class="headerlink" title="vue-router如何实现的"></a>vue-router如何实现的</h3><p>前端路由是直接找到与地址匹配的一个组件或对象并将其渲染出来。改变浏览器地址而不向服务器发出请求有两种方式: </p>
<ol>
<li>在地址中加入#以欺骗浏览器，地址的改变是由于正在进行页内导航 </li>
<li>使用H5的window.history功能，使用URL的Hash来模拟一个完整的URL。</li>
</ol>
<p>当打包构建应用时，Javascript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。</p>
<h3 id="http的常见方法"><a href="#http的常见方法" class="headerlink" title="http的常见方法"></a>http的常见方法</h3><blockquote>
<p>前面已经描述</p>
</blockquote>
<h3 id="正则表达式空格怎么表示"><a href="#正则表达式空格怎么表示" class="headerlink" title="正则表达式空格怎么表示"></a>正则表达式空格怎么表示</h3><blockquote>
<p>特殊字符</p>
</blockquote>
<p>^,$,.,*,+,{},[]</p>
<blockquote>
<p>正则修饰</p>
</blockquote>
<p>i: 不区分大小写<br>g: 全局匹配</p>
<blockquote>
<p>量词</p>
</blockquote>
<p>.:一个或零个<br>+:一个或多个<br>*:零个或多个<br>{1,}一个或多个<br>{1,6}一个到六个</p>
<blockquote>
<p>字符类</p>
</blockquote>
<p>\w:匹配单词字符，包括字母数字下划线<br>\s:匹配空格<br>\d:匹配数字<br>\t:匹配制表符<br>\r:匹配回车符<br>\n:匹配换行符</p>
<p>字符类大写后，表示相反</p>
<blockquote>
<p>字符串上的方法</p>
</blockquote>
<p>match:将匹配的内容当做数组返回，没有则返回null<br>replace: 接收两个参数，第一个正则，第二个替换成的内容，将匹配到的内容全部替换<br>search: 如果找到对应内容返回索引，否则返回-1</p>
<blockquote>
<p>正则上的方法</p>
</blockquote>
<p>test: 如何匹配到了返回true否则返回false<br>exec: 将第一次匹配到的内容和子匹配到的内容放入数组中</p>
<h3 id="cookie的操作，如何设置cookie的目录"><a href="#cookie的操作，如何设置cookie的目录" class="headerlink" title="cookie的操作，如何设置cookie的目录"></a>cookie的操作，如何设置cookie的目录</h3><blockquote>
<p>读取cookie</p>
</blockquote>
<p>document.cookie可以获取到cookie的值</p>
<blockquote>
<p>读取不太友好，需要自己封装，可以配合正则使用</p>
</blockquote>
<p>get: function (name){<br>        var cookieName = encodeURIComponent(name) + “=”,<br>            cookieStart = document.cookie.indexOf(cookieName),<br>            cookieValue = null;<br>        if (cookieStart &gt; -1){<br>            var cookieEnd = document.cookie.indexOf(“;”, cookieStart);<br>            if (cookieEnd == -1){<br>                cookieEnd = document.cookie.length;<br>            }<br>            cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd));<br>    }<br>        return cookieValue;<br>}</p>
<blockquote>
<p>写入</p>
</blockquote>
<p>set: function (name, value, expires, path, domain, secure) {<br>    var cookieText = encodeURIComponent(name) + “=” +<br>                        encodeURIComponent(value);<br>    if (expires instanceof Date) {<br>        cookieText += “; expires=” + expires.toGMTString();<br>    }<br>    if (path) {<br>        cookieText += “; path=” + path;<br>    }<br>    if (domain) {<br>        cookieText += “; domain=” + domain;<br>    }<br>    if (secure) {<br>        cookieText += “; secure”;<br>    }<br>    document.cookie = cookieText;<br>}</p>
<blockquote>
<p>删除cookie</p>
</blockquote>
<p>unset: function (name, path, domain, secure){<br>    this.set(name, “”, new Date(0), path, domain, secure);<br>}</p>
<blockquote>
<p>cookie安全</p>
</blockquote>
<p>HttpOnly=true   // 只能在发送http时携带，无法通过js读取到cookie<br>cookie被设置了Secure=true，那么这个cookie只能用https协议发送给服务器，用http协议是不发送的</p>
<h3 id="svg有用过吗，canvas如何使用"><a href="#svg有用过吗，canvas如何使用" class="headerlink" title="svg有用过吗，canvas如何使用"></a>svg有用过吗，canvas如何使用</h3><p>svg创建的是矢量图，使用xml构建，xml扩展描述语言出现比较早，内置rect，circle，line，等标签主要用于描述二维。每个图形都是dom节点可以绑定事件或用于修改<br>canvas画布，输出的是整个画布，就像一张图片一样放大会出现锯齿</p>
<h3 id="vue的双向绑定原理是怎么样的"><a href="#vue的双向绑定原理是怎么样的" class="headerlink" title="vue的双向绑定原理是怎么样的"></a>vue的双向绑定原理是怎么样的</h3><p>数据劫持(observer)=&gt;订阅者(watcher)=&gt;指令模板(complite)</p>
<h3 id="你是怎么学习的"><a href="#你是怎么学习的" class="headerlink" title="你是怎么学习的"></a>你是怎么学习的</h3><p>前期会看一下视频，后期主要是通过mdn系统学习api，在知乎掘金等社区发现好玩高效的特性，看源码</p>
<h3 id="transition有哪些属性，可以设置什么。同理去学习一下animation"><a href="#transition有哪些属性，可以设置什么。同理去学习一下animation" class="headerlink" title="transition有哪些属性，可以设置什么。同理去学习一下animation"></a>transition有哪些属性，可以设置什么。同理去学习一下animation</h3><blockquote>
<p>transition</p>
</blockquote>
<p>transition: property duration timing-function delay;</p>
<blockquote>
<p>transform</p>
</blockquote>
<p>transform: none|transform-functions;<br>none | matrix(n,n,n,n,n,n) | translate(x,y) | translate3d(x,y,z) | translateX(x) | translateY(y)</p>
<h3 id="常见的网络安全问题，如何解决sql注入，xss攻击，CSRF的防御"><a href="#常见的网络安全问题，如何解决sql注入，xss攻击，CSRF的防御" class="headerlink" title="常见的网络安全问题，如何解决sql注入，xss攻击，CSRF的防御"></a>常见的网络安全问题，如何解决sql注入，xss攻击，CSRF的防御</h3><blockquote>
<p>sql </p>
</blockquote>
<p>在提交表单时，里面输入sql语句，如果服务器端是使用sql拼接方式。则数据库可能遭到恶意修改</p>
<blockquote>
<p>xss</p>
</blockquote>
<p>将html标签或javascript注入到网页中，可以获取到用户的cookie，获增加恶意表单，用户提交时会将信息发送到攻击者的服务器上</p>
<p>在用户输入的地方要检测&lt;&gt;之类的标签</p>
<blockquote>
<p>csrf</p>
</blockquote>
<p>跨站伪造请求，原理很简单，假设我在论坛上发布了一篇文章，文章有一张图片，scr=”<a href="http://www.cnblogs.com/mvc/Follow/FollowBlogger.aspx?blogUserGuid=4e8c33d0-77fe-df11-ac81-842b2b196315&quot;,当你打开这篇文章的时候，src为自动发送http请求，并携带你的token。" target="_blank" rel="noopener">http://www.cnblogs.com/mvc/Follow/FollowBlogger.aspx?blogUserGuid=4e8c33d0-77fe-df11-ac81-842b2b196315&quot;,当你打开这篇文章的时候，src为自动发送http请求，并携带你的token。</a></p>
<p>我在我的文章中放了一个连接指向我的一个网站，我在网站内嵌入了iframe，在网页加载的时候我就使用iframe发送http请求，这个时候你的token就会自动添加到http中并进行发送，但由于同源策略这样是加载不出来的，新建一个页面用户存放iframe，当前页面src嵌入iframe</p>
<h3 id="promise状态有哪些，有哪些方法。所有promise执行完了之后有个finally方法"><a href="#promise状态有哪些，有哪些方法。所有promise执行完了之后有个finally方法" class="headerlink" title="promise状态有哪些，有哪些方法。所有promise执行完了之后有个finally方法"></a>promise状态有哪些，有哪些方法。所有promise执行完了之后有个finally方法</h3><blockquote>
<p>状态<br>peding</p>
</blockquote>
<h3 id="vue的生命周期有哪些，分别做了什么"><a href="#vue的生命周期有哪些，分别做了什么" class="headerlink" title="vue的生命周期有哪些，分别做了什么"></a>vue的生命周期有哪些，分别做了什么</h3><h3 id="h5的离线存储"><a href="#h5的离线存储" class="headerlink" title="h5的离线存储"></a>h5的离线存储</h3><h3 id="如何防止使用js在浏览器中获取到cookie"><a href="#如何防止使用js在浏览器中获取到cookie" class="headerlink" title="如何防止使用js在浏览器中获取到cookie"></a>如何防止使用js在浏览器中获取到cookie</h3><p>设置httpOnly=true,document.cookie = “”</p>
<h3 id="jsonp的跨域原理"><a href="#jsonp的跨域原理" class="headerlink" title="jsonp的跨域原理"></a>jsonp的跨域原理</h3><h3 id="input如何禁止浏览器缓存用户的登录信息"><a href="#input如何禁止浏览器缓存用户的登录信息" class="headerlink" title="input如何禁止浏览器缓存用户的登录信息"></a>input如何禁止浏览器缓存用户的登录信息</h3><p>autocomplete = false</p>
<h3 id="es6中如何实现双向绑定"><a href="#es6中如何实现双向绑定" class="headerlink" title="es6中如何实现双向绑定"></a>es6中如何实现双向绑定</h3><p>proxy代理实现，与Object.definedProperty不同，可以检测数组变化</p>
<h3 id="箭头函数和普通函数有什么区别"><a href="#箭头函数和普通函数有什么区别" class="headerlink" title="箭头函数和普通函数有什么区别"></a>箭头函数和普通函数有什么区别</h3><p>1.箭头函数作为匿名函数,是不能作为构造函数的,不能使用new<br>2.箭头函数不绑定arguments,取而代之用rest参数…解决<br>3.箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值<br>4.箭头函数当方法使用的时候没有定义this绑定<br>5.箭头函数没有原型属性<br>6.箭头函数不能当做Generator函数,不能使用yield关键字<br>7.箭头函数不能换行<br>8.箭头函数的this永远指向其上下文的 this，任何方法都改变不了其指向，如call(), bind(), apply()<br>普通函数的this指向调用它的那个对象</p>
<h3 id="事件委托是如何实现的"><a href="#事件委托是如何实现的" class="headerlink" title="事件委托是如何实现的"></a>事件委托是如何实现的</h3><p>在事件冒泡阶段，将事件代理到父元素上，通过currentTarget和target来查看触发元素的关系，通过这种方式来减少js，提高性能</p>
<h3 id="移动端的点击穿透是为什么"><a href="#移动端的点击穿透是为什么" class="headerlink" title="移动端的点击穿透是为什么"></a>移动端的点击穿透是为什么</h3><p>一般出现这种状况是click和touch事件混用出现的，因为click默认有200毫秒的延迟，而toucch事件没有延迟在弹窗消失后依然会触发click事件，导致底层元素点击事件触发</p>
<h3 id="box-sizing有哪些属性，那些元素是默认border-box的"><a href="#box-sizing有哪些属性，那些元素是默认border-box的" class="headerlink" title="box-sizing有哪些属性，那些元素是默认border-box的"></a>box-sizing有哪些属性，那些元素是默认border-box的</h3><p>content-box，可以通过这个元素将其设置成标准盒模型，和怪异盒模型</p>
<h3 id="background-clip属性和background-origin属性"><a href="#background-clip属性和background-origin属性" class="headerlink" title="background-clip属性和background-origin属性"></a>background-clip属性和background-origin属性</h3><p>background-clip是用于设置，背景图从什么位置开始显示的，border-box、content-box、padding-box<br>background-origin指定background-position以什么位置作为标点进行定位</p>
<h3 id="网页中使用什么类型的图片该如何取舍"><a href="#网页中使用什么类型的图片该如何取舍" class="headerlink" title="网页中使用什么类型的图片该如何取舍"></a>网页中使用什么类型的图片该如何取舍</h3><h3 id="如何设置input框中占位信息的样式"><a href="#如何设置input框中占位信息的样式" class="headerlink" title="如何设置input框中占位信息的样式"></a>如何设置input框中占位信息的样式</h3><p>input:[placehodler]{}<br>进行设置样式</p>
<h3 id="如何设置像五角星一样的不规则点击区域"><a href="#如何设置像五角星一样的不规则点击区域" class="headerlink" title="如何设置像五角星一样的不规则点击区域"></a>如何设置像五角星一样的不规则点击区域</h3><p>通过svg的polygon属性进行设置</p>
<h3 id="scss有些什么功能，extend"><a href="#scss有些什么功能，extend" class="headerlink" title="scss有些什么功能，extend"></a>scss有些什么功能，extend</h3><p>extend可以进行继承，<br>可以进行变量定义，可以for循环<br> mixins进行函数式编写css</p>

    
  </div>

</article>


   

   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2018/01/28/learning/java/java-basics/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2018/03/16/learning/font-end/vue/analyze-vue/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/categories/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tags/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    

<!-- Gitalk评论插件通用代码 -->
<div id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
const gitalk = new Gitalk({
  clientID: '50e2fd922f20a22ea2b4',
  clientSecret: '22a5d41a6a2065f383bdb78cb2191b6c82fe54a1',
  repo: 'zhoushaw.github.io',
  owner: 'zhoushaw',
  // 在这里设置一下截取前50个字符串, 这是因为 github 对 label 的长度有了要求, 如果超过
  // 50个字符串则会报错.
  // id: location.pathname.split('/').pop().substring(0, 49),
  id: location.pathname,
  admin: ['zhoushaw'],
  // facebook-like distraction free mode
  distractionFreeMode: false
})
gitalk.render('gitalk-container')
</script>
<!-- Gitalk代码结束 -->



  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
