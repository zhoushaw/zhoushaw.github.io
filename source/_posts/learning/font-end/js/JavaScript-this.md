---
title: JavaScript系列之this
date: 2019-4-23 10:22:35
categories: js
tags: js
---

## 前言

在JavaScript语言中存在一个`this`关键词，这个关键词指的是函数运行时所在的环境。由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（**context**）。所以，`this`就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。

前一个系列的**作用域**讲过,作用域运用的是词法作用域，意味着是编写时确定的，但**this**与其工作原理完全不同，它的指向并不是编写时确定的，而是运行时确定。

## 仅仅是“规则”

之前在阅读 You Don't Know JS系列的: **this & Object Prototypes**中，将this的指向总结了几条规则：


> 函数调用方式与内部`this`指针关系：

1. 直接调用:函数内部`this`指向全局对象`window`
2. 通过对象使用点来调用:函数内部this指向调用对象
3. 触发事件调用函数:函数内部的`this`指向触发事件的对象
4. 以`new`的方式来调用:函数内部`this`指向本次函数执行时对应的一个匿名对象（以new的方式创建的函数，函数名的首字母一般以大写字母开始）
5. 通过`call`的方法来间接调用方法:函数内部this指向`call`方法的第一参数对象,我们可以创建结构相同，但内容不同的对象


## 不仅仅是“规则”

参考了上面的规则发现，`this`的指向无论如何都逃脱不了上面的**5大原则**,那它们之前是否存在一定的规律呢，或者说是什么来决定`this`的指向的。

通常我们会对一下例子的结果没法准确的确定`this`指向：

```
var name = 'zhou';
var obj = {
    name: 'shaw',
    say: function () {
        console.log(this.name);
    }
}
obj.say();  

var say = obj.say;
say();
```

> 上面的输出结果会是什么呢：

```
obj.say(); // 输出shaw
say();  // 输出zhou
```

为什么这里`obj.say`和`say`的输出结果会不一致呢？下面我们来一探究竟。

`this`的指向与数据在内存里的数据结构有关:

上面案例里的`obj`对象是如何在内存中存储的呢

```
obj.say-> {
    [[value]]: say函数地址
    [[write]]: true,
    [[readable]]: true
}
```
实际上`say`函数并没有存储在`obj`对象中，它只存储了`say`函数的地址。

我们直接通过`obj.say`来调用函数，与`obj.say`赋值给`say`变量调用完全不同，因为`obj`中存储的是`say函数`的地址，我们进行赋值操作时直接将say函数地址直接赋值过去了，而不是我们想象的将`obj.say`引用赋值过去。


