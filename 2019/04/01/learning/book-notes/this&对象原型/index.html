<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>this &amp; 对象原型 | zhou shaw</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="js," />
  

  <meta name="description" content="一、this关键词this是关键词，表示指向的索引位置  很多人对于this最终指向常见的误解是，this是编写时绑定的，通常会将其认为成一下几种情况： 1、认为this指向，foo函数 1234function foo () &amp;#123;    console.log(this);&amp;#125;foo();">
<meta name="keywords" content="js">
<meta property="og:type" content="article">
<meta property="og:title" content="this &amp; 对象原型">
<meta property="og:url" content="http://zhoushaw.github.io/2019/04/01/learning/book-notes/this&对象原型/index.html">
<meta property="og:site_name" content="zhou shaw">
<meta property="og:description" content="一、this关键词this是关键词，表示指向的索引位置  很多人对于this最终指向常见的误解是，this是编写时绑定的，通常会将其认为成一下几种情况： 1、认为this指向，foo函数 1234function foo () &amp;#123;    console.log(this);&amp;#125;foo();">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://s10.mogucdn.com/mlcdn/c45406/190408_13k6cb57lifabic37gi0889i67250_253x333.png">
<meta property="og:updated_time" content="2019-04-23T13:22:02.323Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="this &amp; 对象原型">
<meta name="twitter:description" content="一、this关键词this是关键词，表示指向的索引位置  很多人对于this最终指向常见的误解是，this是编写时绑定的，通常会将其认为成一下几种情况： 1、认为this指向，foo函数 1234function foo () &amp;#123;    console.log(this);&amp;#125;foo();">
<meta name="twitter:image" content="https://s10.mogucdn.com/mlcdn/c45406/190408_13k6cb57lifabic37gi0889i67250_253x333.png">

  

  
    <link rel="icon" href="https://s10.mogucdn.com/mlcdn/c45406/190317_10046af208g71l99jkg2cd2h3abaa_386x394.png">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">
<link href="/css/other.css?v=c114cbeddx" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  

  


  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

  <!-- 聊天系统 -->
  
    <script>
     (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
     daovoice('init', {
         app_id: 'b89c9b48'
       });
     daovoice('update');
   </script>
   
   <style>
      #modal {
        position: static !important;
      }
   </style>
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">导航</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">导航</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/categories/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tags/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、this关键词"><span class="toc-text">一、this关键词</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#可以大致分为以下几种情况："><span class="toc-text">可以大致分为以下几种情况：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#仅仅是规则"><span class="toc-text">仅仅是规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#默认绑定"><span class="toc-text">默认绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#隐含绑定"><span class="toc-text">隐含绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#隐含丢失"><span class="toc-text">隐含丢失</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#明确绑定"><span class="toc-text">明确绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#API-调用的“环境”"><span class="toc-text">API 调用的“环境”</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new-绑定"><span class="toc-text">new 绑定</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一切皆有顺序"><span class="toc-text">一切皆有顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#绑定的特例"><span class="toc-text">绑定的特例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#被忽略的-this"><span class="toc-text">被忽略的 this</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#间接"><span class="toc-text">间接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#词法this"><span class="toc-text">词法this</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、对象"><span class="toc-text">二、对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#语法"><span class="toc-text">语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型"><span class="toc-text">类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本字面量"><span class="toc-text">基本字面量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性描述符"><span class="toc-text">属性描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置对象的几个方法"><span class="toc-text">设置对象的几个方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#防止扩展-Prevent-Extensions"><span class="toc-text">防止扩展(Prevent Extensions)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#封印（Seal）"><span class="toc-text">封印（Seal）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#冻结（Freeze）"><span class="toc-text">冻结（Freeze）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#混合（淆）“类”的对象"><span class="toc-text">混合（淆）“类”的对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、原型（Prototype）"><span class="toc-text">三、原型（Prototype）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-prototype"><span class="toc-text">Object.prototype</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置与遮蔽属性"><span class="toc-text">设置与遮蔽属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#“类”"><span class="toc-text">“类”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#“类”函数"><span class="toc-text">“类”函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-learning/book-notes/this&amp;对象原型" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">this &amp; 对象原型</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2019.04.01</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>zhou shaw</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/js/">js</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
       
          <span class="post-count">
            <i class="fa fa-file-word-o"></i>&nbsp
            <span>字数统计 4.7k字</span>
          </span>

          <span class="post-count">
            <i class="fa fa-columns"></i>&nbsp
            <span>阅读时长 17分</span>
          </span>
      
    </div>
  </header>

  <div class="article-content">
    
      <h2 id="一、this关键词"><a href="#一、this关键词" class="headerlink" title="一、this关键词"></a>一、this关键词</h2><p class="tip">this是关键词，表示指向的索引位置</p>

<p>很多人对于this最终指向常见的误解是，this是编写时绑定的，通常会将其认为成一下几种情况：</p>
<p>1、认为this指向，foo函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<div><a id="more"></a></div>

<p>2、认为this指向，obj对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	a: <span class="number">2</span>,</span><br><span class="line">	foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo; <span class="comment">// 函数引用！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">// `a` 也是一个全局对象的属性</span></span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// "oops, global"</span></span><br></pre></td></tr></table></figure>
<h3 id="可以大致分为以下几种情况："><a href="#可以大致分为以下几种情况：" class="headerlink" title="可以大致分为以下几种情况："></a>可以大致分为以下几种情况：</h3><p>函数调用方式与内部this指针关系<br>1.直接调用:函数内部this指向全局对象window<br>2.通过对象使用点来调用:函数内部this指向调用对象<br>3.触发事件调用函数:函数内部的this指向触发事件的对象<br>4.以new的方式来调用:函数内部this指向本次函数执行时对应的一个匿名对象（以new的方式创建的函数，函数名的首字母一般以大写字母开始）<br>构造函数 ，是一种特殊的方法。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。</p>
<p>5.通过call的方法来间接调用方法:函数内部this指向call方法的第一参数对象<br>有点:我们可以创建结构相同，但内容不同的对象</p>
<p>可参考: <a href="http://www.ruanyifeng.com/blog/2018/06/javascript-this.html" target="_blank" rel="noopener">JavaScript 的this原理</a></p>
<p>按照本文中的分类将其分为四大块：</p>
<p>默认绑定、隐含绑定、明确绑定、new 绑定</p>
<h3 id="仅仅是规则"><a href="#仅仅是规则" class="headerlink" title="仅仅是规则"></a>仅仅是规则</h3><p>this的最终指向可以将其分为大致四种规则</p>
<h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><p>我们要考察的第一种规则源于函数调用的最常见的情况：独立函数调用</p>
<p>在非<code>strict mode</code>模式下，独立函数调用默认指向全局对象window，在<code>strict mode</code>模式下默认绑定 来说全局对象是不合法，所以 <code>this</code> 将被设置为 <code>undefined</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">	console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = 2;</span><br><span class="line"></span><br><span class="line">foo(); // 2</span><br></pre></td></tr></table></figure>
<h4 id="隐含绑定"><a href="#隐含绑定" class="headerlink" title="隐含绑定"></a>隐含绑定</h4><p>另一种要考虑的规则是：调用点是否有一个环境对象（<code>context object</code>），也称为拥有者（<code>owning</code>）或容器（<code>containing</code>）对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">	console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">	a: 2,</span><br><span class="line">	foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo(); // 2</span><br></pre></td></tr></table></figure>
<p class="tip">无论 foo() 是否一开始就在 obj 上被声明，还是后来作为引用添加（如上面代码所示），这个 函数 都不被 obj 所真正“拥有”或“包含”.调用点 使用 obj 环境来 引用 函数，所以你 可以说 obj 对象在函数被调用的时间点上“拥有”或“包含”这个 函数引用。</p>


<p>只有对象属性引用链的最后一层是影响调用点的。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">	console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj2 = &#123;</span><br><span class="line">	a: 42,</span><br><span class="line">	foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;</span><br><span class="line">	a: 2,</span><br><span class="line">	obj2: obj2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj1.obj2.foo(); // 42</span><br></pre></td></tr></table></figure>
<h5 id="隐含丢失"><a href="#隐含丢失" class="headerlink" title="隐含丢失"></a>隐含丢失</h5><p>传递一个回调函数时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">	console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function doFoo(fn) &#123;</span><br><span class="line">	// `fn` 只不过 `foo` 的另一个引用</span><br><span class="line"></span><br><span class="line">	fn(); // &lt;-- 调用点!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">	a: 2,</span><br><span class="line">	foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var a = &quot;oops, global&quot;; // `a` 也是一个全局对象的属性</span><br><span class="line"></span><br><span class="line">doFoo( obj.foo ); // &quot;oops, global&quot;</span><br></pre></td></tr></table></figure>
<p>那么如果接收你所传递回调的函数不是你的，而是语言内建的呢？没有区别，同样的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">	console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">	a: 2,</span><br><span class="line">	foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var a = &quot;oops, global&quot;; // `a` 也是一个全局对象的属性</span><br><span class="line"></span><br><span class="line">setTimeout( obj.foo, 100 ); // &quot;oops, global&quot;</span><br></pre></td></tr></table></figure>
<p>正如我们刚刚看到的，我们的回调函数丢掉他们的 this 绑定是十分常见的事情。但是 this 使我们吃惊的另一种方式是，接收我们回调的函数故意改变调用的 this。那些很流行的 JavaScript 库中的事件处理器就十分喜欢强制你的回调的 this 指向触发事件的 DOM 元素。虽然有时这很有用，但其他时候这简直能气死人。不幸的是，这些工具很少给你选择。</p>
<h4 id="明确绑定"><a href="#明确绑定" class="headerlink" title="明确绑定"></a>明确绑定</h4><p>JavaScript 语言中的“所有”函数都有一些工具。具体地说，函数拥有 call(..) 和 apply(..) 方法。</p>
<p>这些工具如何工作？它们接收的第一个参数都是一个用于 this 的对象，之后使用这个指定的 this 来调用函数。因为你已经直接指明你想让 this 是什么，所以我们称这种方式为 明确绑定（explicit binding)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">	console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">	a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.call( obj ); // 2</span><br></pre></td></tr></table></figure>
<h5 id="API-调用的“环境”"><a href="#API-调用的“环境”" class="headerlink" title="API 调用的“环境”"></a>API 调用的“环境”</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo(el) &#123;</span><br><span class="line">	console.log( el, this.id );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">	id: &quot;awesome&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 使用 `obj` 作为 `this` 来调用 `foo(..)`</span><br><span class="line">[1, 2, 3].forEach( foo, obj ); // 1 awesome  2 awesome  3 awesome</span><br></pre></td></tr></table></figure>
<h4 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h4><p>当使用 new 操作符来初始化一个类时，这个类的构造器就会被调用。通常看起来像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">something = new MyClass(..);</span><br></pre></td></tr></table></figure>
<p class="tip">实际上 JavaScript 的机制和 new 在 JS 中的用法所暗示的面向类的功能 没有任何联系。在 JS 中，构造器 仅仅是一个函数，它们偶然地与前置的 new 操作符一起调用。它们不依附于类，它们也不初始化一个类。它们甚至不是一种特殊的函数类型。它们本质上只是一般的函数，在被使用 new 来调用时改变了行为。</p>

<blockquote>
<p>当在函数前面被加入 new 调用时，也就是构造器调用时，下面这些事情会自动完成：</p>
</blockquote>
<ul>
<li>一个全新的对象会凭空创建（就是被构建）</li>
<li>这个新构建的对象会被接入原形链（[[Prototype]]-linked）</li>
<li>这个新构建的对象被设置为函数调用的 this 绑定</li>
<li>除非函数返回一个它自己的其他 对象，否则这个被 new 调用的函数将 自动 返回这个新构建的对象。</li>
</ul>
<p>简单来说通过new方法初始化的构造器this指向函数本身</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line">	this.a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bar = new foo( 2 );</span><br><span class="line">console.log( bar.a ); // 2</span><br></pre></td></tr></table></figure>
<h3 id="一切皆有顺序"><a href="#一切皆有顺序" class="headerlink" title="一切皆有顺序"></a>一切皆有顺序</h3><p class="tip">上面已经揭示了四种this绑定最终指向的规则，但是指向的规则可能会出现重叠的情况，当两种以上的规则出现后如何抉择优先顺序呢。</p>

<ul>
<li>函数是通过 new 被调用的吗（new 绑定）？如果是，this 就是新构建的对象。<ul>
<li>var bar = new foo()</li>
</ul>
</li>
<li>函数是通过 call 或 apply 被调用（明确绑定），甚至是隐藏在 bind 硬绑定 之中吗？如果是，this 就是那个被明确指定的对象。<ul>
<li>var bar = foo.call( obj2 )</li>
</ul>
</li>
<li>函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（隐含绑定）？如果是，this 就是那个环境对象。<ul>
<li>var bar = obj1.foo()</li>
</ul>
</li>
<li>否则，使用默认的 this（默认绑定）。如果在 strict mode 下，就是 undefined，否则是 global 对象。<ul>
<li>var bar = foo()</li>
</ul>
</li>
</ul>
<h3 id="绑定的特例"><a href="#绑定的特例" class="headerlink" title="绑定的特例"></a>绑定的特例</h3><p>正如通常的那样，对于“规则”总有一些 例外。</p>
<h4 id="被忽略的-this"><a href="#被忽略的-this" class="headerlink" title="被忽略的 this"></a>被忽略的 this</h4><p class="tip">如果你传递 null 或 undefined 作为 call、apply 或 bind 的 this 绑定参数，那么这些值会被忽略掉，取而代之的是 默认绑定 规则将适用于这个调用。</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">	console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = 2;</span><br><span class="line"></span><br><span class="line">foo.call( null ); // 2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>更安全的 this</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo(a,b) &#123;</span><br><span class="line">	console.log( &quot;a:&quot; + a + &quot;, b:&quot; + b );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 我们的 DMZ 空对象</span><br><span class="line">var ø = Object.create( null );</span><br><span class="line"></span><br><span class="line">// 将数组散开作为参数</span><br><span class="line">foo.apply( ø, [2, 3] ); // a:2, b:3</span><br><span class="line"></span><br><span class="line">// 用 `bind(..)` 进行 currying</span><br><span class="line">var bar = foo.bind( ø, 2 );</span><br><span class="line">bar( 3 ); // a:2, b:3</span><br></pre></td></tr></table></figure>
<p>可以通过让其指向一个空对象，使其按照<code>硬绑定</code>原则进行</p>
<h4 id="间接"><a href="#间接" class="headerlink" title="间接"></a>间接</h4><p>通过赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">	console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = 2;</span><br><span class="line">var o = &#123; a: 3, foo: foo &#125;;</span><br><span class="line">var p = &#123; a: 4 &#125;;</span><br><span class="line"></span><br><span class="line">o.foo(); // 3</span><br><span class="line">(p.foo = o.foo)(); // 2</span><br></pre></td></tr></table></figure>
<h3 id="词法this"><a href="#词法this" class="headerlink" title="词法this"></a>词法this</h3><blockquote>
<p>一个箭头函数的词法绑定是不能被覆盖</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  // 返回一个箭头函数</span><br><span class="line">	return (a) =&gt; &#123;</span><br><span class="line">    // 这里的 `this` 是词法上从 `foo()` 采用的</span><br><span class="line">		console.log( this.a );</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;</span><br><span class="line">	a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj2 = &#123;</span><br><span class="line">	a: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var bar = foo.call( obj1 );</span><br><span class="line">bar.call( obj2 ); // 2, 不是3!</span><br></pre></td></tr></table></figure>
<blockquote>
<p>它们本质是使用广为人知的词法作用域来禁止了传统的 <code>this</code> 机制</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">	var self = this; // 词法上捕获 `this`</span><br><span class="line">	setTimeout( function()&#123;</span><br><span class="line">		console.log( self.a );</span><br><span class="line">	&#125;, 100 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">	a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.call( obj ); // 2</span><br></pre></td></tr></table></figure>
<h2 id="二、对象"><a href="#二、对象" class="headerlink" title="二、对象"></a>二、对象</h2><p>前面我们讲解了 this 绑定如何根据函数调用的调用点指向不同的对象。但究竟什么是对象，为什么我们需要指向它们？</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p class="tip">对象来自于两种形式：声明（字面）形式，和构造形式。</p>


<blockquote>
<p>一个对象的字面语法看起来像这样：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var myObj = &#123;</span><br><span class="line">	key: value</span><br><span class="line">	// ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>构造形式看起来像这样：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myObj = new Object();</span><br><span class="line">myObj.key = value;</span><br></pre></td></tr></table></figure>
<p>构造形式和字面形式的结果是完全同种类的对象。唯一真正的区别在于你可以向字面声明一次性添加一个或多个键/值对，而对于构造形式，你必须一个一个地添加属性。</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><blockquote>
<p>JS 的六种主要类型</p>
</blockquote>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>null</li>
<li>undefined</li>
<li>object</li>
</ul>
<blockquote>
<p>内建对象</p>
</blockquote>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Object</li>
<li>Function</li>
<li>Array</li>
<li>Date</li>
<li>RegExp</li>
<li>Error</li>
</ul>
<h3 id="基本字面量"><a href="#基本字面量" class="headerlink" title="基本字面量"></a>基本字面量</h3><p>在JavaScript中基本字面量会转换成对象</p>
<p class="tip">一般来说，我们通过基本字面量：<code>let str = &#39;hello world&#39;;</code>创建的字符串，他只是个基本类型按道理来说不存在属性，但通过<code>str.length</code>却可以轻松渠道str字符串的长度，这是怎么回事呢，原来JavaScript会将<strong>字面量形式的str</strong>，转变成<code>String</code>对象形式的字符串</p>

<blockquote>
<p>基本字面量转变成对象的类型</p>
</blockquote>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>RegExp</li>
</ul>
<blockquote>
<p>深浅拷贝</p>
</blockquote>
<p>在进行深浅拷贝前，我们先明确，基本数据类型和复杂类型赋值的不同：</p>
<ul>
<li>在我们进行赋值操作的时候，基本数据类型的赋值（=）是在内存中新开辟一段栈内存，然后再把再将值赋值到新的栈中</li>
<li>但是引用类型的赋值是传址。只是改变指针的指向，例如，也就是说引用类型的赋值是对象保存在栈中的地址的赋值，这样的话两个变量就指向同一个对象，因此两者之间操作互相有影响</li>
</ul>
<blockquote>
<p>赋值（=）和浅拷贝的区别</p>
</blockquote>
<p>浅复制只会将对象的各个属性进行依次复制，并不会进行递归复制，而 JavaScript 存储对象都是存地址的，所以浅复制会导致赋值后的对象属性指向同一个内存地址</p>
<h3 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h3><blockquote>
<p>获取对象属性性质</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">	a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor( myObject, &quot;a&quot; );</span><br><span class="line">// &#123;</span><br><span class="line">//    value: 2,</span><br><span class="line">//    writable: true,</span><br><span class="line">//    enumerable: true,</span><br><span class="line">//    configurable: true</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>明确定义一个属性</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty( myObject, &quot;a&quot;, &#123;</span><br><span class="line">	value: 2,</span><br><span class="line">	writable: true,</span><br><span class="line">	configurable: true,</span><br><span class="line">	enumerable: true</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">myObject.a; // 2</span><br></pre></td></tr></table></figure>
<p class="tip">使用 defineProperty(..)，我们手动、明确地在 myObject 上添加了一个直白的，普通的 a 属性。然而，你通常不会使用这种手动方法，除非你想要把描述符的某个性质修改为不同的值。</p>


<blockquote>
<p>修改属性性质</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">    a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty( myObject, &quot;a&quot;, &#123;</span><br><span class="line">	value: 2, </span><br><span class="line">	writable: true,</span><br><span class="line">	configurable: true,</span><br><span class="line">	enumerable: true </span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<ul>
<li>value<ul>
<li>默认值：设置的初始值</li>
</ul>
</li>
<li>writable<ul>
<li>可修改性</li>
<li>默认值：true</li>
<li>将属性设置true后，修改属性值，将会发生<code>TypeError</code>(如果你试图改变一个不可配置属性的描述符定义，就会发生 TypeError)</li>
</ul>
</li>
<li>configurable<ul>
<li>可配置性</li>
<li>能否通过defineProperty重新定义特性</li>
<li>设置false后无法，更改特性</li>
<li>默认值：true</li>
<li>阻止的另外一个事情是使用 delete 操作符移除既存属性的能力</li>
</ul>
</li>
<li>enumerable<ul>
<li>可遍历性</li>
<li>默认值：true</li>
</ul>
</li>
</ul>
<h3 id="设置对象的几个方法"><a href="#设置对象的几个方法" class="headerlink" title="设置对象的几个方法"></a>设置对象的几个方法</h3><h4 id="防止扩展-Prevent-Extensions"><a href="#防止扩展-Prevent-Extensions" class="headerlink" title="防止扩展(Prevent Extensions)"></a>防止扩展(Prevent Extensions)</h4><p><code>Object.preventExtensions(..)</code></p>
<p class="tip">不能添加新的属性</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">	a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.preventExtensions( myObject );</span><br><span class="line"></span><br><span class="line">myObject.b = 3;</span><br><span class="line">myObject.b; // undefined</span><br></pre></td></tr></table></figure>
<h4 id="封印（Seal）"><a href="#封印（Seal）" class="headerlink" title="封印（Seal）"></a>封印（Seal）</h4><p><code>Object.Seal(..)</code></p>
<p class="tip">它实质上在当前的对象上调用 Object.preventExtensions(..)、并且属性标记为 configurable:false</p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">	a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.Seal( myObject );</span><br></pre></td></tr></table></figure>
<h4 id="冻结（Freeze）"><a href="#冻结（Freeze）" class="headerlink" title="冻结（Freeze）"></a>冻结（Freeze）</h4><p><code>Object.freeze(..)</code></p>
<p class="tip">Object.freeze(..) 创建一个冻结的对象，这意味着它实质上在当前的对象上调用 Object.seal(..)，同时也将它所有的“数据访问”属性设置为 writable:false，所以它们的值不可改变。</p>

<h3 id="混合（淆）“类”的对象"><a href="#混合（淆）“类”的对象" class="headerlink" title="混合（淆）“类”的对象"></a>混合（淆）“类”的对象</h3><p>在JavaScript中是否存在一般语言类似于Java、C++类的概念，而JavaScript中的原型又是什么东西呢</p>
<p class="tip">在JavaScript中类并不是我们想象中的类，JavaScript还是基于原型的概念进行设计，尽管它看起来存在：<code>new</code>、<code>instanceof</code>这些让你以为它是类的东西</p>

<p>在开始了解前，我们先明白什么是类？</p>
<p>类是一种事物的抽象，拿建汽车来说，汽车需要：</p>
<ul>
<li>轮胎</li>
<li>发动机</li>
<li>后视镜等等…</li>
</ul>
<p>我们通过对汽车事物进行抽象，通过实例化产生新的汽车</p>
<p>并且类还包含继承、多态等概念：同样允许父类的泛化行为被子类覆盖，从而使它更加具体。实际上，相对多态允许我们在覆盖行为中引用基础行为</p>
<p>类的实例化上就是一个拷贝的过程，如下图：</p>
<p><img src="https://s10.mogucdn.com/mlcdn/c45406/190408_13k6cb57lifabic37gi0889i67250_253x333.png" alt=""></p>
<blockquote>
<p>JavaScript中的”类”</p>
</blockquote>
<p class="tip">当你“继承”或是“实例化”时，JavaScript 的对象机制不会 自动地 执行拷贝行为。很简单，在 JavaScript 中没有“类”可以拿来实例化，只有对象。而且对象也不会被拷贝到另一个对象中，而是被 链接在一起</p>

<p>在其他语言中观察到的类的行为意味着拷贝，让我们来看看 JS 开发者如何在 JavaScript 中 模拟 这种 缺失 的类的拷贝行为：mixins（混合）。我们会看到两种“mixin”：明确的（explicit） 和 隐含的（implicit）</p>
<h2 id="三、原型（Prototype）"><a href="#三、原型（Prototype）" class="headerlink" title="三、原型（Prototype）"></a>三、原型（Prototype）</h2><h3 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h3><p>每个 普通 的 [[Prototype]] 链的最顶端，是内建的 Object.prototype。这个对象包含各种在整个 JS 中被使用的共通工具，因为 JavaScript 中所有普通（内建，而非被宿主环境扩展的）的对象都“衍生自”（也就是，使它们的 [[Prototype]] 顶端为）Object.prototype 对象。</p>
<p>你会在这里发现一些你可能很熟悉的工具，比如 .toString() 和 .valueOf()</p>
<h3 id="设置与遮蔽属性"><a href="#设置与遮蔽属性" class="headerlink" title="设置与遮蔽属性"></a>设置与遮蔽属性</h3><p>如果给一个对象添加属性，而这个属性或方法已经在其<code>[[Prototype]]</code>上已存在，这时是否会展现出”多态”特性，子属性</p>
<p>让我们来看下面的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myObject.foo = &quot;bar&quot;;</span><br></pre></td></tr></table></figure>
<p>正如我们被暗示的那样，在 myObject 上的 foo 遮蔽没有看起来那么简单。我们现在来考察 myObject.foo = “bar” 赋值的三种场景，当 foo 不直接存在 于 myObject，但 存在 于 myObject 的 [[Prototype]] 链的更高层时：</p>
<ul>
<li>如果一个普通的名为 foo 的数据访问属性在 [[Prototype]] 链的高层某处被找到，而且没有被标记为只读（writable:false），那么一个名为 foo 的新属性就直接添加到 myObject 上，形成一个 遮蔽属性。</li>
<li>如果一个 foo 在 [[Prototype]] 链的高层某处被找到，但是它被标记为 只读（writable:false） ，那么设置既存属性和在 myObject 上创建遮蔽属性都是 不允许 的。如果代码运行在 strict mode 下，一个错误会被抛出。否则，这个设置属性值的操作会被无声地忽略。不论怎样，没有发生遮蔽。</li>
<li>如果一个 foo 在 [[Prototype]] 链的高层某处被找到。没有 foo 会被添加到（也就是遮蔽在）myObject 上。<strong>必须使用 Object.defineProperty(..)</strong></li>
</ul>
<h3 id="“类”"><a href="#“类”" class="headerlink" title="“类”"></a>“类”</h3><p>现在你可能会想知道：“为什么 一个对象需要链到另一个对象？” 真正的好处是什么？这是一个很恰当的问题，但在我们能够完全理解和体味它是什么和如何有用之前，我们必须首先理解 [[Prototype]] 不是 什么。</p>
<p>在 JavaScript 中，对于对象来说没有抽象模式/蓝图，即没有面向类的语言中那样的称为类的东西。JavaScript 只有 对象。</p>
<p>实际上，在所有语言中，JavaScript 几乎是独一无二的，也许是唯一的可以被称为“面向对象”的语言，因为可以根本没有类而直接创建对象的语言很少，而 JavaScript 就是其中之一。</p>
<p>在 JavaScript 中，类不能（因为根本不存在）描述对象可以做什么。对象直接定义它自己的行为。这里 仅有 对象。</p>
<h3 id="“类”函数"><a href="#“类”函数" class="headerlink" title="“类”函数"></a>“类”函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">	// ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = new Foo();</span><br><span class="line"></span><br><span class="line">Object.getPrototypeOf( a ) === Foo.prototype; // true</span><br></pre></td></tr></table></figure>
<p>在面向类的语言中，可以制造一个类的多个 拷贝（即“实例”），就像从模具中冲压出某些东西一样。我们在第四章中看到，这是因为初始化（或者继承）类的处理意味着，“将行为计划从这个类拷贝到物理对象中”，对于每个新实例这都会发生。</p>
<p>但是在 JavaScript 中，没有这样的拷贝处理发生。你不会创建类的多个实例。你可以创建多个对象，它们的 [[Prototype]] 连接至一个共通对象。但默认地，没有拷贝发生，如此这些对象彼此间最终不会完全分离和切断关系，而是 链接在一起。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当试图在一个对象上进行属性访问，而对象又没有该属性时，对象内部的 [[Prototype]] 链接定义了 [[Get]] 操作（见第三章）下一步应当到哪里寻找它。这种对象到对象的串行链接定义了对象的“原形链”（和嵌套的作用域链有些相似），在解析属性时发挥作用。</p>
<p>所有普通的对象用内建的 Object.prototype 作为原形链的顶端（就像作用域查询的顶端是全局作用域），如果属性没能在链条的前面任何地方找到，属性解析就会在这里停止。toString()，valueOf()，和其他几种共同工具都存在于这个 Object.prototype 对象上，这解释了语言中所有的对象是如何能够访问他们的。</p>
<p>在 JavaScript 中的关键区别是，没有拷贝发生。取而代之的是对象最终通过 [[Prototype]] 链链接在一起。</p>
<p class="tip">当一个属性/方法引用在一个对象上发生，而这样的属性/方法又不存在时，这个链接就会被使用。在这种情况下，[[Prototype]] 链接告诉引擎去那个被链接的对象上寻找该属性/方法。接下来，如果那个对象也不能满足查询，就沿着它的 [[Prototype]] 查询，如此继续。这种对象间的一系列链接构成了所谓的“原形链”。<br></p>



    
  </div>

</article>


   

   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2019/03/27/learning/font-end/js/module/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2019/04/01/learning/book-notes/types & grammar/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/categories/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tags/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    

<!-- Gitalk评论插件通用代码 -->
<div id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
const gitalk = new Gitalk({
  clientID: '50e2fd922f20a22ea2b4',
  clientSecret: '22a5d41a6a2065f383bdb78cb2191b6c82fe54a1',
  repo: 'zhoushaw.github.io',
  owner: 'zhoushaw',
  // 在这里设置一下截取前50个字符串, 这是因为 github 对 label 的长度有了要求, 如果超过
  // 50个字符串则会报错.
  // id: location.pathname.split('/').pop().substring(0, 49),
  id: location.pathname,
  admin: ['zhoushaw'],
  // facebook-like distraction free mode
  distractionFreeMode: false
})
gitalk.render('gitalk-container')
</script>
<!-- Gitalk代码结束 -->



  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
